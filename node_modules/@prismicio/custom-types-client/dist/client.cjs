"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const errors = require("./errors.cjs");
const DEFAULT_CUSTOM_TYPES_API_ENDPOINT = "https://customtypes.prismic.io";
const createPostFetchRequestInit = (body) => {
  return {
    method: "POST",
    body: JSON.stringify(body)
  };
};
const createClient = (...args) => new CustomTypesClient(...args);
class CustomTypesClient {
  constructor(config) {
    __publicField(this, "repositoryName");
    __publicField(this, "endpoint");
    __publicField(this, "token");
    __publicField(this, "fetchFn");
    this.repositoryName = config.repositoryName;
    this.endpoint = config.endpoint || DEFAULT_CUSTOM_TYPES_API_ENDPOINT;
    this.token = config.token;
    if (/\/customtypes\/?$/.test(this.endpoint)) {
      this.endpoint = this.endpoint.replace(/\/customtypes\/?$/, "");
    }
    if (typeof config.fetch === "function") {
      this.fetchFn = config.fetch;
    } else if (typeof globalThis.fetch === "function") {
      this.fetchFn = globalThis.fetch;
    } else {
      throw new errors.MissingFetchError("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` config parameter.");
    }
    if (this.fetchFn === globalThis.fetch) {
      this.fetchFn = this.fetchFn.bind(globalThis);
    }
  }
  async getAllCustomTypes(params) {
    return await this.fetch("./customtypes", params);
  }
  async getCustomTypeByID(id, params) {
    return await this.fetch(`./customtypes/${id}`, params);
  }
  async insertCustomType(customType, params) {
    await this.fetch("./customtypes/insert", params, createPostFetchRequestInit(customType));
    return customType;
  }
  async updateCustomType(customType, params) {
    await this.fetch("./customtypes/update", params, createPostFetchRequestInit(customType));
    return customType;
  }
  async removeCustomType(id, params) {
    await this.fetch(`./customtypes/${id}`, params, {
      method: "DELETE"
    });
    return id;
  }
  async getAllSharedSlices(params) {
    return await this.fetch("./slices", params);
  }
  async getSharedSliceByID(id, params) {
    return await this.fetch(`./slices/${id}`, params);
  }
  async insertSharedSlice(slice, params) {
    await this.fetch("./slices/insert", params, createPostFetchRequestInit(slice));
    return slice;
  }
  async updateSharedSlice(slice, params) {
    await this.fetch("./slices/update", params, createPostFetchRequestInit(slice));
    return slice;
  }
  async removeSharedSlice(id, params) {
    await this.fetch(`./slices/${id}`, params, {
      method: "DELETE"
    });
    return id;
  }
  async fetch(path, params = {}, requestInit = {}) {
    const endpoint = params.endpoint || this.endpoint;
    const url = new URL(path, endpoint.endsWith("/") ? endpoint : `${endpoint}/`).toString();
    const res = await this.fetchFn(url, {
      headers: {
        "Content-Type": "application/json",
        repository: params.repositoryName || this.repositoryName,
        Authorization: `Bearer ${params.token || this.token}`
      },
      signal: params.signal,
      ...requestInit
    });
    switch (res.status) {
      case 200: {
        return await res.json();
      }
      case 201:
      case 204: {
        return void 0;
      }
      case 400: {
        const text = await res.text();
        throw new errors.InvalidPayloadError(text, { url, response: text });
      }
      case 401: {
        const text = await res.text();
        throw new errors.UnauthorizedError(text, { url, response: text });
      }
      case 403: {
        const json = await res.json();
        throw new errors.ForbiddenError(json.message, { url, response: json });
      }
      case 409: {
        throw new errors.ConflictError("The provided ID is already used. A unique ID must be provided.", { url });
      }
      case 404:
      case 422: {
        throw new errors.NotFoundError("An entity with a matching ID could not be found.", { url });
      }
    }
    throw new errors.PrismicError("An invalid API response was returned", { url });
  }
}
exports.CustomTypesClient = CustomTypesClient;
exports.createClient = createClient;
//# sourceMappingURL=client.cjs.map
