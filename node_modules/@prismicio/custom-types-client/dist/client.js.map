{"version":3,"file":"client.js","sources":["../../src/client.ts"],"sourcesContent":["import type * as prismicT from \"@prismicio/types\";\n\nimport type { AbortSignalLike, FetchLike, RequestInitLike } from \"./types\";\nimport {\n\tPrismicError,\n\tMissingFetchError,\n\tConflictError,\n\tNotFoundError,\n\tForbiddenError,\n\tUnauthorizedError,\n\tInvalidPayloadError,\n} from \"./errors\";\n\n/**\n * The default endpoint for the Prismic Custom Types API.\n */\nconst DEFAULT_CUSTOM_TYPES_API_ENDPOINT = \"https://customtypes.prismic.io\";\n\n/**\n * Configuration for creating a `CustomTypesClient`.\n */\nexport type CustomTypesClientConfig = {\n\t/**\n\t * Name of the Prismic repository.\n\t */\n\trepositoryName: string;\n\n\t/**\n\t * The Prismic Custom Types API endpoint for the repository. The standard\n\t * Custom Types API endpoint will be used if no value is provided.\n\t */\n\tendpoint?: string;\n\n\t/**\n\t * The secure token for accessing the Prismic Custom Types API. This is\n\t * required to call any Custom Type API methods.\n\t */\n\ttoken: string;\n\n\t/**\n\t * The function used to make network requests to the Prismic Custom Types API.\n\t * In environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n};\n\n/**\n * Parameters for `CustomTypesClient` methods. Values provided here will\n * override the client's default values, if present.\n */\nexport type CustomTypesClientMethodParams = Partial<\n\tPick<CustomTypesClientConfig, \"repositoryName\" | \"endpoint\" | \"token\">\n>;\n\n/**\n * Parameters for any client method that use `fetch()`. Only a subset of\n * `fetch()` parameters are exposed.\n */\ntype FetchParams = {\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Create a `RequestInit` object for a POST `fetch` request. The provided body\n * will be run through `JSON.stringify`.\n *\n * @param body - The request's body.\n *\n * @returns The `RequestInit` object with the given body.\n */\nconst createPostFetchRequestInit = <T>(body: T): RequestInitLike => {\n\treturn {\n\t\tmethod: \"POST\",\n\t\tbody: JSON.stringify(body),\n\t};\n};\n\n/**\n * Create a client for the Prismic Custom Types API.\n */\nexport const createClient = (\n\t...args: ConstructorParameters<typeof CustomTypesClient>\n): CustomTypesClient => new CustomTypesClient(...args);\n\n/**\n * A client for the Prismic Custom Types API.\n *\n * @see Custom Types API documentation: {@link https://prismic.io/docs/technologies/custom-types-api}\n */\nexport class CustomTypesClient {\n\t/**\n\t * Name of the Prismic repository.\n\t */\n\trepositoryName: string;\n\n\t/**\n\t * The Prismic Custom Types API endpoint for the repository. The standard\n\t * Custom Types API endpoint will be used if no value is provided.\n\t *\n\t * @defaultValue `https://customtypes.prismic.io`\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the Prismic Custom Types API. This is\n\t * required to call any Custom Type API methods.\n\t */\n\ttoken: string;\n\n\t/**\n\t * The function used to make network requests to the Prismic Custom Types API.\n\t * In environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\t/**\n\t * Create a client for the Prismic Custom Types API.\n\t */\n\tconstructor(config: CustomTypesClientConfig) {\n\t\tthis.repositoryName = config.repositoryName;\n\t\tthis.endpoint = config.endpoint || DEFAULT_CUSTOM_TYPES_API_ENDPOINT;\n\t\tthis.token = config.token;\n\n\t\t// TODO: Remove the following `if` statement in v2.\n\t\t//\n\t\t// v1 erroneously assumed `/customtypes` would be part of\n\t\t// `this.endpoint`, forcing all custom endpoints to include\n\t\t// `/customtypes`.\n\t\t//\n\t\t// The client no longer assumes `/customtypes`. This `if`\n\t\t// statement ensures backwards compatibility with existing\n\t\t// custom endpoints that includes `/customtypes`.\n\t\tif (/\\/customtypes\\/?$/.test(this.endpoint)) {\n\t\t\tthis.endpoint = this.endpoint.replace(/\\/customtypes\\/?$/, \"\");\n\t\t}\n\n\t\tif (typeof config.fetch === \"function\") {\n\t\t\tthis.fetchFn = config.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch;\n\t\t} else {\n\t\t\tthrow new MissingFetchError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` config parameter.\",\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\t}\n\n\t/**\n\t * Returns all Custom Types models from the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The Custom Type returned from the API.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns All Custom Type models from the Prismic repository.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync getAllCustomTypes<TCustomType extends prismicT.CustomTypeModel>(\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType[]> {\n\t\treturn await this.fetch<TCustomType[]>(\"./customtypes\", params);\n\t}\n\n\t/**\n\t * Returns a Custom Type model with a given ID from the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The Custom Type returned from the API.\n\t * @param id - ID of the Custom Type.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The Custom Type model from the Prismic repository.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link NotFoundError} Thrown if a Custom Type with the given ID\n\t *   cannot be found.\n\t */\n\tasync getCustomTypeByID<TCustomType extends prismicT.CustomTypeModel>(\n\t\tid: string,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType> {\n\t\treturn await this.fetch<TCustomType>(`./customtypes/${id}`, params);\n\t}\n\n\t/**\n\t * Inserts a Custom Type model to the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The Custom Type to insert.\n\t * @param customType - The Custom Type to insert.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The inserted Custom Type.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Custom Type is\n\t *   provided.\n\t * @throws {@link ConflictError} Thrown if a Custom Type with the given ID\n\t *   already exists.\n\t */\n\tasync insertCustomType<TCustomType extends prismicT.CustomTypeModel>(\n\t\tcustomType: TCustomType,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType> {\n\t\tawait this.fetch<undefined>(\n\t\t\t\"./customtypes/insert\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(customType),\n\t\t);\n\n\t\treturn customType;\n\t}\n\n\t/**\n\t * Updates a Custom Type model from the Prismic repository.\n\t *\n\t * @typeParam TCustomType - The updated Custom Type.\n\t * @param customType - The updated Custom Type.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The updated Custom Type.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Custom Type is\n\t *   provided.\n\t * @throws {@link NotFoundError} Thrown if a Custom Type with the given ID\n\t *   cannot be found.\n\t */\n\tasync updateCustomType<TCustomType extends prismicT.CustomTypeModel>(\n\t\tcustomType: TCustomType,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomType> {\n\t\tawait this.fetch<undefined>(\n\t\t\t\"./customtypes/update\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(customType),\n\t\t);\n\n\t\treturn customType;\n\t}\n\n\t/**\n\t * Removes a Custom Type model from the Prismic repository.\n\t *\n\t * @typeParam TCustomTypeID - The ID of the Custom Type.\n\t * @param id - The ID of the Custom Type to remove.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The ID of the removed Custom Type.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync removeCustomType<TCustomTypeID extends string>(\n\t\tid: TCustomTypeID,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TCustomTypeID> {\n\t\tawait this.fetch<undefined>(`./customtypes/${id}`, params, {\n\t\t\tmethod: \"DELETE\",\n\t\t});\n\n\t\treturn id;\n\t}\n\n\t/**\n\t * Returns all Shared Slice models from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The Shared Slice model returned from the\n\t *   API.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns All Shared Slice models from the Prismic repository.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync getAllSharedSlices<TSharedSliceModel extends prismicT.SharedSliceModel>(\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel[]> {\n\t\treturn await this.fetch<TSharedSliceModel[]>(\"./slices\", params);\n\t}\n\n\t/**\n\t * Returns a Shared Slice model with a given ID from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The Shared Slice model returned from the\n\t *   API.\n\t * @param id - ID of the Shared Slice.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The Shared Slice model from the Prismic repository.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link NotFoundError} Thrown if a Shared Slice with the given ID\n\t *   cannot be found.\n\t */\n\tasync getSharedSliceByID<TSharedSliceModel extends prismicT.SharedSliceModel>(\n\t\tid: string,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel> {\n\t\treturn await this.fetch<TSharedSliceModel>(`./slices/${id}`, params);\n\t}\n\n\t/**\n\t * Inserts a Shared Slice model to the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The Shared Slice model to insert.\n\t * @param slice - The Shared Slice model to insert.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The inserted Shared Slice model.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Shared Slice model\n\t *   is provided.\n\t * @throws {@link ConflictError} Thrown if a Shared Slice with the given ID\n\t *   already exists.\n\t */\n\tasync insertSharedSlice<TSharedSliceModel extends prismicT.SharedSliceModel>(\n\t\tslice: TSharedSliceModel,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel> {\n\t\tawait this.fetch(\n\t\t\t\"./slices/insert\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(slice),\n\t\t);\n\n\t\treturn slice;\n\t}\n\n\t/**\n\t * Updates a Shared Slice model from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceModel - The updated Shared Slice model.\n\t * @param slice - The updated Shared Slice model.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The updated Shared Slice model.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if an invalid Shared Slice model\n\t *   is provided.\n\t * @throws {@link NotFoundError} Thrown if a Shared Slice with the given ID\n\t *   cannot be found.\n\t */\n\tasync updateSharedSlice<TSharedSliceModel extends prismicT.SharedSliceModel>(\n\t\tslice: TSharedSliceModel,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceModel> {\n\t\tawait this.fetch(\n\t\t\t\"./slices/update\",\n\t\t\tparams,\n\t\t\tcreatePostFetchRequestInit(slice),\n\t\t);\n\n\t\treturn slice;\n\t}\n\n\t/**\n\t * Removes a Shared Slice model from the Prismic repository.\n\t *\n\t * @typeParam TSharedSliceID - The ID of the Shared Slice.\n\t * @param id - The ID of the Shared Slice to remove.\n\t * @param params - Parameters to override the client's default configuration.\n\t *\n\t * @returns The ID of the removed Shared Slice.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t */\n\tasync removeSharedSlice<TSharedSliceID extends string>(\n\t\tid: TSharedSliceID,\n\t\tparams?: CustomTypesClientMethodParams & FetchParams,\n\t): Promise<TSharedSliceID> {\n\t\tawait this.fetch(`./slices/${id}`, params, {\n\t\t\tmethod: \"DELETE\",\n\t\t});\n\n\t\treturn id;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t * @param path - URL to the resource to fetch.\n\t * @param params - Parameters to override the client's default configuration.\n\t * @param requestInit - `RequestInit` overrides for the `fetch` request.\n\t *\n\t * @returns The response from the network request, if any.\n\t * @throws {@link ForbiddenError} Thrown if the client is unauthorized to make\n\t *   requests.\n\t * @throws {@link InvalidPayloadError} Thrown if the given body is invalid.\n\t * @throws {@link ConflictError} Thrown if an entity with the given ID already\n\t *   exists.\n\t * @throws {@link NotFoundError} Thrown if the requested entity could not be\n\t *   found.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\tpath: string,\n\t\tparams: Partial<CustomTypesClientMethodParams> & FetchParams = {},\n\t\trequestInit: RequestInitLike = {},\n\t): Promise<T> {\n\t\tconst endpoint = params.endpoint || this.endpoint;\n\t\tconst url = new URL(\n\t\t\tpath,\n\t\t\tendpoint.endsWith(\"/\") ? endpoint : `${endpoint}/`,\n\t\t).toString();\n\n\t\tconst res = await this.fetchFn(url, {\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\trepository: params.repositoryName || this.repositoryName,\n\t\t\t\tAuthorization: `Bearer ${params.token || this.token}`,\n\t\t\t},\n\t\t\tsignal: params.signal,\n\t\t\t...requestInit,\n\t\t});\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\t// - Successfully get one or more Custom Types\n\t\t\t// - Successfully get one or more Shared Slices\n\t\t\tcase 200: {\n\t\t\t\treturn await res.json();\n\t\t\t}\n\n\t\t\t// Created\n\t\t\t// - Successfully insert a Custom Type\n\t\t\t// - Successfully insert a Shared Slice\n\t\t\tcase 201:\n\t\t\t// No Content\n\t\t\t// - Successfully update a Custom Type\n\t\t\t// - Successfully delete a Custom Type\n\t\t\t// - Successfully update a Shared Slice\n\t\t\t// - Successfully delete a Shared Slice\n\t\t\tcase 204: {\n\t\t\t\t// We use `any` since we don't have a concrete value we can return. We\n\t\t\t\t// let the call site define what the return type is with the `T` generic.\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\treturn undefined as any;\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid body sent\n\t\t\tcase 400: {\n\t\t\t\tconst text = await res.text();\n\n\t\t\t\tthrow new InvalidPayloadError(text, { url, response: text });\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - User does not have access to requested repository\n\t\t\tcase 401: {\n\t\t\t\tconst text = await res.text();\n\n\t\t\t\tthrow new UnauthorizedError(text, { url, response: text });\n\t\t\t}\n\n\t\t\t// Forbidden\n\t\t\t// - Missing token\n\t\t\t// - Incorrect token\n\t\t\tcase 403: {\n\t\t\t\tconst json = await res.json();\n\n\t\t\t\tthrow new ForbiddenError(json.message, { url, response: json });\n\t\t\t}\n\n\t\t\t// Conflict\n\t\t\t// - Insert a Custom Type with same ID as an existing Custom Type\n\t\t\t// - Insert a Shared Slice with same ID as an existing Shared Slice\n\t\t\tcase 409: {\n\t\t\t\tthrow new ConflictError(\n\t\t\t\t\t\"The provided ID is already used. A unique ID must be provided.\",\n\t\t\t\t\t{ url },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Not Found\n\t\t\t// - Get a Custom Type with no matching ID\n\t\t\t// - Get a Shared Slice with no matching ID\n\t\t\tcase 404:\n\t\t\t// Unprocessable Entity\n\t\t\t// - Update a Custom Type with no matching ID\n\t\t\t// - Update a Shared Slice with no matching ID\n\t\t\tcase 422: {\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\t\"An entity with a matching ID could not be found.\",\n\t\t\t\t\t{ url },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(\"An invalid API response was returned\", { url });\n\t}\n}\n"],"names":[],"mappings":"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"}