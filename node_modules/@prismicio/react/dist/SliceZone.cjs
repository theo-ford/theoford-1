"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const pascalCase = require("./lib/pascalCase.cjs");
const TODOSliceComponent = ({ slice }) => {
  if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
    const type = "slice_type" in slice ? slice.slice_type : slice.type;
    console.warn(`[SliceZone] Could not find a component for Slice type "${type}"`, slice);
    return /* @__PURE__ */ jsxRuntime.jsxs("section", { "data-slice-zone-todo-component": "", "data-slice-type": type, children: [
      "Could not find a component for Slice type “",
      type,
      "”"
    ] });
  } else {
    return null;
  }
};
function SliceZone({ slices = [], components = {}, resolver, defaultComponent = TODOSliceComponent, context = {} }) {
  if (process.env.NODE_ENV === "development") {
    if (resolver) {
      console.warn("The `resolver` prop is deprecated. Please replace it with a components map using the `components` prop.");
    }
  }
  const renderedSlices = slices.map((slice, index) => {
    const type = "slice_type" in slice ? slice.slice_type : slice.type;
    let Comp = components[type] || defaultComponent;
    if (resolver) {
      const resolvedComp = resolver({
        slice,
        sliceName: pascalCase.pascalCase(type),
        i: index
      });
      if (resolvedComp) {
        Comp = resolvedComp;
      }
    }
    const key = "id" in slice && slice.id ? slice.id : `${index}-${JSON.stringify(slice)}`;
    if (slice.__mapped) {
      const { __mapped, ...mappedProps } = slice;
      return /* @__PURE__ */ jsxRuntime.jsx(Comp, { ...mappedProps }, key);
    } else {
      return /* @__PURE__ */ jsxRuntime.jsx(Comp, { slice, index, slices, context }, key);
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderedSlices });
}
exports.SliceZone = SliceZone;
exports.TODOSliceComponent = TODOSliceComponent;
//# sourceMappingURL=SliceZone.cjs.map
