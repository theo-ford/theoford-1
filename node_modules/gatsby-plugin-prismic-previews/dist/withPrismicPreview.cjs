"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const React = require("react");
const getActiveRepositoryName = require("./lib/getActiveRepositoryName.cjs");
const getComponentDisplayName = require("./lib/getComponentDisplayName.cjs");
const useMergePrismicPreviewData = require("./useMergePrismicPreviewData.cjs");
const usePrismicPreviewStore = require("./usePrismicPreviewStore.cjs");
const _interopNamespaceDefaultOnly = (e) => Object.freeze(Object.defineProperty({ __proto__: null, default: e }, Symbol.toStringTag, { value: "Module" }));
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
const withPrismicPreview = (WrappedComponent) => {
  const WithPrismicPreview = (props) => {
    const isBootstrapped = usePrismicPreviewStore.usePrismicPreviewStore((state) => state.isBootstrapped);
    const [isPrismicPreview, setIsPrismicPreview] = React__namespace.useState(null);
    const mergedData = useMergePrismicPreviewData.useMergePrismicPreviewData(props.data);
    React__namespace.useEffect(() => {
      const abortController = new AbortController();
      if (!isBootstrapped) {
        const repositoryName = getActiveRepositoryName.getActiveRepositoryName();
        setIsPrismicPreview(!!repositoryName);
        if (repositoryName) {
          Promise.resolve().then(() => /* @__PURE__ */ _interopNamespaceDefaultOnly(require("./lib/bootstrapPrismicPreview.cjs"))).then((mod) => mod.default(repositoryName, abortController));
        }
      }
      return () => abortController.abort();
    }, [isBootstrapped]);
    return /* @__PURE__ */ jsxRuntime.jsx(WrappedComponent, { ...props, data: mergedData, originalData: props.data, isPrismicPreview });
  };
  if (process.env.NODE_ENV === "development") {
    const wrappedComponentName = getComponentDisplayName.getComponentDisplayName(WrappedComponent);
    WithPrismicPreview.displayName = `withPrismicPreview(${wrappedComponentName})`;
  }
  return WithPrismicPreview;
};
exports.withPrismicPreview = withPrismicPreview;
//# sourceMappingURL=withPrismicPreview.cjs.map
