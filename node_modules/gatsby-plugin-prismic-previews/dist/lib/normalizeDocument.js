import { asLink, CustomTypeModelFieldType, isFilled, asHTML, asText, CustomTypeModelSliceType } from "@prismicio/client";
import { getImageData } from "gatsby-plugin-image";
import { buildURL } from "imgix-url-builder";
import { DEFAULT_IMGIX_PARAMS } from "../constants.js";
import { getDocument } from "./getDocument.js";
import { hasOwnProperty } from "./hasOwnProperty.js";
import { pascalCase } from "./pascalCase.js";
import { uuid } from "./uuid.js";
const defaultTransformFieldName = (fieldName) => {
  return fieldName.replace(/-/g, "_");
};
const withDocumentProxy = (target, repositoryConfig) => {
  return new Proxy(target, {
    get(target2, prop, receiver) {
      if (prop === "document") {
        if (hasOwnProperty(target2, "id") && typeof target2.id === "string") {
          return getDocument(target2.id) || null;
        }
      } else if (prop === "url") {
        if (hasOwnProperty(target2, "id") && typeof target2.id === "string") {
          const document = getDocument(target2.id);
          if (document) {
            return asLink(document.raw, {
              linkResolver: repositoryConfig.linkResolver
            });
          }
        }
      }
      return Reflect.get(target2, prop, receiver);
    }
  });
};
const imgixGatsbyImageDataUrlBuilder = (args) => {
  return buildURL(args.baseUrl, {
    ...DEFAULT_IMGIX_PARAMS,
    ...args.options.imageImgixParams,
    fm: args.format && args.format !== "auto" ? args.format : void 0,
    w: args.width,
    h: args.height
  });
};
const normalizeImageField = (image, pluginOptions) => {
  return {
    ...image,
    get url() {
      if (isFilled.image(image)) {
        return buildURL(image.url, {
          ...DEFAULT_IMGIX_PARAMS,
          ...pluginOptions.imageImgixParams
        });
      } else {
        return null;
      }
    },
    get gatsbyImageData() {
      if (isFilled.image(image)) {
        return getImageData({
          baseUrl: image.url,
          sourceWidth: image.dimensions.width,
          sourceHeight: image.dimensions.height,
          urlBuilder: imgixGatsbyImageDataUrlBuilder,
          options: {
            imageImgixParams: pluginOptions.imageImgixParams
          }
        });
      } else {
        return null;
      }
    },
    get localFile() {
      if (isFilled.image(image)) {
        return {
          publicURL: image.url,
          childImageSharp: {
            get gatsbyImageData() {
              return getImageData({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                baseUrl: image.url,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                sourceWidth: image.dimensions.width,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                sourceHeight: image.dimensions.height,
                urlBuilder: imgixGatsbyImageDataUrlBuilder,
                options: {
                  imageImgixParams: pluginOptions.imageImgixParams
                }
              });
            }
          }
        };
      } else {
        return null;
      }
    }
  };
};
const normalizeField = async (looseModel, looseValue, path, sharedSliceModels, repositoryConfig, pluginOptions) => {
  switch (looseModel == null ? void 0 : looseModel.type) {
    case CustomTypeModelFieldType.Slices: {
      const value = looseValue;
      if (isFilled.sliceZone(value)) {
        return await Promise.all(value.map(async (slice) => {
          var _a, _b;
          const model = looseModel;
          const sliceModel = (_b = (_a = model.config) == null ? void 0 : _a.choices) == null ? void 0 : _b[slice.slice_type];
          if (sliceModel) {
            const result = {
              ...slice,
              id: uuid(),
              __typename: pascalCase("Prismic", pluginOptions.typePrefix, ...path, slice.slice_type)
            };
            if (sliceModel.type === CustomTypeModelSliceType.Slice) {
              result.primary = await normalizeFields(slice.primary, sliceModel["non-repeat"] || {}, [...path, slice.slice_type, "primary"], sharedSliceModels, repositoryConfig, pluginOptions);
              result.items = await Promise.all(slice.items.map(async (item) => {
                return await normalizeFields(item, sliceModel.repeat || {}, [...path, slice.slice_type, "item"], sharedSliceModels, repositoryConfig, pluginOptions);
              }));
            } else if (sliceModel.type === CustomTypeModelSliceType.SharedSlice) {
              const typedSlice = slice;
              const sharedSliceModel = sharedSliceModels.find((m) => m.id === slice.slice_type);
              const variationModel = sharedSliceModel == null ? void 0 : sharedSliceModel.variations.find((m) => m.id === typedSlice.variation);
              if (sharedSliceModel && variationModel) {
                result.__typename = pascalCase("Prismic", pluginOptions.typePrefix, sharedSliceModel.id);
                result.primary = await normalizeFields(slice.primary, variationModel.primary || {}, [...path, slice.slice_type, "primary"], sharedSliceModels, repositoryConfig, pluginOptions);
                result.items = await Promise.all(slice.items.map(async (item) => {
                  return await normalizeFields(item, variationModel.items || {}, [...path, slice.slice_type, "item"], sharedSliceModels, repositoryConfig, pluginOptions);
                }));
              }
            }
            return result;
          } else {
            return slice;
          }
        }));
      } else {
        return [];
      }
    }
    case CustomTypeModelFieldType.Group: {
      const value = looseValue;
      if (isFilled.group(value)) {
        return await Promise.all(value.map(async (item) => {
          var _a;
          const model = looseModel;
          return await normalizeFields(item, ((_a = model.config) == null ? void 0 : _a.fields) || {}, path, sharedSliceModels, repositoryConfig, pluginOptions);
        }));
      } else {
        return [];
      }
    }
    case CustomTypeModelFieldType.Link: {
      const value = looseValue;
      const result = {
        ...value,
        target: "target" in value && value.target ? value.target || null : void 0,
        url: asLink(value, { linkResolver: repositoryConfig.linkResolver }) ?? null,
        raw: value,
        localFile: null
      };
      if (value.link_type === "Media" && "url" in value && value.url) {
        result.localFile = {
          publicURL: value.url
        };
      }
      return withDocumentProxy(result, repositoryConfig);
    }
    case CustomTypeModelFieldType.StructuredText: {
      const value = looseValue;
      return {
        get html() {
          if (isFilled.richText(value)) {
            return asHTML(value, {
              linkResolver: repositoryConfig.linkResolver,
              serializer: repositoryConfig.htmlSerializer
            });
          } else {
            return null;
          }
        },
        get text() {
          if (isFilled.richText(value)) {
            return asText(value);
          } else {
            return null;
          }
        },
        richText: value,
        raw: value
      };
    }
    case CustomTypeModelFieldType.Image: {
      const value = looseValue;
      const result = {
        ...normalizeImageField(value, pluginOptions),
        get thumbnails() {
          var _a;
          const model = looseModel;
          const transformFieldName = repositoryConfig.transformFieldName || defaultTransformFieldName;
          if ((_a = model.config) == null ? void 0 : _a.thumbnails) {
            const thumbnails = {};
            for (const thumbnailModel of model.config.thumbnails) {
              const transformedThumbnailName = transformFieldName(thumbnailModel.name);
              thumbnails[transformedThumbnailName] = normalizeImageField(value[thumbnailModel.name], pluginOptions);
            }
            return thumbnails;
          } else {
            return void 0;
          }
        }
      };
      return result;
    }
    default: {
      return looseValue;
    }
  }
};
const normalizeFields = async (fields, models, path, sharedSliceModels, repositoryConfig, pluginOptions) => {
  const result = {};
  const fieldNames = Object.keys(models);
  await Promise.all(fieldNames.map(async (fieldName) => {
    if (fieldName !== "uid") {
      const transformFieldName = repositoryConfig.transformFieldName || defaultTransformFieldName;
      const transformedFieldName = transformFieldName(fieldName);
      result[transformedFieldName] = await normalizeField(models[fieldName], fields[fieldName], [...path, fieldName], sharedSliceModels, repositoryConfig, pluginOptions);
    }
  }));
  return result;
};
const normalizeDocument = async (document, model, sharedSliceModels, repositoryConfig, pluginOptions) => {
  const normalizedDocument = {
    ...document,
    __typename: pascalCase("Prismic", pluginOptions.typePrefix, model.id),
    _previewable: document.id,
    prismicId: document.id,
    id: uuid(),
    url: asLink(document, { linkResolver: repositoryConfig.linkResolver }) ?? null,
    dataRaw: document.data,
    raw: document,
    alternate_languages: document.alternate_languages.map((alternateLanguage) => {
      return withDocumentProxy(alternateLanguage, repositoryConfig);
    })
  };
  if (Object.keys(document.data).length > 0) {
    const fieldModels = Object.assign({}, ...Object.values(model.json));
    normalizedDocument.data = await normalizeFields(document.data, fieldModels, [model.id, "data"], sharedSliceModels, repositoryConfig, pluginOptions);
  }
  return normalizedDocument;
};
export {
  normalizeDocument
};
//# sourceMappingURL=normalizeDocument.js.map
