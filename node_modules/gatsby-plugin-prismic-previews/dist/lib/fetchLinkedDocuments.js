import { CustomTypeModelFieldType, CustomTypeModelSliceType } from "@prismicio/client";
import { usePrismicPreviewStore } from "../usePrismicPreviewStore.js";
import { normalizeDocument } from "./normalizeDocument.js";
const extractLinkedDocumentIDsFromField = async (looseValue, looseModel, sharedSliceModels) => {
  switch (looseModel.type) {
    case CustomTypeModelFieldType.Slices: {
      const value = looseValue;
      return (await Promise.all(value.map(async (slice) => {
        var _a, _b, _c;
        const model = looseModel;
        const sliceModel = (_b = (_a = model.config) == null ? void 0 : _a.choices) == null ? void 0 : _b[slice.slice_type];
        if (sliceModel) {
          if (sliceModel.type === CustomTypeModelSliceType.Slice) {
            return (await Promise.all([
              extractLinkedDocumentIDsFromFields(slice.primary, sliceModel["non-repeat"] || {}, sharedSliceModels),
              ...slice.items.map(async (item) => {
                return extractLinkedDocumentIDsFromFields(item, sliceModel.repeat || {}, sharedSliceModels);
              })
            ])).flat();
          } else if (sliceModel.type === CustomTypeModelSliceType.SharedSlice) {
            const typedSlice = slice;
            const variationModel = (_c = sharedSliceModels.find((m) => m.id === slice.slice_type)) == null ? void 0 : _c.variations.find((m) => m.id === typedSlice.variation);
            if (variationModel) {
              return (await Promise.all([
                extractLinkedDocumentIDsFromFields(slice.primary, variationModel.primary || {}, sharedSliceModels),
                ...slice.items.map(async (item) => {
                  return extractLinkedDocumentIDsFromFields(item, variationModel.items || {}, sharedSliceModels);
                })
              ])).flat();
            } else {
              return [];
            }
          } else {
            return [];
          }
        } else {
          return [];
        }
      }))).flat();
    }
    case CustomTypeModelFieldType.Group: {
      const value = looseValue;
      return (await Promise.all(value.map(async (item) => {
        var _a;
        const model = looseModel;
        return await extractLinkedDocumentIDsFromFields(item, ((_a = model.config) == null ? void 0 : _a.fields) || {}, sharedSliceModels);
      }))).flat();
    }
    case CustomTypeModelFieldType.Link: {
      const value = looseValue;
      if ("id" in value && !value.isBroken) {
        return [value.id];
      }
    }
    default: {
      return [];
    }
  }
};
const extractLinkedDocumentIDsFromFields = async (fields, models, sharedSliceModels) => {
  const fieldNames = Object.keys(models);
  return (await Promise.all(fieldNames.map(async (fieldName) => {
    return extractLinkedDocumentIDsFromField(fields[fieldName], models[fieldName], sharedSliceModels);
  }))).flat();
};
const extractLinkedDocumentIDs = async (document, customTypeModels, sharedSliceModels) => {
  const model = customTypeModels.find((customTypeModel) => customTypeModel.id === document.type);
  if (model) {
    const fieldModels = Object.assign({}, ...Object.values(model.json));
    const linkedIDs = await extractLinkedDocumentIDsFromFields(document.data, fieldModels, sharedSliceModels);
    const alternateLanguageIDs = document.alternate_languages.map((alternateLanguage) => {
      return alternateLanguage.id;
    });
    linkedIDs.push(...alternateLanguageIDs);
    return linkedIDs;
  } else {
    return [];
  }
};
const fetchLinkedDocuments = async (documents, client, pluginOptions, repositoryConfig, customTypeModels, sharedSliceModels, abortController, iterationCount = 0, maximumIterationCount = 3, aggregateAlreadyFetchedIDs = []) => {
  if (iterationCount >= maximumIterationCount) {
    console.warn(`The maximum depth to which gatsby-plugin-prismic-previews will fetch linked documents (${maximumIterationCount} levels deep) was reached. Any Link field's \`document\` property nested below ${maximumIterationCount} levels deep will return undefined.`);
    return;
  }
  const alreadyFetchedIDs = [
    ...aggregateAlreadyFetchedIDs,
    ...documents.map((doc) => doc.id)
  ];
  const ids = (await Promise.all(documents.map(async (doc) => {
    return extractLinkedDocumentIDs(doc, customTypeModels, sharedSliceModels);
  }))).flat();
  const prunedIDs = ids.filter((id) => !alreadyFetchedIDs.includes(id));
  if (prunedIDs.length > 0) {
    const fetchedLinkedDocuments = await client.getAllByIDs([...new Set(prunedIDs)], { signal: abortController.signal });
    await Promise.all([
      Promise.all(fetchedLinkedDocuments.map(async (doc) => {
        const model = customTypeModels.find((customTypeModel) => customTypeModel.id === doc.type);
        if (model) {
          const normalizedDocument = await normalizeDocument(doc, model, sharedSliceModels, pluginOptions, repositoryConfig);
          const state = usePrismicPreviewStore.getState();
          state.addDocument(normalizedDocument);
        }
      })),
      fetchLinkedDocuments(fetchedLinkedDocuments, client, pluginOptions, repositoryConfig, customTypeModels, sharedSliceModels, abortController, iterationCount + 1, maximumIterationCount, [...alreadyFetchedIDs, ...prunedIDs])
    ]);
  }
};
export {
  fetchLinkedDocuments
};
//# sourceMappingURL=fetchLinkedDocuments.js.map
