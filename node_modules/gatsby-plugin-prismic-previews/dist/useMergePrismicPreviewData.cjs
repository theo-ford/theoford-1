"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
const getDocument = require("./lib/getDocument.cjs");
const hasOwnProperty = require("./lib/hasOwnProperty.cjs");
const usePrismicPreviewStore = require("./usePrismicPreviewStore.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
const mergePreviewData = ({ staticDataNode, publishedDocumentIDs }) => {
  const castedData = staticDataNode;
  if (typeof castedData === "object" && castedData !== null && !Array.isArray(castedData)) {
    if (hasOwnProperty.hasOwnProperty(castedData, "_previewable")) {
      const replacement = getDocument.getDocument(castedData._previewable);
      if (replacement) {
        return replacement;
      } else {
        if (publishedDocumentIDs.length > 0 && !publishedDocumentIDs.includes(castedData._previewable)) {
          return null;
        } else {
          return staticDataNode;
        }
      }
    } else {
      const newNode = {};
      for (const key in castedData) {
        newNode[key] = mergePreviewData({
          staticDataNode: castedData[key],
          publishedDocumentIDs
        });
      }
      return newNode;
    }
  } else if (Array.isArray(staticDataNode)) {
    return staticDataNode.map((element) => {
      return mergePreviewData({
        staticDataNode: element,
        publishedDocumentIDs
      });
    });
  } else {
    return staticDataNode;
  }
};
const useMergePrismicPreviewData = (staticData) => {
  const isBootstrapped = usePrismicPreviewStore.usePrismicPreviewStore((state) => state.isBootstrapped);
  const publishedDocumentIDs = usePrismicPreviewStore.usePrismicPreviewStore((state) => state.publishedDocumentIDs);
  const documents = usePrismicPreviewStore.usePrismicPreviewStore((state) => state.documents);
  return React__namespace.useMemo(() => {
    if (staticData) {
      const hasPreviewData = publishedDocumentIDs.length > 0 || Object.keys(documents).length > 0;
      if (isBootstrapped && hasPreviewData) {
        return mergePreviewData({
          staticDataNode: staticData,
          publishedDocumentIDs
        });
      } else {
        return staticData;
      }
    }
  }, [documents, publishedDocumentIDs, isBootstrapped, staticData]);
};
exports.useMergePrismicPreviewData = useMergePrismicPreviewData;
//# sourceMappingURL=useMergePrismicPreviewData.cjs.map
