"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("path");
const mutex = require("gatsby-core-utils/mutex");
const getPublicModelsFileName = require("../lib/getPublicModelsFileName.cjs");
const pascalCase = require("../lib/pascalCase.cjs");
const fs = require("fs/promises");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const isCustomTypeModelIDs = (input) => {
  return Array.isArray(input) && input.every((element) => typeof element === "string");
};
const onPostBootstrap = async (args, options) => {
  const gatsbySourcePrismicCache = args.getCache("gatsby-source-prismic");
  const customTypeModelIDs = await gatsbySourcePrismicCache.get(`${options.repositoryName}:customTypeModelIDs`);
  if (!isCustomTypeModelIDs(customTypeModelIDs)) {
    throw new Error("Did not find Custom Type model IDs from gatsby-source-prismic.");
  }
  const nodes = [];
  for (const customTypeModelID of customTypeModelIDs) {
    const nodesForType = args.getNodesByType(pascalCase.pascalCase("Prismic", options.typePrefix, customTypeModelID));
    nodes.push(...nodesForType);
  }
  const mutex$1 = mutex.createMutex(`gatsby-plugin-prismic-previews:write-nodes:${options.repositoryName}`);
  await mutex$1.acquire();
  {
    const fileName = await getPublicModelsFileName.getPublicModelsFileName(args.cache);
    const filePath = path__namespace.join("public", "static", fileName);
    let contents = {};
    try {
      const rawExistingContents = await fs__namespace.readFile(filePath, "utf8");
      contents = JSON.parse(rawExistingContents);
    } catch {
    }
    const models = await gatsbySourcePrismicCache.get(`${options.repositoryName}:models`);
    contents[options.repositoryName] = models;
    await fs__namespace.writeFile(filePath, JSON.stringify(contents));
  }
  await mutex$1.release();
};
exports.onPostBootstrap = onPostBootstrap;
//# sourceMappingURL=onPostBootstrap.cjs.map
