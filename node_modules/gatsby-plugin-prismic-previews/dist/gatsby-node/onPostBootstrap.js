import * as path from "path";
import { createMutex } from "gatsby-core-utils/mutex";
import { getPublicModelsFileName } from "../lib/getPublicModelsFileName.js";
import { pascalCase } from "../lib/pascalCase.js";
import * as fs from "fs/promises";
const isCustomTypeModelIDs = (input) => {
  return Array.isArray(input) && input.every((element) => typeof element === "string");
};
const onPostBootstrap = async (args, options) => {
  const gatsbySourcePrismicCache = args.getCache("gatsby-source-prismic");
  const customTypeModelIDs = await gatsbySourcePrismicCache.get(`${options.repositoryName}:customTypeModelIDs`);
  if (!isCustomTypeModelIDs(customTypeModelIDs)) {
    throw new Error("Did not find Custom Type model IDs from gatsby-source-prismic.");
  }
  const nodes = [];
  for (const customTypeModelID of customTypeModelIDs) {
    const nodesForType = args.getNodesByType(pascalCase("Prismic", options.typePrefix, customTypeModelID));
    nodes.push(...nodesForType);
  }
  const mutex = createMutex(`gatsby-plugin-prismic-previews:write-nodes:${options.repositoryName}`);
  await mutex.acquire();
  {
    const fileName = await getPublicModelsFileName(args.cache);
    const filePath = path.join("public", "static", fileName);
    let contents = {};
    try {
      const rawExistingContents = await fs.readFile(filePath, "utf8");
      contents = JSON.parse(rawExistingContents);
    } catch {
    }
    const models = await gatsbySourcePrismicCache.get(`${options.repositoryName}:models`);
    contents[options.repositoryName] = models;
    await fs.writeFile(filePath, JSON.stringify(contents));
  }
  await mutex.release();
};
export {
  onPostBootstrap
};
//# sourceMappingURL=onPostBootstrap.js.map
