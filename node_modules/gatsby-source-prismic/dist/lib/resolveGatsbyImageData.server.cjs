"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const buffer = require("buffer");
const gatsbyPluginImage = require("gatsby-plugin-image");
const imgixUrlBuilder = require("imgix-url-builder");
const index = require('./../_node_modules/p-queue/dist/index.cjs');
const path = require("path");
const _package = require("../packages/gatsby-source-prismic/package.json.cjs");
const constants = require("../constants.cjs");
const imgixRequestQueue = new index.default({ concurrency: 5 });
const generateImageSource = (sourceUrl, width, height, format, _fit, options) => {
  const imgixParams = {
    ...constants.DEFAULT_IMGIX_PARAMS,
    ...options == null ? void 0 : options.imgixParams,
    w: width,
    h: height
  };
  if (format && format !== "auto") {
    imgixParams.fm = format;
  }
  return {
    src: imgixUrlBuilder.buildURL(sourceUrl, imgixParams),
    width,
    height,
    format
  };
};
const fetchBase64Image = async (config) => {
  const cacheKey = `base64___${config.url}`;
  const cacheValue = await config.cache.get(cacheKey);
  if (cacheValue) {
    return cacheValue;
  } else {
    const fetch = (await import("node-fetch")).default;
    const res = await imgixRequestQueue.add(async () => {
      return await fetch(config.url);
    });
    if (res) {
      const arrayBuffer = await res.arrayBuffer();
      const buffer$1 = buffer.Buffer.from(new Uint8Array(arrayBuffer));
      const contentType = res.headers.get("content-type");
      const base64 = `data:${contentType};base64,${buffer$1.toString("base64")}`;
      config.cache.set(cacheKey, base64);
      return base64;
    }
  }
};
const resolveGatsbyImageData = async (image, options = {}, config) => {
  var _a, _b, _c, _d;
  const imageDataArgs = {
    pluginName: config.pluginName || _package.name,
    sourceMetadata: {
      width: image.width,
      height: image.height,
      format: "auto"
    },
    filename: image.url,
    generateImageSource,
    options,
    layout: options.layout,
    width: options.width,
    height: options.height,
    aspectRatio: options.aspectRatio,
    backgroundColor: options.backgroundColor,
    breakpoints: options.breakpoints,
    formats: options.formats,
    sizes: options.sizes
  };
  const resolvedBuildURL = config.buildURL || imgixUrlBuilder.buildURL;
  const placeholderURL = resolvedBuildURL(imageDataArgs.filename, {
    ...constants.DEFAULT_IMGIX_PARAMS,
    ...options.imgixParams,
    ...options.placeholderImgixParams
  });
  if (options.placeholder === constants.GatsbyImageDataPlaceholderKind.Blurred) {
    imageDataArgs.placeholderURL = await fetchBase64Image({
      url: gatsbyPluginImage.getLowResolutionImageURL({
        ...imageDataArgs,
        filename: placeholderURL
      }),
      cache: config.cache
    });
  }
  if (options.placeholder === constants.GatsbyImageDataPlaceholderKind.DominantColor) {
    const cacheKey = `${constants.GatsbyImageDataPlaceholderKind.DominantColor}___${placeholderURL}`;
    const cacheValue = await config.cache.get(cacheKey);
    if (cacheValue) {
      imageDataArgs.backgroundColor = cacheValue;
    } else {
      const fileExtension = path.extname(new URL(placeholderURL).pathname);
      if (fileExtension !== ".svg") {
        const palleteUrl = resolvedBuildURL(placeholderURL, {
          palette: "json",
          colors: 1
        });
        const fetch = (await import("node-fetch")).default;
        const res = await imgixRequestQueue.add(async () => {
          return await fetch(palleteUrl);
        });
        if (res) {
          const json = await res.json();
          const dominantColor = ((_b = (_a = json.dominant_colors) == null ? void 0 : _a.muted) == null ? void 0 : _b.hex) || ((_d = (_c = json.dominant_colors) == null ? void 0 : _c.vibrant) == null ? void 0 : _d.hex) || json.colors[0].hex;
          config.cache.set(cacheKey, dominantColor);
          imageDataArgs.backgroundColor = dominantColor;
        }
      }
    }
  }
  return gatsbyPluginImage.generateImageData(imageDataArgs);
};
exports.generateImageSource = generateImageSource;
exports.resolveGatsbyImageData = resolveGatsbyImageData;
//# sourceMappingURL=resolveGatsbyImageData.server.cjs.map
