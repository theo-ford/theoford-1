import * as prismic from "@prismicio/client";
import { createCachedRemoteFileNode } from "./createCachedRemoteFileNode.js";
import { defaultTransformFieldName } from "./defaultTransformFieldName.js";
import { fmtLog } from "./fmtLog.js";
import { pascalCase } from "./pascalCase.js";
import { shouldDownloadFile } from "./shouldDownloadFile.js";
import { withoutURLParameter } from "./withoutURLParameter.js";
const normalizeDocumentField = async (args) => {
  var _a, _b;
  const model = args.model;
  switch (model.type) {
    case prismic.CustomTypeModelFieldType.Slices: {
      const value = args.value;
      if (prismic.isFilled.sliceZone(value)) {
        return await Promise.all(value.map(async (slice) => {
          var _a2, _b2;
          const sliceModel = (_b2 = (_a2 = model.config) == null ? void 0 : _a2.choices) == null ? void 0 : _b2[slice.slice_type];
          if (!sliceModel) {
            return slice;
          }
          switch (sliceModel.type) {
            case prismic.CustomTypeModelSliceType.SharedSlice: {
              const sharedSlice = slice;
              const sharedSliceModel = args.sharedSliceModels.find((model2) => {
                return model2.id === sharedSlice.slice_type;
              });
              const sharedSliceVariationModel = sharedSliceModel == null ? void 0 : sharedSliceModel.variations.find((variationModel) => {
                return variationModel.id === sharedSlice.variation;
              });
              if (sharedSliceModel && sharedSliceVariationModel) {
                const [primary, items] = await Promise.all([
                  normalizeDocumentFieldRecord({
                    ...args,
                    models: sharedSliceVariationModel.primary || {},
                    record: sharedSlice.primary,
                    path: [
                      sharedSliceModel.id,
                      sharedSliceVariationModel.id,
                      "primary"
                    ]
                  }),
                  ...sharedSlice.items.map(async (item) => {
                    return await normalizeDocumentFieldRecord({
                      ...args,
                      models: sharedSliceVariationModel.items || {},
                      record: item,
                      path: [
                        sharedSliceModel.id,
                        sharedSliceVariationModel.id,
                        "items"
                      ]
                    });
                  })
                ]);
                return {
                  ...sharedSlice,
                  primary,
                  items
                };
              } else {
                throw new Error(`A Shared Slice model with ID "${slice.slice_type}" was not found.`);
              }
            }
            case prismic.CustomTypeModelSliceType.Slice: {
              const [primary, ...items] = await Promise.all([
                normalizeDocumentFieldRecord({
                  ...args,
                  models: sliceModel["non-repeat"] || {},
                  record: slice.primary,
                  path: [...args.path, slice.slice_type, "primary"]
                }),
                ...slice.items.map(async (item) => {
                  return await normalizeDocumentFieldRecord({
                    ...args,
                    models: sliceModel.repeat || {},
                    record: item,
                    path: [...args.path, slice.slice_type, "items"]
                  });
                })
              ]);
              return {
                ...slice,
                primary,
                items
              };
            }
            default: {
              return slice;
            }
          }
        }));
      } else {
        return [];
      }
    }
    case prismic.CustomTypeModelFieldType.Group: {
      const value = args.value;
      if (prismic.isFilled.group(value)) {
        return await Promise.all(value.map(async (item) => {
          var _a2;
          return normalizeDocumentFieldRecord({
            ...args,
            models: ((_a2 = model.config) == null ? void 0 : _a2.fields) || {},
            record: item
          });
        }));
      } else {
        return [];
      }
    }
    case prismic.CustomTypeModelFieldType.Link: {
      const value = args.value;
      if (prismic.isFilled.link(value) && value.link_type === prismic.LinkType.Media && await shouldDownloadFile({
        field: value,
        path: args.path,
        pluginOptions: args.pluginOptions
      })) {
        const fileNode = await createCachedRemoteFileNode({
          url: value.url,
          gatsbyNodeArgs: args.gatsbyNodeArgs
        });
        return {
          ...value,
          localFile: fileNode.id
        };
      } else {
        return {
          ...value,
          localFile: null
        };
      }
    }
    case prismic.CustomTypeModelFieldType.Image: {
      const value = args.value;
      const thumbnails = {};
      if ((_a = model.config) == null ? void 0 : _a.thumbnails) {
        for (const thumbnailModel of model.config.thumbnails) {
          const thumbnailValue = value[thumbnailModel.name];
          const transformedThumbnailName = args.pluginOptions.transformFieldName ? args.pluginOptions.transformFieldName(thumbnailModel.name) : defaultTransformFieldName(thumbnailModel.name);
          if (prismic.isFilled.imageThumbnail(thumbnailValue) && await shouldDownloadFile({
            field: thumbnailValue,
            path: args.path,
            pluginOptions: args.pluginOptions
          })) {
            const fileNode = await createCachedRemoteFileNode({
              url: withoutURLParameter(thumbnailValue.url, "auto"),
              gatsbyNodeArgs: args.gatsbyNodeArgs
            });
            thumbnails[transformedThumbnailName] = {
              ...thumbnailValue,
              localFile: fileNode.id
            };
          } else {
            thumbnails[transformedThumbnailName] = {
              ...thumbnailValue,
              localFile: null
            };
          }
        }
      }
      if (prismic.isFilled.image(value) && await shouldDownloadFile({
        field: value,
        path: args.path,
        pluginOptions: args.pluginOptions
      })) {
        const fileNode = await createCachedRemoteFileNode({
          url: withoutURLParameter(value.url, "auto"),
          gatsbyNodeArgs: args.gatsbyNodeArgs
        });
        return {
          ...value,
          ...thumbnails,
          localFile: fileNode.id
        };
      } else {
        return {
          ...value,
          ...thumbnails,
          localFile: null
        };
      }
    }
    case prismic.CustomTypeModelFieldType.Embed: {
      const value = args.value;
      if (prismic.isFilled.embed(value)) {
        const node = {
          ...value,
          id: args.gatsbyNodeArgs.createNodeId(value.embed_url),
          internal: {
            type: pascalCase("Prismic", args.pluginOptions.typePrefix, "EmbedField"),
            contentDigest: args.gatsbyNodeArgs.createContentDigest(value)
          }
        };
        args.gatsbyNodeArgs.actions.createNode(node);
        return node.id;
      } else {
        return null;
      }
    }
    case prismic.CustomTypeModelFieldType.Integration: {
      const value = args.value;
      if (!((_b = model.config) == null ? void 0 : _b.catalog)) {
        throw new Error(fmtLog(args.pluginOptions.repositoryName, `Integration fields must have a catalog configured, but none was found for this field: ${args.path.join(".")}`));
      }
      if (prismic.isFilled.integrationField(value)) {
        const contentDigest = args.gatsbyNodeArgs.createContentDigest(value);
        const node = {
          ...value,
          id: contentDigest,
          internal: {
            type: pascalCase("Prismic", args.pluginOptions.typePrefix, model.config.catalog, "IntegrationItem"),
            contentDigest
          }
        };
        if (value.id) {
          node.prismicId = value.id;
        }
        if (value.internal) {
          node.prismicInternal = value.internal;
        }
        args.gatsbyNodeArgs.actions.createNode(node);
        return node.id;
      } else {
        return null;
      }
    }
    default: {
      return args.value;
    }
  }
};
const normalizeDocumentFieldRecord = async (args) => {
  const result = {};
  const fieldNames = Object.keys(args.models);
  await Promise.all(fieldNames.map(async (fieldName) => {
    if (fieldName !== "uid") {
      const transformedFieldName = args.pluginOptions.transformFieldName ? args.pluginOptions.transformFieldName(fieldName) : defaultTransformFieldName(fieldName);
      result[transformedFieldName] = await normalizeDocumentField({
        ...args,
        model: args.models[fieldName],
        value: args.record[fieldName],
        path: [...args.path, transformedFieldName]
      });
    }
  }));
  return result;
};
const normalizeDocument = async (args) => {
  const models = Object.assign({}, ...Object.values(args.model.json));
  const normalizedData = await normalizeDocumentFieldRecord({
    ...args,
    models,
    path: [args.model.id],
    record: args.document.data
  });
  return {
    ...args.document,
    data: normalizedData
  };
};
export {
  normalizeDocument
};
//# sourceMappingURL=normalizeDocument.js.map
