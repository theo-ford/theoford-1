import { Buffer } from "buffer";
import { getLowResolutionImageURL, generateImageData } from "gatsby-plugin-image";
import { buildURL } from "imgix-url-builder";
import PQueue from './../_node_modules/p-queue/dist/index.js';
import { extname } from "path";
import { name } from "../packages/gatsby-source-prismic/package.json.js";
import { DEFAULT_IMGIX_PARAMS, GatsbyImageDataPlaceholderKind } from "../constants.js";
const imgixRequestQueue = new PQueue({ concurrency: 5 });
const generateImageSource = (sourceUrl, width, height, format, _fit, options) => {
  const imgixParams = {
    ...DEFAULT_IMGIX_PARAMS,
    ...options == null ? void 0 : options.imgixParams,
    w: width,
    h: height
  };
  if (format && format !== "auto") {
    imgixParams.fm = format;
  }
  return {
    src: buildURL(sourceUrl, imgixParams),
    width,
    height,
    format
  };
};
const fetchBase64Image = async (config) => {
  const cacheKey = `base64___${config.url}`;
  const cacheValue = await config.cache.get(cacheKey);
  if (cacheValue) {
    return cacheValue;
  } else {
    const fetch = (await import("node-fetch")).default;
    const res = await imgixRequestQueue.add(async () => {
      return await fetch(config.url);
    });
    if (res) {
      const arrayBuffer = await res.arrayBuffer();
      const buffer = Buffer.from(new Uint8Array(arrayBuffer));
      const contentType = res.headers.get("content-type");
      const base64 = `data:${contentType};base64,${buffer.toString("base64")}`;
      config.cache.set(cacheKey, base64);
      return base64;
    }
  }
};
const resolveGatsbyImageData = async (image, options = {}, config) => {
  var _a, _b, _c, _d;
  const imageDataArgs = {
    pluginName: config.pluginName || name,
    sourceMetadata: {
      width: image.width,
      height: image.height,
      format: "auto"
    },
    filename: image.url,
    generateImageSource,
    options,
    layout: options.layout,
    width: options.width,
    height: options.height,
    aspectRatio: options.aspectRatio,
    backgroundColor: options.backgroundColor,
    breakpoints: options.breakpoints,
    formats: options.formats,
    sizes: options.sizes
  };
  const resolvedBuildURL = config.buildURL || buildURL;
  const placeholderURL = resolvedBuildURL(imageDataArgs.filename, {
    ...DEFAULT_IMGIX_PARAMS,
    ...options.imgixParams,
    ...options.placeholderImgixParams
  });
  if (options.placeholder === GatsbyImageDataPlaceholderKind.Blurred) {
    imageDataArgs.placeholderURL = await fetchBase64Image({
      url: getLowResolutionImageURL({
        ...imageDataArgs,
        filename: placeholderURL
      }),
      cache: config.cache
    });
  }
  if (options.placeholder === GatsbyImageDataPlaceholderKind.DominantColor) {
    const cacheKey = `${GatsbyImageDataPlaceholderKind.DominantColor}___${placeholderURL}`;
    const cacheValue = await config.cache.get(cacheKey);
    if (cacheValue) {
      imageDataArgs.backgroundColor = cacheValue;
    } else {
      const fileExtension = extname(new URL(placeholderURL).pathname);
      if (fileExtension !== ".svg") {
        const palleteUrl = resolvedBuildURL(placeholderURL, {
          palette: "json",
          colors: 1
        });
        const fetch = (await import("node-fetch")).default;
        const res = await imgixRequestQueue.add(async () => {
          return await fetch(palleteUrl);
        });
        if (res) {
          const json = await res.json();
          const dominantColor = ((_b = (_a = json.dominant_colors) == null ? void 0 : _a.muted) == null ? void 0 : _b.hex) || ((_d = (_c = json.dominant_colors) == null ? void 0 : _c.vibrant) == null ? void 0 : _d.hex) || json.colors[0].hex;
          config.cache.set(cacheKey, dominantColor);
          imageDataArgs.backgroundColor = dominantColor;
        }
      }
    }
  }
  return generateImageData(imageDataArgs);
};
export {
  generateImageSource,
  resolveGatsbyImageData
};
//# sourceMappingURL=resolveGatsbyImageData.server.js.map
