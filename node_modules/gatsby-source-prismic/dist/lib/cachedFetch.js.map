{"version":3,"file":"cachedFetch.js","sources":["../../../src/lib/cachedFetch.ts"],"sourcesContent":["import type { FetchLike } from \"@prismicio/custom-types-client\";\nimport type { GatsbyCache } from \"gatsby\";\nimport type { Response } from \"node-fetch\";\n\ntype CachedFetchArgs = {\n\tfetch: FetchLike;\n\tcache: GatsbyCache;\n\tname: string;\n};\n\nexport const cachedFetch = async (\n\tinput: Parameters<FetchLike>[0],\n\tinit: Parameters<FetchLike>[1],\n\targs: CachedFetchArgs,\n): Promise<Response> => {\n\tconst cacheKey = `fetchLike(${args.name})___${JSON.stringify({\n\t\tinput,\n\t\tinit,\n\t})}`;\n\n\tconst cachedValue: string | undefined = await args.cache.get(cacheKey);\n\n\tconst { Response } = await import(\"node-fetch\");\n\n\t// Gatsby's cache does not have a `has` method. Because we are\n\t// saving strings to the cache, this check should be sufficient\n\t// to detect cache values.\n\tif (cachedValue !== undefined) {\n\t\treturn new Response(cachedValue);\n\t} else {\n\t\tconst result = await args.fetch(input, init);\n\n\t\t// Using `.text()` allows the consumer to re-parse as\n\t\t// JSON while being able to save to the cache reliably.\n\t\tconst text = await result.text();\n\n\t\t// This call is purposely not awaited. We can let it\n\t\t// resolve in the background.\n\t\targs.cache.set(cacheKey, text);\n\n\t\treturn new Response(text);\n\t}\n};\n"],"names":[],"mappings":"AAUO,MAAM,cAAc,OAC1B,OACA,MACA,SACsB;AACtB,QAAM,WAAW,aAAa,KAAK,WAAW,KAAK,UAAU;AAAA,IAC5D;AAAA,IACA;AAAA,EACA,CAAA;AAED,QAAM,cAAkC,MAAM,KAAK,MAAM,IAAI,QAAQ;AAErE,QAAM,EAAE,SAAA,IAAa,MAAM,OAAO,YAAY;AAK9C,MAAI,gBAAgB,QAAW;AACvB,WAAA,IAAI,SAAS,WAAW;AAAA,EAAA,OACzB;AACN,UAAM,SAAS,MAAM,KAAK,MAAM,OAAO,IAAI;AAIrC,UAAA,OAAO,MAAM,OAAO;AAIrB,SAAA,MAAM,IAAI,UAAU,IAAI;AAEtB,WAAA,IAAI,SAAS,IAAI;AAAA,EACxB;AACF;"}