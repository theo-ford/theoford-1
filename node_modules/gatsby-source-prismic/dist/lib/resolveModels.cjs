"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const prismicCustomTypesClient = require("@prismicio/custom-types-client");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const prismicCustomTypesClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(prismicCustomTypesClient);
const resolveModels = async (args) => {
  const keyedCustomTypeModels = {};
  const keyedSharedSliceModels = {};
  if (args.pluginOptions.customTypesApiToken) {
    const client = prismicCustomTypesClient__namespace.createClient({
      repositoryName: args.pluginOptions.repositoryName,
      token: args.pluginOptions.customTypesApiToken,
      fetch: args.pluginOptions.fetch || (await import("node-fetch")).default,
      endpoint: args.pluginOptions.customTypesApiEndpoint
    });
    const [customTypeModels, sharedSliceModels] = await Promise.all([
      client.getAllCustomTypes(),
      client.getAllSharedSlices()
    ]);
    for (const customTypeModel of customTypeModels) {
      keyedCustomTypeModels[customTypeModel.id] = customTypeModel;
    }
    for (const sharedSliceModel of sharedSliceModels) {
      keyedSharedSliceModels[sharedSliceModel.id] = sharedSliceModel;
    }
  }
  if (args.pluginOptions.schemas) {
    for (const id in args.pluginOptions.schemas) {
      const customTypeModel = {
        id,
        json: args.pluginOptions.schemas[id],
        // The following values are "fake". They are
        // not part of the given definition so we must
        // fill them in to promote the type to a Custom
        // Type model.
        label: "label",
        status: true,
        repeatable: true
      };
      keyedCustomTypeModels[customTypeModel.id] = customTypeModel;
    }
  }
  if (args.pluginOptions.customTypeModels) {
    for (const customTypeModel of args.pluginOptions.customTypeModels) {
      keyedCustomTypeModels[customTypeModel.id] = customTypeModel;
    }
  }
  if (args.pluginOptions.sharedSliceModels) {
    for (const sharedSliceModel of args.pluginOptions.sharedSliceModels) {
      keyedSharedSliceModels[sharedSliceModel.id] = sharedSliceModel;
    }
  }
  return {
    customTypeModels: Object.values(keyedCustomTypeModels),
    sharedSliceModels: Object.values(keyedSharedSliceModels)
  };
};
exports.resolveModels = resolveModels;
//# sourceMappingURL=resolveModels.cjs.map
