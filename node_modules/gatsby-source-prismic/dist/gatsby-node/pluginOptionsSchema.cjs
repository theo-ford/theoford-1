"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const prismic = require("@prismicio/client");
const prismicCustomTypesClient = require("@prismicio/custom-types-client");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const prismic__namespace = /* @__PURE__ */ _interopNamespaceDefault(prismic);
const prismicCustomTypesClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(prismicCustomTypesClient);
const pluginOptionsSchema = ({ Joi }) => {
  return Joi.object({
    repositoryName: Joi.string().required(),
    accessToken: Joi.string().allow(""),
    apiEndpoint: Joi.string(),
    routes: Joi.array().items(Joi.object({
      type: Joi.string().required(),
      uid: Joi.string(),
      lang: Joi.string(),
      path: Joi.string().required(),
      resolvers: Joi.object().pattern(Joi.string(), Joi.string().required())
    }).required()),
    linkResolver: Joi.function().arity(1),
    htmlSerializer: Joi.alternatives(Joi.object().pattern(Joi.allow(...Object.keys(prismic__namespace.Element)), Joi.function()), Joi.function()),
    lang: Joi.string(),
    fetchLinks: Joi.array().items(Joi.string()),
    graphQuery: Joi.string(),
    predicates: Joi.alternatives(Joi.string(), Joi.array().items(Joi.string())),
    releaseID: Joi.string(),
    releaseLabel: Joi.string(),
    typePrefix: Joi.string(),
    customTypesApiToken: Joi.string(),
    customTypesApiEndpoint: Joi.string(),
    schemas: Joi.object().pattern(Joi.string(), Joi.object().required()),
    customTypeModels: Joi.array().items(Joi.object({
      id: Joi.string().required(),
      json: Joi.object().required()
    }).unknown()),
    sharedSliceModels: Joi.array().items(Joi.object({
      id: Joi.string().required(),
      variations: Joi.array().items(Joi.object({
        id: Joi.string().required(),
        primary: Joi.object(),
        items: Joi.object()
      }).unknown()).required()
    }).unknown()),
    imageImgixParams: Joi.object().pattern(Joi.string(), Joi.any()),
    imagePlaceholderImgixParams: Joi.object().pattern(Joi.string(), Joi.any()),
    transformFieldName: Joi.function().arity(1),
    shouldDownloadFiles: Joi.alternatives(Joi.boolean(), Joi.function().arity(1), Joi.object().pattern(Joi.string(), Joi.alternatives(Joi.boolean(), Joi.function().arity(1)))),
    webhookSecret: Joi.string(),
    fetch: Joi.function()
  }).or("customTypesApiToken", "customTypeModels", "schemas").oxor("fetchLinks", "graphQuery").oxor("releaseID", "releaseLabel").external(async (options) => {
    const client = prismic__namespace.createClient(options.apiEndpoint || options.repositoryName, {
      accessToken: options.accessToken,
      fetch: options.fetch || (await import("node-fetch")).default
    });
    let repository;
    try {
      repository = await client.getRepository();
    } catch (error) {
      if (error instanceof prismic__namespace.NotFoundError) {
        throw new Joi.ValidationError("repositoryName", [
          {
            message: `Could not access the "${options.repositoryName}" Prismic repository. Check that the \`repositoryName\` option is correct and try again.`
          }
        ], options);
      }
      if (error instanceof prismic__namespace.ForbiddenError) {
        if (options.accessToken) {
          throw new Joi.ValidationError("accessToken", [
            {
              message: `The provided accessToken for the "${options.repositoryName}" repository is incorrect. Check that the \`accessToken\` option is correct and try again.`
            }
          ], options);
        } else {
          throw new Joi.ValidationError("accessToken", [
            {
              message: `An access token is required for the "${options.repositoryName}" Prismic repository, but one was not given. Check that the \`accessToken\` option is correct and try again.`
            }
          ], options);
        }
      }
      throw error;
    }
    if (options.releaseID || options.releaseLabel) {
      if (options.releaseID) {
        const ref = repository.refs.find((ref2) => ref2.id === options.releaseID);
        if (!ref) {
          if (options.accessToken) {
            throw new Joi.ValidationError("releaseID", [
              {
                message: `A Release with the ID "${options.releaseID}" could not be found. Check that the \`releaseID\` option is correct and try again. Also check that the access token has access to Releases.`
              }
            ], options);
          } else {
            throw new Joi.ValidationError("releaseID", [
              {
                message: `A Release with the ID "${options.releaseID}" could not be found. Check that the \`releaseID\` option is correct and try again. You may also need to provide an access token to query Releases.`
              }
            ], options);
          }
        }
      } else if (options.releaseLabel) {
        const ref = repository.refs.find((ref2) => ref2.label === options.releaseLabel);
        if (!ref) {
          if (options.accessToken) {
            throw new Joi.ValidationError("releaseLabel", [
              {
                message: `A Release with the label "${options.releaseLabel}" could not be found. Check that the \`releaseLabel\` option is correct and try again. Also check that the access token has access to Releases.`
              }
            ], options);
          } else {
            throw new Joi.ValidationError("releaseLabel", [
              {
                message: `A Release with the label "${options.releaseLabel}" could not be found. Check that the \`releaseLabel\` option is correct and try again. You may also need to provide an access token to query Releases.`
              }
            ], options);
          }
        }
      }
    }
    if (options.customTypesApiToken) {
      const client2 = prismicCustomTypesClient__namespace.createClient({
        repositoryName: options.repositoryName,
        endpoint: options.customTypesApiEndpoint,
        token: options.customTypesApiToken,
        fetch: options.fetch || (await import("node-fetch")).default
      });
      try {
        await client2.getAllCustomTypes();
      } catch (error) {
        if (error instanceof prismicCustomTypesClient__namespace.ForbiddenError) {
          throw new Joi.ValidationError("customTypesApiToken", [
            {
              message: `The provided Custom Types API token is incorrect. Check that the \`customTypesApiToken\` option is correct and try again.`
            }
          ], options);
        }
        throw error;
      }
    }
  });
};
exports.pluginOptionsSchema = pluginOptionsSchema;
//# sourceMappingURL=pluginOptionsSchema.cjs.map
