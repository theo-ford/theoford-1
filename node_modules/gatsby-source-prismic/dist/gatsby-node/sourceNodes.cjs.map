{"version":3,"file":"sourceNodes.cjs","sources":["../../../src/gatsby-node/sourceNodes.ts"],"sourcesContent":["import {\n\tCustomTypeModel,\n\tLinkResolverFunction,\n\tPrismicDocument,\n\tRelease,\n\tSharedSliceModel,\n\tWebhookBody,\n\tWebhookType,\n\tcreateClient,\n} from \"@prismicio/client\";\nimport type { Node, SourceNodesArgs } from \"gatsby\";\n\nimport { cachedFetch } from \"../lib/cachedFetch\";\nimport { createDocumentNodes } from \"../lib/createDocumentNodes\";\nimport { fmtLog } from \"../lib/fmtLog\";\nimport { getModelsCacheKey } from \"../lib/getModelsCacheKey\";\nimport { hasOwnProperty } from \"../lib/hasOwnProperty\";\n\nimport type { PluginOptions } from \"../types\";\n\nconst isPrismicWebhookBody = (\n\twebhookBody: unknown,\n): webhookBody is WebhookBody => {\n\treturn (\n\t\ttypeof webhookBody === \"object\" &&\n\t\twebhookBody !== null &&\n\t\thasOwnProperty(webhookBody, \"apiUrl\") &&\n\t\ttypeof webhookBody.apiUrl === \"string\" &&\n\t\t/^https?:\\/\\/([^.]+)\\.(wroom\\.(?:test|io)|prismic\\.io)\\/api\\/?/.test(\n\t\t\twebhookBody.apiUrl,\n\t\t)\n\t);\n};\n\nexport const sourceNodes = async <\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTLinkResolverFunction extends LinkResolverFunction<any> = LinkResolverFunction,\n>(\n\targs: SourceNodesArgs,\n\toptions: PluginOptions<TLinkResolverFunction>,\n): Promise<void> => {\n\tconst client = createClient(options.apiEndpoint || options.repositoryName, {\n\t\taccessToken: options.accessToken,\n\t\troutes: options.routes,\n\t\tfetch: async (input, init) => {\n\t\t\tconst resolvedFetch =\n\t\t\t\toptions.fetch || (await import(\"node-fetch\")).default;\n\t\t\tconst url = new URL(input);\n\n\t\t\tif (/\\/documents\\/search\\/?/.test(url.pathname)) {\n\t\t\t\treturn await cachedFetch(input, init, {\n\t\t\t\t\tfetch: resolvedFetch,\n\t\t\t\t\tcache: args.cache,\n\t\t\t\t\tname: \"sourceNodes\",\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn await resolvedFetch(input, init);\n\t\t\t}\n\t\t},\n\t\tdefaultParams: {\n\t\t\tlang: options.lang || \"*\",\n\t\t\tfetchLinks: options.fetchLinks,\n\t\t\tgraphQuery: options.graphQuery,\n\t\t\tpredicates: options.predicates,\n\t\t},\n\t});\n\n\tlet release: Release | undefined;\n\tif (options.releaseID) {\n\t\tclient.queryContentFromReleaseByID(options.releaseID);\n\t\trelease = await client.getReleaseByID(options.releaseID);\n\t} else if (options.releaseLabel) {\n\t\tclient.queryContentFromReleaseByLabel(options.releaseLabel);\n\t\trelease = await client.getReleaseByLabel(options.releaseLabel);\n\t}\n\n\t// Only log Release information at startup.\n\tif (release && !args.webhookBody) {\n\t\targs.reporter.info(\n\t\t\tfmtLog(\n\t\t\t\toptions.repositoryName,\n\t\t\t\t`Querying documents from the \"${release.label}\" Release (ID: \"${release.id}\")`,\n\t\t\t),\n\t\t);\n\t}\n\n\tconst {\n\t\tcustomTypeModels,\n\t\tsharedSliceModels,\n\t}: {\n\t\tcustomTypeModels: CustomTypeModel[];\n\t\tsharedSliceModels: SharedSliceModel[];\n\t} = await args.cache.get(\n\t\tgetModelsCacheKey({ repositoryName: options.repositoryName }),\n\t);\n\n\tlet documentsToCreate: PrismicDocument[] = [];\n\tconst documentIDsToDelete: string[] = [];\n\n\tconst hasWebhookBody =\n\t\targs.webhookBody && JSON.stringify(args.webhookBody) !== \"{}\";\n\n\tif (!hasWebhookBody) {\n\t\tdocumentsToCreate = await client.dangerouslyGetAll();\n\t} else {\n\t\tif (\n\t\t\tisPrismicWebhookBody(args.webhookBody) &&\n\t\t\targs.webhookBody.domain === options.repositoryName\n\t\t) {\n\t\t\tif (\n\t\t\t\t!args.webhookBody.secret ||\n\t\t\t\targs.webhookBody.secret === options.webhookSecret\n\t\t\t) {\n\t\t\t\tswitch (args.webhookBody.type) {\n\t\t\t\t\tcase WebhookType.TestTrigger: {\n\t\t\t\t\t\targs.reporter.info(\n\t\t\t\t\t\t\tfmtLog(\n\t\t\t\t\t\t\t\toptions.repositoryName,\n\t\t\t\t\t\t\t\t\"Success! Received a test trigger webhook. When changes to your content are saved, Gatsby will automatically fetch the changes.\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WebhookType.APIUpdate: {\n\t\t\t\t\t\targs.reporter.info(\n\t\t\t\t\t\t\tfmtLog(\n\t\t\t\t\t\t\t\toptions.repositoryName,\n\t\t\t\t\t\t\t\t\"Received an API update webhook. Documents will be added, updated, or deleted accordingly.\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst webhookDocumentIDs = args.webhookBody.documents;\n\n\t\t\t\t\t\tif (release) {\n\t\t\t\t\t\t\tconst webhookReleaseDocumentIDs: string[] = [];\n\t\t\t\t\t\t\tfor (const releaseUpdate of [\n\t\t\t\t\t\t\t\t...(args.webhookBody.releases.update || []),\n\t\t\t\t\t\t\t\t...(args.webhookBody.releases.addition || []),\n\t\t\t\t\t\t\t\t...(args.webhookBody.releases.deletion || []),\n\t\t\t\t\t\t\t]) {\n\t\t\t\t\t\t\t\tif (releaseUpdate.id === release.id) {\n\t\t\t\t\t\t\t\t\twebhookReleaseDocumentIDs.push(...releaseUpdate.documents);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twebhookDocumentIDs.push(...webhookReleaseDocumentIDs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdocumentsToCreate = await client.getAllByIDs([\n\t\t\t\t\t\t\t...new Set(webhookDocumentIDs),\n\t\t\t\t\t\t]);\n\n\t\t\t\t\t\tfor (const webhookDocumentID of webhookDocumentIDs) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!documentsToCreate.some((doc) => doc.id === webhookDocumentID)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tdocumentIDsToDelete.push(webhookDocumentID);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (documentsToCreate.length > 0) {\n\t\tif (hasWebhookBody) {\n\t\t\targs.reporter.info(\n\t\t\t\tfmtLog(\n\t\t\t\t\toptions.repositoryName,\n\t\t\t\t\t`Adding or updating the following Prismic documents: [${documentsToCreate\n\t\t\t\t\t\t.map((doc) => `\"${doc.id}\"`)\n\t\t\t\t\t\t.join(\", \")}]`,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tawait createDocumentNodes({\n\t\t\tdocuments: documentsToCreate,\n\t\t\tcustomTypeModels,\n\t\t\tsharedSliceModels,\n\t\t\tgatsbyNodeArgs: args,\n\t\t\tpluginOptions: options,\n\t\t});\n\t}\n\n\tif (documentIDsToDelete.length > 0) {\n\t\targs.reporter.info(\n\t\t\tfmtLog(\n\t\t\t\toptions.repositoryName,\n\t\t\t\t`Deleting the following Prismic documents: [${documentIDsToDelete\n\t\t\t\t\t.map((id) => `\"${id}\"`)\n\t\t\t\t\t.join(\", \")}]`,\n\t\t\t),\n\t\t);\n\n\t\tfor (const documentIDToDelete of documentIDsToDelete) {\n\t\t\tconst node = args.getNode(args.createNodeId(documentIDToDelete));\n\n\t\t\tif (node) {\n\t\t\t\targs.actions.deleteNode(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t// All nodes must be touched to prevent them from being garbage collected.\n\tconst nodesToTouch: Node[] = args.getNodes().filter((node) => {\n\t\treturn (\n\t\t\tnode.internal.owner === \"gatsby-source-prismic\" &&\n\t\t\thasOwnProperty(node, \"prismicId\") &&\n\t\t\ttypeof node.prismicId === \"string\" &&\n\t\t\t!documentIDsToDelete.includes(node.prismicId)\n\t\t);\n\t});\n\n\tfor (const nodeToTouch of nodesToTouch) {\n\t\targs.actions.touchNode(nodeToTouch);\n\t}\n};\n"],"names":["hasOwnProperty","createClient","cachedFetch","fmtLog","getModelsCacheKey","WebhookType","createDocumentNodes"],"mappings":"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"}