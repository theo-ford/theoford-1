"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const prismic = require("@prismicio/client");
const cachedFetch = require("../lib/cachedFetch.cjs");
const createDocumentNodes = require("../lib/createDocumentNodes.cjs");
const fmtLog = require("../lib/fmtLog.cjs");
const getModelsCacheKey = require("../lib/getModelsCacheKey.cjs");
const hasOwnProperty = require("../lib/hasOwnProperty.cjs");
const isPrismicWebhookBody = (webhookBody) => {
  return typeof webhookBody === "object" && webhookBody !== null && hasOwnProperty.hasOwnProperty(webhookBody, "apiUrl") && typeof webhookBody.apiUrl === "string" && /^https?:\/\/([^.]+)\.(wroom\.(?:test|io)|prismic\.io)\/api\/?/.test(webhookBody.apiUrl);
};
const sourceNodes = async (args, options) => {
  const client = prismic.createClient(options.apiEndpoint || options.repositoryName, {
    accessToken: options.accessToken,
    routes: options.routes,
    fetch: async (input, init) => {
      const resolvedFetch = options.fetch || (await import("node-fetch")).default;
      const url = new URL(input);
      if (/\/documents\/search\/?/.test(url.pathname)) {
        return await cachedFetch.cachedFetch(input, init, {
          fetch: resolvedFetch,
          cache: args.cache,
          name: "sourceNodes"
        });
      } else {
        return await resolvedFetch(input, init);
      }
    },
    defaultParams: {
      lang: options.lang || "*",
      fetchLinks: options.fetchLinks,
      graphQuery: options.graphQuery,
      predicates: options.predicates
    }
  });
  let release;
  if (options.releaseID) {
    client.queryContentFromReleaseByID(options.releaseID);
    release = await client.getReleaseByID(options.releaseID);
  } else if (options.releaseLabel) {
    client.queryContentFromReleaseByLabel(options.releaseLabel);
    release = await client.getReleaseByLabel(options.releaseLabel);
  }
  if (release && !args.webhookBody) {
    args.reporter.info(fmtLog.fmtLog(options.repositoryName, `Querying documents from the "${release.label}" Release (ID: "${release.id}")`));
  }
  const { customTypeModels, sharedSliceModels } = await args.cache.get(getModelsCacheKey.getModelsCacheKey({ repositoryName: options.repositoryName }));
  let documentsToCreate = [];
  const documentIDsToDelete = [];
  const hasWebhookBody = args.webhookBody && JSON.stringify(args.webhookBody) !== "{}";
  if (!hasWebhookBody) {
    documentsToCreate = await client.dangerouslyGetAll();
  } else {
    if (isPrismicWebhookBody(args.webhookBody) && args.webhookBody.domain === options.repositoryName) {
      if (!args.webhookBody.secret || args.webhookBody.secret === options.webhookSecret) {
        switch (args.webhookBody.type) {
          case prismic.WebhookType.TestTrigger: {
            args.reporter.info(fmtLog.fmtLog(options.repositoryName, "Success! Received a test trigger webhook. When changes to your content are saved, Gatsby will automatically fetch the changes."));
            break;
          }
          case prismic.WebhookType.APIUpdate: {
            args.reporter.info(fmtLog.fmtLog(options.repositoryName, "Received an API update webhook. Documents will be added, updated, or deleted accordingly."));
            const webhookDocumentIDs = args.webhookBody.documents;
            if (release) {
              const webhookReleaseDocumentIDs = [];
              for (const releaseUpdate of [
                ...args.webhookBody.releases.update || [],
                ...args.webhookBody.releases.addition || [],
                ...args.webhookBody.releases.deletion || []
              ]) {
                if (releaseUpdate.id === release.id) {
                  webhookReleaseDocumentIDs.push(...releaseUpdate.documents);
                }
              }
              webhookDocumentIDs.push(...webhookReleaseDocumentIDs);
            }
            documentsToCreate = await client.getAllByIDs([
              ...new Set(webhookDocumentIDs)
            ]);
            for (const webhookDocumentID of webhookDocumentIDs) {
              if (!documentsToCreate.some((doc) => doc.id === webhookDocumentID)) {
                documentIDsToDelete.push(webhookDocumentID);
              }
            }
            break;
          }
        }
      }
    }
  }
  if (documentsToCreate.length > 0) {
    if (hasWebhookBody) {
      args.reporter.info(fmtLog.fmtLog(options.repositoryName, `Adding or updating the following Prismic documents: [${documentsToCreate.map((doc) => `"${doc.id}"`).join(", ")}]`));
    }
    await createDocumentNodes.createDocumentNodes({
      documents: documentsToCreate,
      customTypeModels,
      sharedSliceModels,
      gatsbyNodeArgs: args,
      pluginOptions: options
    });
  }
  if (documentIDsToDelete.length > 0) {
    args.reporter.info(fmtLog.fmtLog(options.repositoryName, `Deleting the following Prismic documents: [${documentIDsToDelete.map((id) => `"${id}"`).join(", ")}]`));
    for (const documentIDToDelete of documentIDsToDelete) {
      const node = args.getNode(args.createNodeId(documentIDToDelete));
      if (node) {
        args.actions.deleteNode(node);
      }
    }
  }
  const nodesToTouch = args.getNodes().filter((node) => {
    return node.internal.owner === "gatsby-source-prismic" && hasOwnProperty.hasOwnProperty(node, "prismicId") && typeof node.prismicId === "string" && !documentIDsToDelete.includes(node.prismicId);
  });
  for (const nodeToTouch of nodesToTouch) {
    args.actions.touchNode(nodeToTouch);
  }
};
exports.sourceNodes = sourceNodes;
//# sourceMappingURL=sourceNodes.cjs.map
