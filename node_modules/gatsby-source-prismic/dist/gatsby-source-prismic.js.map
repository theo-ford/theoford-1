{"version":3,"file":"gatsby-source-prismic.js","sources":["../src/validateOptions.ts","../src/utils.ts","../src/constants.ts","../src/api.ts","../src/types.ts","../src/documentsToNodes.ts","../src/environment.browser.ts","../src/usePrismicPreview.ts","../src/mergePrismicPreviewData.ts","../src/usePreviewStore.tsx","../src/withPreview.tsx","../src/withPreviewResolver.tsx","../src/withUnpublishedPreview.tsx"],"sourcesContent":["import * as struct from 'superstruct'\n\nimport { PluginOptions, BrowserPluginOptions } from './types'\n\nconst baseSchema = {\n  repositoryName: struct.string(),\n  accessToken: struct.optional(struct.string()),\n  releaseID: struct.optional(struct.string()),\n  schemas: struct.record(struct.string(), struct.object()),\n  linkResolver: struct.defaulted(struct.func(), () => () => () => {}),\n  htmlSerializer: struct.defaulted(struct.func(), () => () => () => {}),\n  fetchLinks: struct.defaulted(struct.array(struct.string()), []),\n  lang: struct.defaulted(struct.string(), '*'),\n  typePathsFilenamePrefix: struct.defaulted(\n    struct.string(),\n    'prismic-typepaths---',\n  ),\n  prismicToolbar: struct.defaulted(\n    struct.union([struct.boolean(), struct.enums(['legacy'])]),\n    false,\n  ),\n  imageImgixParams: struct.defaulted(\n    struct.record(\n      struct.string(),\n      struct.optional(\n        struct.union([struct.string(), struct.number(), struct.boolean()]),\n      ),\n    ),\n    { auto: 'format,compress', fit: 'max', q: 50 },\n  ),\n  imagePlaceholderImgixParams: struct.defaulted(\n    struct.record(\n      struct.string(),\n      struct.optional(\n        struct.union([struct.string(), struct.number(), struct.boolean()]),\n      ),\n    ),\n    { w: 100, blur: 15, q: 20 },\n  ),\n  plugins: struct.defaulted(struct.empty(struct.array()), []),\n} as const\n\nconst PluginOptions = struct.object({\n  ...baseSchema,\n  shouldDownloadImage: struct.defaulted(\n    struct.optional(struct.func()),\n    () => () => false,\n  ),\n  webhookSecret: struct.optional(struct.string()),\n})\n\nconst BrowserPluginOptions = struct.object({\n  ...baseSchema,\n  pathResolver: struct.optional(struct.func()),\n  schemasDigest: struct.string(),\n})\n\nexport const validatePluginOptions = (pluginOptions: PluginOptions) => {\n  const coerced = struct.coerce(pluginOptions, PluginOptions)\n  struct.assert(coerced, PluginOptions)\n  return (coerced as unknown) as PluginOptions\n}\n\nexport const validateBrowserOptions = (\n  browserOptions: BrowserPluginOptions,\n) => {\n  const coerced = struct.coerce(browserOptions, BrowserPluginOptions)\n  struct.assert(coerced, BrowserPluginOptions)\n  return (coerced as unknown) as BrowserPluginOptions\n}\n","import * as React from 'react'\nimport { pascalCase, pascalCaseTransformMerge } from 'pascal-case'\n\n/**\n * Returns a namespaced string intended for logging.\n *\n * @param message Message to namespace.\n *\n * @returns Namespaced message.\n */\nexport const msg = (message: string) => `gatsby-source-prismic - ${message}`\n\n/**\n * Maps key-value tuples of an object to new key-value tuples to create a new\n * object.\n *\n * @param fn Function that maps a key-value tuple to a new key-value tuple.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped key-values.\n */\nexport const mapObj = <T1, T2>(\n  fn: (entry: [string, T1]) => [string, T2],\n  obj: { [key: string]: T1 },\n): { [key: string]: T2 } => {\n  const entries = Object.entries(obj)\n  const pairs = entries.map((x) => fn(x))\n\n  const result: { [key: string]: T2 } = {}\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [k, v] = pairs[i]\n    result[k] = v\n  }\n\n  return result\n}\n\n/**\n * Maps key-value tuples of an object to new key-value tuples to create a new\n * object. The mapper function can be async.\n *\n * @param fn Function that maps a key-value tuple to a new key-value tuple.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped key-values.\n */\nexport const mapObjP = async <T1, T2>(\n  fn: (entry: [string, T1]) => Promise<[string, T2]>,\n  obj: { [key: string]: T1 },\n): Promise<{ [key: string]: T2 }> => {\n  const entries = Object.entries(obj)\n  const pairs = await Promise.all(entries.map((x) => Promise.resolve(fn(x))))\n\n  const result: { [key: string]: T2 } = {}\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [k, v] = pairs[i]\n    result[k] = v\n  }\n\n  return result\n}\n\n/**\n * Maps values of an object to new values.\n *\n * @param fn Function that maps a value and key to a new value.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped values.\n */\nexport const mapObjVals = <T1, T2>(\n  fn: (val: T1, key: string) => T2,\n  obj: { [key: string]: T1 },\n): { [key: string]: T2 } => {\n  const result: { [key: string]: T2 } = {}\n\n  for (const key in obj) result[key] = fn(obj[key], key)\n\n  return result\n}\n\n/**\n * Maps values of an object to new values.\n *\n * @param fn Function that maps a value and key to a new value.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped values.\n */\nexport const mapObjValsP = async <T1, T2>(\n  fn: (val: T1, key: string) => Promise<T2>,\n  obj: { [key: string]: T1 },\n): Promise<{ [key: string]: T2 }> => {\n  const result: { [key: string]: T2 } = {}\n\n  const keys = Object.keys(obj)\n  await Promise.all(\n    keys.map(async (key) => {\n      result[key] = await fn(obj[key], key)\n    }),\n  )\n\n  return result\n}\n\n/**\n * Returns true if the provided object has no keys, false otherwise.\n *\n * @param obj Object to check.\n *\n * @returns `true` if `obj` has no keys, `false` otherwise.\n */\nexport const isEmptyObj = (obj: object) => {\n  for (const _ in obj) return false\n  return true\n}\n\n/**\n * Returns a valid GraphQL type name for a Prismic schema.\n *\n * @param apiId API ID of the schema.\n *\n * @returns Type name for the schema.\n */\nexport const buildSchemaTypeName = (apiId: string) =>\n  pascalCase(`Prismic ${apiId}`, { transform: pascalCaseTransformMerge })\n\n/**\n * Determines whether the current context is the browser.\n *\n * @returns `true` if the current context is the browser, `false` otherwise.\n */\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const getComponentDisplayName = (\n  WrappedComponent: React.ComponentType<any>,\n) => WrappedComponent.displayName || WrappedComponent.name || 'Component'\n\n/**\n * Separates an array in to an array of arrays\n * @param arr The array to chunk\n * @param size the maximum size for each of the resulting arrays\n */\nexport function chunk<T>(arr: T[], size: number): Array<T[]> {\n  const chunks = []\n\n  let i = 0\n\n  while (i < arr.length) {\n    const a = arr.slice(i, (i += size))\n    chunks.push(a)\n  }\n\n  return chunks\n}\n","export const BROWSER_STORE_KEY = '__GATSBY_SOURCE_PRISMIC__'\n\nexport const IMAGE_FIELD_KEYS = [\n  'alt',\n  'copyright',\n  'dimensions',\n  'url',\n] as const\n\nexport const API_PAGE_SIZE = 100\n\nexport const UUID_NAMESPACE = `638f7a53-c567-4eca-8fc1-b23efb1cfb2b`\n\nexport const PLACEHOLDER_NODE_TYPE_SUFFIX = '__PLACEHOLDER'\n","import { getApi } from 'prismic-javascript'\n\nimport { msg, chunk } from './utils'\nimport { API_PAGE_SIZE } from './constants'\n\nimport { SourceNodesArgs, Reporter } from 'gatsby'\nimport PrismicResolvedApi, {\n  QueryOptions,\n} from 'prismic-javascript/d.ts/ResolvedApi'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport { PluginOptions } from './types'\nimport ApiSearchResponse from 'prismic-javascript/d.ts/ApiSearchResponse'\n\nexport function toPrismicUrl(nameOrUrl: string) {\n  const urlRegex = /^https?:\\/\\/([^.]+)\\.(wroom\\.(?:test|io)|prismic\\.io)/\n  const addr = nameOrUrl.match(urlRegex)\n\n  return addr ? addr[0] + '/api/v2' : `https://${nameOrUrl}.prismic.io/api/v2`\n}\n\nexport const createClient = async (\n  repositoryName: string,\n  accessToken?: string,\n) => {\n  const url = toPrismicUrl(repositoryName)\n  return await getApi(url, { accessToken })\n}\n\nconst pagedGet = async (\n  client: PrismicResolvedApi,\n  queryOptions: QueryOptions,\n  page: number,\n  pageSize: number,\n  documents: PrismicDocument[],\n  reporter: Reporter,\n): Promise<PrismicDocument[]> => {\n  reporter.verbose(msg(`fetching documents page ${page}`))\n\n  const response = await client.query([], { ...queryOptions, page, pageSize })\n\n  for (const doc of response.results) documents.push(doc)\n\n  if (page * pageSize < response.total_results_size)\n    return await pagedGet(\n      client,\n      queryOptions,\n      page + 1,\n      pageSize,\n      documents,\n      reporter,\n    )\n\n  return documents\n}\n\nexport const fetchAllDocuments = async (\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n) => {\n  const {\n    repositoryName,\n    releaseID,\n    accessToken,\n    fetchLinks,\n    lang,\n  } = pluginOptions\n  const { reporter } = gatsbyContext\n\n  const client = await createClient(repositoryName, accessToken)\n\n  const queryOptions: QueryOptions = {}\n  if (releaseID) {\n    const ref = client.refs.find((r) => r.id === releaseID)\n    if (ref) {\n      queryOptions.ref = ref.ref\n    } else {\n      reporter.warn(\n        msg(\n          `A release with ID \"${releaseID}\" was not found. Defaulting to the master ref instead.`,\n        ),\n      )\n    }\n  }\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n  if (lang) queryOptions.lang = lang\n\n  return await pagedGet(client, queryOptions, 1, API_PAGE_SIZE, [], reporter)\n}\n\nexport async function fetchDocumentsByIds(\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  documents: string[],\n): Promise<PrismicDocument[]> {\n  const {\n    repositoryName,\n    releaseID,\n    accessToken,\n    fetchLinks,\n    lang,\n  } = pluginOptions\n\n  const { reporter } = gatsbyContext\n\n  const client = await createClient(repositoryName, accessToken)\n\n  const queryOptions: QueryOptions = {}\n\n  if (releaseID) {\n    const ref = client.refs.find((r) => r.id === releaseID)\n    if (ref) {\n      queryOptions.ref = ref.ref\n    } else {\n      reporter.warn(\n        msg(\n          `A release with ID \"${releaseID}\" was not found. Defaulting to the master ref instead.`,\n        ),\n      )\n    }\n  }\n\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n\n  if (lang) queryOptions.lang = lang\n\n  const chunks = chunk(documents, 100).map((docs) =>\n    client.getByIDs(docs, queryOptions),\n  )\n\n  const responses: ApiSearchResponse[] = await Promise.all(chunks)\n\n  return responses.flatMap((doc) => doc.results)\n}\n","import {\n  PluginOptions as GatsbyPluginOptions,\n  SourceNodesArgs,\n  NodeInput,\n  Node,\n} from 'gatsby'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport * as PrismicDOM from 'prismic-dom'\nimport { ImgixUrlParams } from 'gatsby-plugin-imgix'\n\nexport type NodeID = string\n\nexport interface NodeTree {\n  [key: string]: Node\n}\n\nexport interface DocumentNodeInput extends NodeInput {\n  prismicId: PrismicDocument['id']\n  data: { [key: string]: NormalizedField }\n  dataString: string\n  dataRaw: PrismicDocument['data']\n  alternate_languages: NormalizedAlternateLanguagesField\n  url?: string\n}\n\nexport interface SliceNodeInput extends NodeInput {\n  slice_type: string\n  slice_label?: string\n  primary: { [key: string]: NormalizedField }\n  items: { [key: string]: NormalizedField }[]\n}\n\nexport interface DocumentsToNodesEnvironment {\n  createNode: (node: NodeInput) => void\n  createNodeId: (input: string) => string\n  createContentDigest: (input: string | object) => string\n  normalizeImageField: ImageFieldNormalizer\n  normalizeLinkField: LinkFieldNormalizer\n  normalizeSlicesField: SlicesFieldNormalizer\n  normalizeStructuredTextField: StructuredTextFieldNormalizer\n  typePaths: TypePath[]\n  pluginOptions: PluginOptions\n  context:\n    | DocumentsToNodesEnvironmentNodeContext\n    | DocumentsToNodesEnvironmentBrowserContext\n}\n\nexport interface DocumentsToNodesEnvironmentNodeContext {\n  gatsbyContext: SourceNodesArgs\n}\n\nexport interface DocumentsToNodesEnvironmentBrowserContext {\n  hasNodeById: (id: string) => boolean\n  getNodeById: <T>(id: string) => T & Node\n}\n\nexport interface TypePath {\n  path: string[]\n  type: GraphQLType | string\n}\n\nexport type FieldNormalizer<T, N> = (\n  apiId: string,\n  field: T,\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => N | Promise<N>\n\nexport type ImageFieldNormalizer = FieldNormalizer<\n  ImageField,\n  NormalizedImageField\n>\n\nexport type LinkFieldNormalizer = FieldNormalizer<\n  LinkField,\n  NormalizedLinkField\n>\n\nexport type SlicesFieldNormalizer = FieldNormalizer<\n  SliceIDsField,\n  NormalizedSlicesField\n>\n\nexport type StructuredTextFieldNormalizer = FieldNormalizer<\n  StructuredTextField,\n  NormalizedStructuredTextField\n>\n\nexport type Field =\n  | StructuredTextField\n  | ImageField\n  | SlicesField\n  | GroupField\n  | LinkField\n  | AlternateLanguagesField\n  | string\n  | number\n  | boolean\n  | null\n\nexport type NormalizedField =\n  | NormalizedStructuredTextField\n  | NormalizedImageField\n  | NormalizedSlicesField\n  | NormalizedGroupField\n  | NormalizedLinkField\n  | NormalizedAlternateLanguagesField\n  | Field\n\nexport type StructuredTextField = {\n  type: string\n  text: string\n  spans: { [key: string]: unknown }\n}[]\n\nexport interface NormalizedStructuredTextField {\n  html: string\n  text: string\n  raw: StructuredTextField\n}\n\nexport type SlicesField = Slice[]\n\ninterface Slice {\n  slice_type: string\n  slice_label: string | null\n  items: { [key: string]: Field }[]\n  primary: { [key: string]: Field }\n}\n\nexport type SliceIDsField = NodeID[]\n\nexport type NormalizedSlicesField = NodeID[]\n\nexport enum LinkFieldType {\n  Any = 'Any',\n  Document = 'Document',\n  Media = 'Media',\n  Web = 'Web',\n}\n\nexport interface LinkField {\n  link_type: LinkFieldType\n  isBroken: boolean\n  url?: string\n  target?: string\n  size?: number\n  id?: string\n  type?: string\n  tags?: string[]\n  lang?: string\n  slug?: string\n  uid?: string\n}\n\nexport interface NormalizedLinkField extends LinkField {\n  url: string\n  document?: NodeID\n  raw: LinkField\n}\n\nexport interface ImageField {\n  alt?: string\n  copyright?: string\n  dimensions?: { width: number; height: number }\n  url?: string\n  // This should be ImageThumbnailField, but TypeScript does not let us\n  // type unknown field types separatly from known without widening the type.\n  [key: string]: unknown\n}\n\nexport interface NormalizedImageField extends ImageField {\n  thumbnails?: { [key: string]: NormalizedImageField }\n  fixed?: FixedObject\n  fluid?: FluidObject\n  localFile?: NodeID\n}\n\nexport type AlternateLanguagesField = LinkField[]\n\nexport type NormalizedAlternateLanguagesField = AlternateLanguagesField\n\nexport type GroupField = { [key: string]: Field }[]\n\nexport type NormalizedGroupField = { [key: string]: NormalizedField }[]\n\nexport enum FieldType {\n  Boolean = 'Boolean',\n  Color = 'Color',\n  Date = 'Date',\n  Embed = 'Embed',\n  GeoPoint = 'GeoPoint',\n  Group = 'Group',\n  Image = 'Image',\n  Link = 'Link',\n  Number = 'Number',\n  Select = 'Select',\n  Slice = 'Slice',\n  Slices = 'Slices',\n  StructuredText = 'StructuredText',\n  Text = 'Text',\n  Timestamp = 'Timestamp',\n  UID = 'UID',\n  // Internal plugin-specific field not defined in the in Prismic schema.\n  AlternateLanguages = 'AlternateLanguages',\n}\n\nexport enum GraphQLType {\n  ID = 'ID',\n  Boolean = 'Boolean',\n  String = 'String',\n  Float = 'Float',\n  Date = 'Date',\n  JSON = 'JSON',\n  Link = 'PrismicLinkType',\n  Image = 'PrismicImageType',\n  ImageThumbnail = 'PrismicImageThumbnailType',\n  ImageThumbnails = 'PrismicImageThumbnailsType',\n  Embed = 'PrismicEmbedType',\n  GeoPoint = 'PrismicGeoPointType',\n  StructuredText = 'PrismicStructuredTextType',\n  AllDocumentTypes = 'PrismicAllDocumentTypes',\n  Group = 'Group',\n  Slices = 'Slices',\n  AlternateLanguages = 'AlternateLanguages',\n}\n\nexport interface GraphQLTypeObj {\n  type: GraphQLType | string\n  extensions?: { [key: string]: any }\n  resolve?: Function\n}\n\ninterface BaseFieldConfigSchema {\n  label?: string\n  labels?: { [key: string]: string[] }\n  placeholder?: string\n  [key: string]: unknown\n}\n\nexport interface BaseFieldSchema {\n  type: FieldType\n  config: BaseFieldConfigSchema\n}\n\nexport interface ImageFieldSchema extends BaseFieldSchema {\n  type: FieldType.Image\n  config: ImageFieldConfigSchema\n}\n\ninterface ThumbnailSchema {\n  name: string\n  width?: string\n  height?: string\n}\n\ninterface ImageFieldConfigSchema extends BaseFieldConfigSchema {\n  constraint?: { width?: number; height?: number }\n  thumbnails?: ThumbnailSchema[]\n}\n\nexport interface SlicesFieldSchema extends BaseFieldSchema {\n  type: FieldType.Slices\n  fieldset: string\n  config: SlicesFieldConfigSchema\n}\n\ninterface SlicesFieldConfigSchema extends BaseFieldConfigSchema {\n  choices: SliceChoicesSchema\n}\n\nexport interface SliceChoicesSchema {\n  [sliceId: string]: SliceFieldSchema\n}\n\nenum SliceChoiceDisplay {\n  List = 'list',\n  Grid = 'grid',\n}\n\nexport interface SliceFieldSchema extends BaseFieldSchema {\n  type: FieldType.Slice\n  fieldset: string\n  description: string\n  icon: string\n  display: SliceChoiceDisplay\n  repeat?: FieldsSchema\n  'non-repeat'?: FieldsSchema\n}\n\nexport interface GroupFieldSchema extends BaseFieldSchema {\n  type: FieldType.Group\n  config: GroupFieldConfigSchema\n}\n\ninterface GroupFieldConfigSchema extends BaseFieldConfigSchema {\n  fields: FieldsSchema\n}\n\nexport type FieldSchema =\n  | BaseFieldSchema\n  | ImageFieldSchema\n  | SlicesFieldSchema\n  | GroupFieldSchema\n  | SliceFieldSchema\n\nexport interface FieldsSchema {\n  [fieldId: string]: FieldSchema\n}\n\nexport interface Schema {\n  [tabName: string]: {\n    [fieldId: string]: FieldSchema\n  }\n}\n\nexport interface Schemas {\n  [schemaId: string]: Schema\n}\n\nexport type LinkResolver = (doc: object) => string\nexport type PluginLinkResolver = (input: {\n  key?: string\n  value?: unknown\n  node: PrismicDocument\n}) => LinkResolver\n\nexport type HTMLSerializer = typeof PrismicDOM.HTMLSerializer\nexport type PluginHTMLSerializer = (input: {\n  key: string\n  value: unknown\n  node: PrismicDocument\n}) => HTMLSerializer\n\ntype ShouldDownloadImage = (input: {\n  key: string\n  value: unknown\n  node: PrismicDocument\n}) => boolean | Promise<boolean>\n\nexport type BrowserPluginOptions = GatsbyPluginOptions &\n  Pick<\n    PluginOptions,\n    | 'repositoryName'\n    | 'accessToken'\n    | 'fetchLinks'\n    | 'schemas'\n    | 'lang'\n    | 'typePathsFilenamePrefix'\n    | 'prismicToolbar'\n  >\n\nexport interface PluginOptions extends GatsbyPluginOptions {\n  repositoryName: string\n  releaseID?: string\n  accessToken?: string\n  linkResolver?: PluginLinkResolver\n  htmlSerializer?: PluginHTMLSerializer\n  fetchLinks?: string[]\n  schemas: Schemas\n  lang?: string\n  shouldDownloadImage?: ShouldDownloadImage\n  shouldNormalizeImage?: ShouldDownloadImage\n  typePathsFilenamePrefix?: string\n  prismicToolbar?: boolean | 'legacy'\n  imageImgixParams?: ImgixUrlParams\n  imagePlaceholderImgixParams?: ImgixUrlParams\n  webhookSecret?: string\n}\n\nexport interface WebhookBase {\n  type: 'api-update' | 'test-trigger'\n  domain: string\n  apiUrl: string\n  secret: string | null\n}\n\nexport interface TestWebhook extends WebhookBase {\n  type: 'test-trigger'\n}\n\ninterface Operations<T> {\n  update?: T[]\n  addition?: T[]\n  deletion?: T[]\n}\n\nexport interface PrismicWebhook extends WebhookBase {\n  type: 'api-update'\n  masterRef?: string\n  releases: Operations<WebhookRelease>\n  masks: Operations<WebhookMask>\n  tags: Operations<WebhookTag>\n  documents: string[]\n  experiments?: Operations<WebhookExperiment>\n}\n\nexport interface WebhookRelease {\n  id: string\n  ref: string\n  label: string\n  documents: string[]\n}\n\nexport interface WebhookMask {\n  id: string\n  label: string\n}\n\nexport interface WebhookTag {\n  id: string\n}\n\n// Legacy fields\ninterface WebhookExperimentVariation {\n  id: string\n  ref: string\n  label: string\n}\ninterface WebhookExperiment {\n  id: string\n  name: string\n  variations: WebhookExperimentVariation[]\n}\n","import pick from 'lodash.pick'\nimport omit from 'lodash.omit'\n\nimport { mapObjValsP, buildSchemaTypeName } from './utils'\nimport { IMAGE_FIELD_KEYS } from './constants'\n\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport {\n  DocumentsToNodesEnvironment,\n  TypePath,\n  Field,\n  AlternateLanguagesField,\n  GroupField,\n  ImageField,\n  LinkField,\n  SlicesField,\n  StructuredTextField,\n  NormalizedField,\n  NormalizedAlternateLanguagesField,\n  LinkFieldType,\n  GraphQLType,\n  LinkResolver,\n  DocumentNodeInput,\n  SliceNodeInput,\n} from './types'\n\nconst getTypeForPath = (\n  path: TypePath['path'],\n  typePaths: TypePath[],\n): GraphQLType | string | undefined => {\n  const stringifiedPath = JSON.stringify(path)\n  const def = typePaths.find((x) => JSON.stringify(x.path) === stringifiedPath)\n\n  if (!def) return\n  if (/^\\[.*GroupType\\]$/.test(def.type)) return GraphQLType.Group\n  if (/^\\[.*SlicesType\\]$/.test(def.type)) return GraphQLType.Slices\n\n  return def.type\n}\n\nconst normalizeField = async (\n  apiId: string,\n  field: Field,\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n): Promise<NormalizedField> => {\n  const {\n    createNodeId,\n    createNode,\n    createContentDigest,\n    typePaths,\n    normalizeStructuredTextField,\n    normalizeLinkField,\n    normalizeImageField,\n    normalizeSlicesField,\n  } = env\n\n  const type = getTypeForPath([...path, apiId], typePaths)\n\n  switch (type) {\n    case GraphQLType.Image: {\n      const baseObj: ImageField = pick(field as ImageField, IMAGE_FIELD_KEYS)\n      const thumbsObj = omit(field as ImageField, IMAGE_FIELD_KEYS) as {\n        [key: string]: ImageField\n      }\n\n      const base = await normalizeImageField(apiId, baseObj, path, doc, env)\n      const thumbs = await mapObjValsP(\n        async (thumb) =>\n          await normalizeImageField(apiId, thumb, path, doc, env),\n        thumbsObj,\n      )\n\n      return { ...base, thumbnails: thumbs }\n    }\n\n    case GraphQLType.StructuredText: {\n      return await normalizeStructuredTextField(\n        apiId,\n        field as StructuredTextField,\n        path,\n        doc,\n        env,\n      )\n    }\n\n    case GraphQLType.Link: {\n      return await normalizeLinkField(apiId, field as LinkField, path, doc, env)\n    }\n\n    case GraphQLType.Group: {\n      return await normalizeObjs(\n        field as GroupField,\n        [...path, apiId],\n        doc,\n        env,\n      )\n    }\n\n    case GraphQLType.Slices: {\n      const sliceNodeIds = await Promise.all(\n        (field as SlicesField).map(async (slice, index) => {\n          const sliceNodeId = createNodeId(\n            `${doc.type} ${doc.id} ${apiId} ${index}`,\n          )\n\n          const normalizedPrimary = await normalizeObj(\n            slice.primary,\n            [...path, apiId, slice.slice_type, 'primary'],\n            doc,\n            env,\n          )\n\n          const normalizedItems = await normalizeObjs(\n            slice.items,\n            [...path, apiId, slice.slice_type, 'items'],\n            doc,\n            env,\n          )\n\n          const node: SliceNodeInput = {\n            id: sliceNodeId,\n            slice_type: slice.slice_type,\n            slice_label: slice.slice_label ?? undefined,\n            primary: normalizedPrimary,\n            items: normalizedItems,\n            internal: {\n              type: buildSchemaTypeName(\n                `${doc.type} ${apiId} ${slice.slice_type}`,\n              ),\n              contentDigest: createContentDigest(slice),\n            },\n          }\n\n          createNode(node)\n\n          return node.id\n        }),\n      )\n\n      return await normalizeSlicesField(\n        apiId,\n        sliceNodeIds,\n        [...path, apiId],\n        doc,\n        env,\n      )\n    }\n\n    // This field type is not an actual Prismic type and was assigned manually\n    // in `schemasToTypeDefs.ts`.\n    case GraphQLType.AlternateLanguages: {\n      // Treat the array of alternate language documents as a list of link\n      // fields. We need to force the link type to a Document since it is not\n      // there by default.\n      return await Promise.all(\n        (field as AlternateLanguagesField).map(\n          async (item) =>\n            await normalizeLinkField(\n              apiId,\n              {\n                ...item,\n                link_type: LinkFieldType.Document,\n              },\n              path,\n              doc,\n              env,\n            ),\n        ),\n      )\n    }\n\n    default: {\n      return field\n    }\n  }\n}\n\nconst normalizeObj = (\n  obj: { [key: string]: Field } = {},\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n): Promise<{ [key: string]: NormalizedField }> =>\n  mapObjValsP(\n    (field, fieldApiId) => normalizeField(fieldApiId, field, path, doc, env),\n    obj,\n  )\n\nconst normalizeObjs = (\n  objs: { [key: string]: Field }[] = [],\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => Promise.all(objs.map((obj) => normalizeObj(obj, path, doc, env)))\n\nexport const documentToNodes = async (\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => {\n  const { createNode, createContentDigest, createNodeId, pluginOptions } = env\n  const { linkResolver } = pluginOptions\n\n  let linkResolverForDoc: LinkResolver | undefined = undefined\n  if (linkResolver) linkResolverForDoc = linkResolver({ node: doc })\n\n  const docNodeId = createNodeId(doc.id)\n  const docUrl = linkResolverForDoc ? linkResolverForDoc(doc) : undefined\n\n  const normalizedData = await normalizeObj(\n    doc.data,\n    [doc.type, 'data'],\n    doc,\n    env,\n  )\n  const normalizedAlernativeLanguages = (await normalizeField(\n    'alternate_languages',\n    (doc.alternate_languages as unknown) as AlternateLanguagesField,\n    [doc.type],\n    doc,\n    env,\n  )) as NormalizedAlternateLanguagesField\n\n  const node: DocumentNodeInput = {\n    ...doc,\n    id: docNodeId,\n    prismicId: doc.id,\n    data: normalizedData,\n    dataString: JSON.stringify(doc.data),\n    dataRaw: doc.data,\n    alternate_languages: normalizedAlernativeLanguages,\n    url: docUrl,\n    internal: {\n      type: buildSchemaTypeName(doc.type),\n      contentDigest: createContentDigest(doc),\n    },\n    _previewable: doc.id,\n  }\n\n  createNode(node)\n\n  return node.id\n}\n\nexport const documentsToNodes = async (\n  docs: PrismicDocument[],\n  env: DocumentsToNodesEnvironment,\n) => await Promise.all(docs.map((doc) => documentToNodes(doc, env)))\n","import {\n  Link as PrismicDOMLink,\n  RichText as PrismicDOMRichText,\n} from 'prismic-dom'\nimport { buildImgixFixed, buildImgixFluid } from 'gatsby-plugin-imgix'\nimport { v5 as uuidv5 } from 'uuid'\nimport md5 from 'md5'\n\nimport { createClient } from './api'\nimport { documentToNodes } from './documentsToNodes'\nimport { buildSchemaTypeName } from './utils'\nimport { UUID_NAMESPACE, PLACEHOLDER_NODE_TYPE_SUFFIX } from './constants'\n\nimport { NodeInput } from 'gatsby'\nimport { QueryOptions } from 'prismic-javascript/d.ts/ResolvedApi'\nimport {\n  BrowserPluginOptions,\n  DocumentsToNodesEnvironment,\n  DocumentsToNodesEnvironmentBrowserContext,\n  HTMLSerializer,\n  ImageFieldNormalizer,\n  LinkField,\n  LinkFieldNormalizer,\n  LinkFieldType,\n  LinkResolver,\n  NormalizedLinkField,\n  SlicesFieldNormalizer,\n  StructuredTextFieldNormalizer,\n  TypePath,\n  NodeID,\n} from './types'\n\ninterface UnbrokenDocumentLinkField extends LinkField {\n  link_type: LinkFieldType.Document\n  id: string\n  isBroken: false\n}\n\nconst loadLinkFieldDocument = async (\n  field: UnbrokenDocumentLinkField,\n  env: DocumentsToNodesEnvironment,\n) => {\n  const {\n    createNode,\n    createNodeId,\n    createContentDigest,\n    pluginOptions,\n    context,\n  } = env\n  if (field.link_type !== LinkFieldType.Document || !field.id || field.isBroken)\n    return\n\n  const { hasNodeById } = context as DocumentsToNodesEnvironmentBrowserContext\n  const { repositoryName, accessToken, fetchLinks } = pluginOptions\n\n  const linkedDocId = createNodeId(field.id)\n\n  // Skip the fetch process if the node already exists in the store.\n  if (hasNodeById(linkedDocId)) return\n\n  // Create a placeholder node in the store to prevent infinite recursion. This\n  // placeholder will be replaced with the actual node during the\n  // `documentToNodes` call.\n  createNode({\n    id: linkedDocId,\n    internal: {\n      type: buildSchemaTypeName(field.type!) + PLACEHOLDER_NODE_TYPE_SUFFIX,\n      contentDigest: createContentDigest(linkedDocId),\n    },\n  })\n\n  const queryOptions: QueryOptions = {}\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n\n  // Query Prismic's API for the document.\n  const client = await createClient(repositoryName, accessToken)\n  const doc = await client.getByID(field.id, queryOptions)\n\n  await documentToNodes(doc, env)\n}\n\nconst normalizeImageField: ImageFieldNormalizer = async (\n  _apiId,\n  field,\n  _path,\n  _doc,\n  env,\n) => {\n  const { pluginOptions } = env\n\n  const url = field.url\n  if (!url) return field\n\n  const fixed = buildImgixFixed({\n    url,\n    sourceWidth: field.dimensions!.width,\n    sourceHeight: field.dimensions!.height,\n    args: {\n      imgixParams: pluginOptions.imageImgixParams,\n      placeholderImgixParams: pluginOptions.imagePlaceholderImgixParams,\n    },\n  })\n\n  const fluid = buildImgixFluid({\n    url,\n    sourceWidth: field.dimensions!.width,\n    sourceHeight: field.dimensions!.height,\n    args: {\n      imgixParams: pluginOptions.imageImgixParams,\n      placeholderImgixParams: pluginOptions.imagePlaceholderImgixParams,\n    },\n  })\n\n  return { ...field, fixed, fluid }\n}\n\n// TODO: Abstract proxy handler for any `getNodeById` needs (e.g. Slices).\nconst normalizeLinkField: LinkFieldNormalizer = async (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { createNodeId, pluginOptions, context } = env\n  const { getNodeById } = context as DocumentsToNodesEnvironmentBrowserContext\n  const { linkResolver } = pluginOptions\n\n  let linkResolverForField: LinkResolver | undefined = undefined\n  if (linkResolver)\n    linkResolverForField = linkResolver({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  let linkedDocId: NodeID | undefined = undefined\n  if (field && field.link_type === LinkFieldType.Document && field.id)\n    linkedDocId = createNodeId(field.id)\n\n  if (\n    field &&\n    field.link_type === LinkFieldType.Document &&\n    field.id &&\n    !field.isBroken\n  )\n    await loadLinkFieldDocument(field as UnbrokenDocumentLinkField, env)\n\n  return new Proxy(\n    {\n      ...field,\n      url: PrismicDOMLink.url(field, linkResolverForField),\n      document: linkedDocId,\n      raw: field,\n    },\n    {\n      get: (obj, prop: keyof NormalizedLinkField) => {\n        if (prop === 'document') {\n          if (\n            field &&\n            field.link_type === LinkFieldType.Document &&\n            !field.isBroken &&\n            linkedDocId\n          )\n            return getNodeById(linkedDocId)\n\n          return null\n        }\n\n        return obj[prop]\n      },\n    },\n  )\n}\n\nconst normalizeSlicesField: SlicesFieldNormalizer = (\n  _apiId,\n  field,\n  _path,\n  _doc,\n  env,\n) => {\n  const { context } = env\n  const {\n    hasNodeById,\n    getNodeById,\n  } = context as DocumentsToNodesEnvironmentBrowserContext\n\n  return new Proxy(field, {\n    get: (obj, prop: number) => {\n      const id = obj[prop]\n\n      if (hasNodeById(id)) {\n        const node = getNodeById(id)\n        return { ...node, __typename: node.internal.type }\n      }\n\n      return id\n    },\n  })\n}\n\nconst normalizeStructuredTextField: StructuredTextFieldNormalizer = async (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { pluginOptions } = env\n  const { linkResolver, htmlSerializer } = pluginOptions\n\n  let linkResolverForField: LinkResolver | undefined = undefined\n  if (linkResolver)\n    linkResolverForField = linkResolver({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  let htmlSerializerForField: HTMLSerializer | undefined = undefined\n  if (htmlSerializer)\n    htmlSerializerForField = htmlSerializer({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  return {\n    html: PrismicDOMRichText.asHtml(\n      field,\n      linkResolverForField,\n      htmlSerializerForField,\n    ),\n    text: PrismicDOMRichText.asText(field),\n    raw: field,\n  }\n}\n\nexport const createEnvironment = (\n  pluginOptions: BrowserPluginOptions,\n  typePaths: TypePath[],\n): DocumentsToNodesEnvironment => {\n  const nodeStore = new Map()\n\n  const createNode = (node: NodeInput) => void nodeStore.set(node.id, node)\n  const createNodeId = (input: string) => uuidv5(input, UUID_NAMESPACE)\n  const createContentDigest = (input: unknown) => md5(JSON.stringify(input))\n  const hasNodeById = (id: string) => nodeStore.has(id)\n  const getNodeById = (id: string) => nodeStore.get(id)\n\n  return {\n    createNode,\n    createNodeId,\n    createContentDigest,\n    normalizeImageField,\n    normalizeLinkField,\n    normalizeSlicesField,\n    normalizeStructuredTextField,\n    typePaths,\n    pluginOptions,\n    context: { hasNodeById, getNodeById },\n  }\n}\n","import { useReducer, useEffect, useCallback, useMemo } from 'react'\nimport { set as setCookie } from 'es-cookie'\nimport { previewCookie } from 'prismic-javascript'\nimport { camelCase } from 'camel-case'\n\nimport { validateBrowserOptions } from './validateOptions'\nimport { createClient } from './api'\nimport { createEnvironment } from './environment.browser'\nimport { documentToNodes } from './documentsToNodes'\nimport { isBrowser } from './utils'\nimport { BROWSER_STORE_KEY } from './constants'\n\nimport { Node } from 'gatsby'\nimport { QueryOptions } from 'prismic-javascript/d.ts/ResolvedApi'\nimport {\n  PluginOptions,\n  DocumentsToNodesEnvironmentBrowserContext,\n  BrowserPluginOptions,\n} from './types'\n\nexport type UsePrismicPreviewOptions = Pick<\n  PluginOptions,\n  | 'repositoryName'\n  | 'accessToken'\n  | 'linkResolver'\n  | 'htmlSerializer'\n  | 'fetchLinks'\n  | 'lang'\n  | 'typePathsFilenamePrefix'\n> & {\n  pathResolver?: PluginOptions['linkResolver']\n  schemasDigest?: string\n}\n\nenum ActionType {\n  IS_NOT_PREVIEW = 'IS_NOT_PREVIEW',\n  IS_PREVIEW = 'IS_PREVIEW',\n  DOCUMENT_LOADED = 'DOCUMENT_LOADED',\n  RESET = 'RESET',\n}\n\ninterface Action {\n  type: ActionType\n  payload?: {\n    rootNode: Node\n    path?: string\n  }\n}\n\ninterface State {\n  isPreview?: boolean\n  isLoading: boolean\n  previewData?: { [key: string]: Node }\n  path?: string\n}\n\nconst initialState: State = {\n  isPreview: undefined,\n  isLoading: false,\n  previewData: undefined,\n  path: undefined,\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case ActionType.IS_NOT_PREVIEW: {\n      return { ...state, isPreview: false, isLoading: false }\n    }\n\n    case ActionType.IS_PREVIEW: {\n      return { ...state, isPreview: true, isLoading: true }\n    }\n\n    case ActionType.DOCUMENT_LOADED: {\n      if (!action.payload)\n        return { ...state, isPreview: false, isLoading: false }\n\n      const { rootNode, path } = action.payload\n      const type = camelCase(rootNode.internal.type)\n      const previewData = { [type]: rootNode }\n\n      return { ...state, previewData, path, isPreview: true, isLoading: false }\n    }\n\n    case ActionType.RESET: {\n      return initialState\n    }\n\n    default:\n      throw new Error('Invalid error')\n  }\n}\n\nexport const usePrismicPreview = (options: UsePrismicPreviewOptions) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  // @ts-expect-error\n  const hydratedOptions: UsePrismicPreviewOptions & {\n    plugins: []\n    schemas: {}\n    lang: string\n    typePathsFilenamePrefix: string\n    schemasDigest: string\n  } = useMemo(() => {\n    if (!isBrowser) return options\n\n    const context = window[BROWSER_STORE_KEY][options.repositoryName]\n\n    if (!context)\n      throw new Error(\n        `Could not find plugin context for repository: \"${options.repositoryName}\". Check that a gatsby-source-plugin instance exists for that repository. `,\n      )\n\n    return validateBrowserOptions({\n      ...context.pluginOptions,\n      schemasDigest: context.schemasDigest,\n      // Need to include an empty object because environment.browser.ts is\n      // expecting it. We do not include the actual schemas in the browser.\n      schemas: {},\n      ...options,\n    })\n  }, [options])\n\n  const { token, documentId } = useMemo(() => {\n    if (!isBrowser) return {}\n\n    const params = new URLSearchParams(window.location.search)\n\n    return {\n      token: params.get('token') ?? undefined,\n      documentId: params.get('documentId') ?? undefined,\n    }\n  }, [isBrowser ? window.location.search : undefined])\n\n  /**\n   * Set the preview status as soon as possible.\n   */\n  useEffect(() => {\n    const isPreview = Boolean(token && documentId)\n\n    dispatch({\n      type: isPreview ? ActionType.IS_PREVIEW : ActionType.IS_NOT_PREVIEW,\n    })\n  }, [token, documentId])\n\n  const asyncEffect = useCallback(async () => {\n    if (!state.isPreview || !token || !documentId) return\n\n    setCookie(previewCookie, token)\n\n    const queryOptions: QueryOptions = {}\n    if (hydratedOptions.fetchLinks)\n      queryOptions.fetchLinks = hydratedOptions.fetchLinks\n\n    // Query Prismic's API for the document.\n    const client = await createClient(\n      hydratedOptions.repositoryName,\n      hydratedOptions.accessToken,\n    )\n    const doc = await client.getByID(documentId, queryOptions)\n\n    // Process the document into nodes.\n    const typePathsRes = await fetch(\n      `/${hydratedOptions.typePathsFilenamePrefix}${hydratedOptions.schemasDigest}.json`,\n      { headers: { 'Content-Type': 'application/json' } },\n    )\n    const typePaths = await typePathsRes.json()\n    const env = createEnvironment(\n      hydratedOptions as BrowserPluginOptions,\n      typePaths,\n    )\n    const { context } = env\n    const { getNodeById } = context as DocumentsToNodesEnvironmentBrowserContext\n    const rootNodeId = await documentToNodes(doc, env)\n    const rootNode = getNodeById(rootNodeId)\n\n    const resolvedPathResolver =\n      hydratedOptions.pathResolver ?? hydratedOptions.linkResolver\n    const path = resolvedPathResolver\n      ? resolvedPathResolver({ node: doc })(doc)\n      : undefined\n\n    dispatch({ type: ActionType.DOCUMENT_LOADED, payload: { rootNode, path } })\n  }, [state.isPreview])\n\n  useEffect(() => {\n    asyncEffect()\n  }, [asyncEffect])\n\n  return state\n}\n","import { Node } from 'gatsby'\nimport isPlainObject from 'lodash.isplainobject'\n\nimport { NodeTree } from './types'\n\n// Root node field used to compare static data with preview data. If values are\n// equal, the preview node can be treated as an updated version of the static\n// node.\nconst PREVIEWABLE_NODE_ID_FIELD = '_previewable'\n\n// TODO: Remove in v4.0.0\n// Same as PREVIEWABLE_NODE_ID_FIELD, but the legacy version that will be phased out in v4.0.0.\nconst LEGACY_PREVIEWABLE_NODE_ID_FIELD = 'prismicId'\n\nconst traverseAndReplace = (node: any, replacementNode: Node): any => {\n  if (isPlainObject(node)) {\n    // If the nodes share an ID, replace it.\n    if (\n      node[PREVIEWABLE_NODE_ID_FIELD] ===\n      replacementNode[PREVIEWABLE_NODE_ID_FIELD]\n    )\n      return replacementNode\n\n    // TODO: Remove in v4.0.0\n    if (\n      node[LEGACY_PREVIEWABLE_NODE_ID_FIELD] ===\n      replacementNode[LEGACY_PREVIEWABLE_NODE_ID_FIELD]\n    ) {\n      console.warn(\n        'Warning: Merging nested preview data using the prismicId field will be deprecated in gatsby-source-prismic v4.0.0.\\n\\nIf you are relying on this functionality, please update your GraphQL query to include the _previewable field on documents that should be previewable.',\n      )\n      return replacementNode\n    }\n\n    // We did not find the Node to replace. Iterate all properties and continue\n    // to find the Node.\n    const newNode: typeof node = {}\n    for (const subnodeKey in node)\n      newNode[subnodeKey] = traverseAndReplace(\n        node[subnodeKey],\n        replacementNode,\n      )\n    return newNode\n  }\n\n  // Iterate all elements in the node to find the Node.\n  if (Array.isArray(node))\n    return node.map((subnode) => traverseAndReplace(subnode, replacementNode))\n\n  // If the node is not an object or array, it cannot be a Node.\n  return node\n}\n\nexport interface MergePrismicPreviewDataArgs {\n  staticData?: NodeTree\n  previewData?: NodeTree\n  /**\n   * Determines the method with which the function merges preview data into static data.\n   *\n   * - `traverseAndReplace`: Traverse static data nodes and replace with preview data if IDs match.\n   * - `rootReplaceOrInsert`: Replace or insert preview data at the root level.\n   */\n  strategy?: 'traverseAndReplace' | 'rootReplaceOrInsert'\n}\n\n/**\n * Merges preview data with static data. Different merge strategies can be used\n * for different environments.\n */\nexport const mergePrismicPreviewData = ({\n  staticData,\n  previewData,\n  strategy = 'traverseAndReplace',\n}: MergePrismicPreviewDataArgs): NodeTree | undefined => {\n  if (!staticData && !previewData) return\n  if (!staticData) return previewData\n  if (!previewData) return staticData\n\n  switch (strategy) {\n    // Unpublished previews must return data at the root to ensure it is always\n    // available. If staticData and previewData share root-level keys, they are\n    // merged. Otherwise, data will be sibilings.\n    case 'rootReplaceOrInsert':\n      return { ...staticData, ...previewData }\n\n    // Traverse static data nodes and replace with preview data if IDs match.\n    case 'traverseAndReplace':\n    default: {\n      const previewDataRootNodeKey = Object.keys(previewData)[0]\n\n      // TODO: Remove in v4.0.0.\n      if (\n        staticData.hasOwnProperty(previewDataRootNodeKey) &&\n        !staticData[previewDataRootNodeKey][PREVIEWABLE_NODE_ID_FIELD] &&\n        !staticData[previewDataRootNodeKey][LEGACY_PREVIEWABLE_NODE_ID_FIELD]\n      ) {\n        // TODO: Add link to more details on _previewable.\n        console.warn(\n          'Warning: Merging preview data implicitly will be deprecated in gatsby-source-prismic v4.0.0.\\n\\nIf you are relying on this functionality, please update your GraphQL query to include the _previewable field on documents that should be previewable.',\n        )\n        return { ...staticData, ...previewData }\n      }\n\n      return traverseAndReplace(staticData, previewData[previewDataRootNodeKey])\n    }\n  }\n}\n","import * as React from 'react'\nimport { NodeTree } from './types'\n\nconst DEFAULT_INITIAL_PAGES = {}\nconst DEFAULT_INITIAL_ENABLED = false\n\nexport enum ActionType {\n  AddPage,\n  EnablePreviews,\n  DisablePreviews,\n}\n\ntype Action =\n  | {\n      type: ActionType.AddPage\n      payload: { path: string; data: NodeTree }\n    }\n  | { type: Exclude<ActionType, ActionType.AddPage> }\n\ninterface State {\n  pages: Record<string, NodeTree>\n  enabled: boolean\n}\n\nconst createInitialState = (initialState?: Partial<State>): State => ({\n  pages: DEFAULT_INITIAL_PAGES,\n  enabled: DEFAULT_INITIAL_ENABLED,\n  ...initialState,\n})\n\nconst reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case ActionType.AddPage: {\n      return {\n        ...state,\n        pages: {\n          ...state.pages,\n          [action.payload.path]: action.payload.data,\n        },\n        enabled: true,\n      }\n    }\n\n    case ActionType.EnablePreviews: {\n      return { ...state, enabled: true }\n    }\n\n    case ActionType.DisablePreviews: {\n      return { ...state, enabled: false }\n    }\n  }\n}\n\nconst PreviewStoreContext = React.createContext([\n  createInitialState(),\n  () => {},\n] as [State, React.Dispatch<Action>])\n\nexport type PreviewStoreProviderProps = {\n  children?: React.ReactNode\n  initialPages?: State['pages']\n  initialEnabled?: State['enabled']\n}\n\nexport const PreviewStoreProvider = ({\n  children,\n  initialPages = DEFAULT_INITIAL_PAGES,\n  initialEnabled = DEFAULT_INITIAL_ENABLED,\n}: PreviewStoreProviderProps) => {\n  const reducerTuple = React.useReducer(\n    reducer,\n    createInitialState({\n      pages: initialPages,\n      enabled: initialEnabled,\n    }),\n  )\n\n  return (\n    <PreviewStoreContext.Provider value={reducerTuple}>\n      {children}\n    </PreviewStoreContext.Provider>\n  )\n}\n\nexport const usePreviewStore = () => React.useContext(PreviewStoreContext)\n","import * as React from 'react'\nimport { PageProps } from 'gatsby'\n\nimport {\n  mergePrismicPreviewData,\n  MergePrismicPreviewDataArgs,\n} from './mergePrismicPreviewData'\nimport { usePreviewStore } from './usePreviewStore'\nimport { getComponentDisplayName } from './utils'\nimport { NodeTree } from './types'\n\ntype WithPreviewArgs = {\n  mergeStrategy?: MergePrismicPreviewDataArgs['strategy']\n}\n\nexport const withPreview = <TProps extends PageProps>(\n  WrappedComponent: React.ComponentType<TProps>,\n  options?: WithPreviewArgs,\n): React.ComponentType<TProps> => {\n  const WithPreview = (props: TProps) => {\n    const [state] = usePreviewStore()\n\n    const path = props.location.pathname\n    const staticData = props.data as NodeTree\n    const previewData = state.pages[path]\n\n    const data = React.useMemo(\n      () =>\n        state.enabled\n          ? mergePrismicPreviewData({\n              staticData,\n              previewData,\n              strategy: options?.mergeStrategy,\n            })\n          : staticData,\n      [state.enabled, staticData, previewData],\n    )\n\n    return <WrappedComponent {...props} data={data} />\n  }\n  WithPreview.displayName = `withPreview(${getComponentDisplayName(\n    WrappedComponent,\n  )})`\n\n  return WithPreview\n}\n","import * as React from 'react'\nimport { navigate, PageProps } from 'gatsby'\n\nimport {\n  usePrismicPreview,\n  UsePrismicPreviewOptions,\n} from './usePrismicPreview'\nimport { usePreviewStore, ActionType } from './usePreviewStore'\nimport { getComponentDisplayName } from './utils'\n\nexport interface WithPreviewResolverProps {\n  isPreview: boolean | undefined\n  isLoading: boolean\n}\n\nexport const withPreviewResolver = <TProps extends PageProps>(\n  WrappedComponent: React.ComponentType<TProps>,\n  options: UsePrismicPreviewOptions,\n): React.ComponentType<TProps> => {\n  const WithPreviewResolver = (props: TProps) => {\n    const [, dispatch] = usePreviewStore()\n\n    const { isLoading, isPreview, previewData, path } = usePrismicPreview(\n      options,\n    )\n\n    React.useEffect(() => {\n      if (isPreview && previewData && path) {\n        dispatch({\n          type: ActionType.AddPage,\n          payload: { path, data: previewData },\n        })\n        navigate(path)\n      }\n    }, [isPreview, previewData, path, dispatch])\n\n    return (\n      <WrappedComponent\n        {...props}\n        isPreview={isPreview}\n        isLoading={isLoading}\n      />\n    )\n  }\n  WithPreviewResolver.displayName = `withPreviewResolver(${getComponentDisplayName(\n    WrappedComponent,\n  )})`\n\n  return WithPreviewResolver\n}\n","import * as React from 'react'\nimport { PageProps } from 'gatsby'\n\nimport { usePreviewStore } from './usePreviewStore'\nimport { withPreview } from './withPreview'\nimport { msg, getComponentDisplayName } from './utils'\n\ntype WithUnpublishedPreviewArgs = {\n  templateMap: Record<string, React.ComponentType<any>>\n}\n\nexport const withUnpublishedPreview = <TProps extends PageProps>(\n  WrappedComponent: React.ComponentType<TProps>,\n  options: WithUnpublishedPreviewArgs,\n): React.ComponentType<TProps> => {\n  const WithUnpublishedPreview = (props: TProps) => {\n    const [state] = usePreviewStore()\n    const path = props.location.pathname\n    const isPreview = state.pages.hasOwnProperty(path)\n\n    if (isPreview) {\n      const previewData = state.pages[path]\n      const key = Object.keys(previewData)[0]\n      const type = previewData[key].type as string\n      const TemplateComp = options.templateMap[type]\n\n      if (TemplateComp) return <TemplateComp {...props} />\n      else\n        console.warn(\n          msg(\n            `An unpublished preview was detected, but a template component could not be found for a custom type of \"${type}\". Check that the templateMap option in withUnpublishedPreview includes a component for \"${type}\". withUnpublishedPreview will yield to the wrapped component to render.`,\n          ),\n        )\n    }\n\n    return <WrappedComponent {...props} />\n  }\n  WithUnpublishedPreview.displayName = `withUnpublishedPreview(${getComponentDisplayName(\n    WrappedComponent,\n  )})`\n\n  return withPreview(WithUnpublishedPreview, {\n    // In an unpublished preview, we have to assume the component accepts the\n    // preview data as a root-level field.\n    mergeStrategy: 'rootReplaceOrInsert',\n  })\n}\n"],"names":["baseSchema","repositoryName","struct","accessToken","releaseID","schemas","linkResolver","htmlSerializer","fetchLinks","lang","typePathsFilenamePrefix","prismicToolbar","imageImgixParams","auto","fit","q","imagePlaceholderImgixParams","w","blur","plugins","BrowserPluginOptions","shouldDownloadImage","webhookSecret","pathResolver","schemasDigest","mapObjValsP","fn","obj","result","keys","Object","Promise","all","map","key","buildSchemaTypeName","apiId","pascalCase","transform","pascalCaseTransformMerge","isBrowser","window","getComponentDisplayName","WrappedComponent","displayName","name","IMAGE_FIELD_KEYS","createClient","url","nameOrUrl","addr","match","toPrismicUrl","getApi","LinkFieldType","FieldType","GraphQLType","SliceChoiceDisplay","normalizeField","field","path","doc","env","createNodeId","createNode","createContentDigest","typePaths","normalizeStructuredTextField","normalizeLinkField","normalizeImageField","normalizeSlicesField","stringifiedPath","JSON","stringify","def","find","x","test","type","Group","Slices","getTypeForPath","Image","baseObj","pick","thumbsObj","omit","base","thumb","thumbs","thumbnails","StructuredText","Link","normalizeObjs","slice","index","sliceNodeId","id","normalizeObj","primary","slice_type","normalizedPrimary","items","normalizedItems","node","slice_label","undefined","internal","contentDigest","sliceNodeIds","AlternateLanguages","item","link_type","Document","fieldApiId","objs","documentToNodes","pluginOptions","linkResolverForDoc","docNodeId","docUrl","data","normalizedData","alternate_languages","normalizedAlernativeLanguages","prismicId","dataString","dataRaw","_previewable","_apiId","_path","_doc","fixed","buildImgixFixed","sourceWidth","dimensions","width","sourceHeight","height","args","imgixParams","placeholderImgixParams","fluid","buildImgixFluid","Proxy","PrismicDOMLink","linkResolverForField","document","linkedDocId","raw","get","prop","isBroken","getNodeById","context","value","hasNodeById","queryOptions","client","getByID","loadLinkFieldDocument","__typename","htmlSerializerForField","html","PrismicDOMRichText","asHtml","text","asText","ActionType","initialState","isPreview","isLoading","previewData","reducer","state","action","IS_NOT_PREVIEW","IS_PREVIEW","DOCUMENT_LOADED","payload","rootNode","[object Object]","camelCase","RESET","Error","usePrismicPreview","options","dispatch","useReducer","hydratedOptions","useMemo","browserOptions","coerced","validateBrowserOptions","token","documentId","params","URLSearchParams","location","search","useEffect","Boolean","asyncEffect","useCallback","setCookie","previewCookie","fetch","headers","Content-Type","typePathsRes","json","nodeStore","Map","set","input","uuidv5","md5","has","createEnvironment","rootNodeId","resolvedPathResolver","traverseAndReplace","replacementNode","isPlainObject","console","warn","newNode","subnodeKey","Array","isArray","subnode","mergePrismicPreviewData","staticData","strategy","previewDataRootNodeKey","hasOwnProperty","DEFAULT_INITIAL_PAGES","createInitialState","pages","enabled","AddPage","EnablePreviews","DisablePreviews","PreviewStoreContext","React","usePreviewStore","withPreview","WithPreview","props","pathname","mergeStrategy","children","initialPages","initialEnabled","reducerTuple","Provider","WithPreviewResolver","navigate","WithUnpublishedPreview","TemplateComp","templateMap"],"mappings":"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"}