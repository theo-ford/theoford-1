{"version":3,"file":"gatsby-node.js","sources":["../src/validateOptions.ts","../src/utils.ts","../src/types.ts","../src/schemasToTypeDefs.ts","../src/constants.ts","../src/api.ts","../src/documentsToNodes.ts","../src/environment.node.ts","../src/gqlTypes.ts","../src/gatsby-node.ts","../src/webhook.ts"],"sourcesContent":["import * as struct from 'superstruct'\n\nimport { PluginOptions, BrowserPluginOptions } from './types'\n\nconst baseSchema = {\n  repositoryName: struct.string(),\n  accessToken: struct.optional(struct.string()),\n  releaseID: struct.optional(struct.string()),\n  schemas: struct.record(struct.string(), struct.object()),\n  linkResolver: struct.defaulted(struct.func(), () => () => () => {}),\n  htmlSerializer: struct.defaulted(struct.func(), () => () => () => {}),\n  fetchLinks: struct.defaulted(struct.array(struct.string()), []),\n  lang: struct.defaulted(struct.string(), '*'),\n  typePathsFilenamePrefix: struct.defaulted(\n    struct.string(),\n    'prismic-typepaths---',\n  ),\n  prismicToolbar: struct.defaulted(\n    struct.union([struct.boolean(), struct.enums(['legacy'])]),\n    false,\n  ),\n  imageImgixParams: struct.defaulted(\n    struct.record(\n      struct.string(),\n      struct.optional(\n        struct.union([struct.string(), struct.number(), struct.boolean()]),\n      ),\n    ),\n    { auto: 'format,compress', fit: 'max', q: 50 },\n  ),\n  imagePlaceholderImgixParams: struct.defaulted(\n    struct.record(\n      struct.string(),\n      struct.optional(\n        struct.union([struct.string(), struct.number(), struct.boolean()]),\n      ),\n    ),\n    { w: 100, blur: 15, q: 20 },\n  ),\n  plugins: struct.defaulted(struct.empty(struct.array()), []),\n} as const\n\nconst PluginOptions = struct.object({\n  ...baseSchema,\n  shouldDownloadImage: struct.defaulted(\n    struct.optional(struct.func()),\n    () => () => false,\n  ),\n  webhookSecret: struct.optional(struct.string()),\n})\n\nconst BrowserPluginOptions = struct.object({\n  ...baseSchema,\n  pathResolver: struct.optional(struct.func()),\n  schemasDigest: struct.string(),\n})\n\nexport const validatePluginOptions = (pluginOptions: PluginOptions) => {\n  const coerced = struct.coerce(pluginOptions, PluginOptions)\n  struct.assert(coerced, PluginOptions)\n  return (coerced as unknown) as PluginOptions\n}\n\nexport const validateBrowserOptions = (\n  browserOptions: BrowserPluginOptions,\n) => {\n  const coerced = struct.coerce(browserOptions, BrowserPluginOptions)\n  struct.assert(coerced, BrowserPluginOptions)\n  return (coerced as unknown) as BrowserPluginOptions\n}\n","import * as React from 'react'\nimport { pascalCase, pascalCaseTransformMerge } from 'pascal-case'\n\n/**\n * Returns a namespaced string intended for logging.\n *\n * @param message Message to namespace.\n *\n * @returns Namespaced message.\n */\nexport const msg = (message: string) => `gatsby-source-prismic - ${message}`\n\n/**\n * Maps key-value tuples of an object to new key-value tuples to create a new\n * object.\n *\n * @param fn Function that maps a key-value tuple to a new key-value tuple.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped key-values.\n */\nexport const mapObj = <T1, T2>(\n  fn: (entry: [string, T1]) => [string, T2],\n  obj: { [key: string]: T1 },\n): { [key: string]: T2 } => {\n  const entries = Object.entries(obj)\n  const pairs = entries.map((x) => fn(x))\n\n  const result: { [key: string]: T2 } = {}\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [k, v] = pairs[i]\n    result[k] = v\n  }\n\n  return result\n}\n\n/**\n * Maps key-value tuples of an object to new key-value tuples to create a new\n * object. The mapper function can be async.\n *\n * @param fn Function that maps a key-value tuple to a new key-value tuple.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped key-values.\n */\nexport const mapObjP = async <T1, T2>(\n  fn: (entry: [string, T1]) => Promise<[string, T2]>,\n  obj: { [key: string]: T1 },\n): Promise<{ [key: string]: T2 }> => {\n  const entries = Object.entries(obj)\n  const pairs = await Promise.all(entries.map((x) => Promise.resolve(fn(x))))\n\n  const result: { [key: string]: T2 } = {}\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [k, v] = pairs[i]\n    result[k] = v\n  }\n\n  return result\n}\n\n/**\n * Maps values of an object to new values.\n *\n * @param fn Function that maps a value and key to a new value.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped values.\n */\nexport const mapObjVals = <T1, T2>(\n  fn: (val: T1, key: string) => T2,\n  obj: { [key: string]: T1 },\n): { [key: string]: T2 } => {\n  const result: { [key: string]: T2 } = {}\n\n  for (const key in obj) result[key] = fn(obj[key], key)\n\n  return result\n}\n\n/**\n * Maps values of an object to new values.\n *\n * @param fn Function that maps a value and key to a new value.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped values.\n */\nexport const mapObjValsP = async <T1, T2>(\n  fn: (val: T1, key: string) => Promise<T2>,\n  obj: { [key: string]: T1 },\n): Promise<{ [key: string]: T2 }> => {\n  const result: { [key: string]: T2 } = {}\n\n  const keys = Object.keys(obj)\n  await Promise.all(\n    keys.map(async (key) => {\n      result[key] = await fn(obj[key], key)\n    }),\n  )\n\n  return result\n}\n\n/**\n * Returns true if the provided object has no keys, false otherwise.\n *\n * @param obj Object to check.\n *\n * @returns `true` if `obj` has no keys, `false` otherwise.\n */\nexport const isEmptyObj = (obj: object) => {\n  for (const _ in obj) return false\n  return true\n}\n\n/**\n * Returns a valid GraphQL type name for a Prismic schema.\n *\n * @param apiId API ID of the schema.\n *\n * @returns Type name for the schema.\n */\nexport const buildSchemaTypeName = (apiId: string) =>\n  pascalCase(`Prismic ${apiId}`, { transform: pascalCaseTransformMerge })\n\n/**\n * Determines whether the current context is the browser.\n *\n * @returns `true` if the current context is the browser, `false` otherwise.\n */\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const getComponentDisplayName = (\n  WrappedComponent: React.ComponentType<any>,\n) => WrappedComponent.displayName || WrappedComponent.name || 'Component'\n\n/**\n * Separates an array in to an array of arrays\n * @param arr The array to chunk\n * @param size the maximum size for each of the resulting arrays\n */\nexport function chunk<T>(arr: T[], size: number): Array<T[]> {\n  const chunks = []\n\n  let i = 0\n\n  while (i < arr.length) {\n    const a = arr.slice(i, (i += size))\n    chunks.push(a)\n  }\n\n  return chunks\n}\n","import {\n  PluginOptions as GatsbyPluginOptions,\n  SourceNodesArgs,\n  NodeInput,\n  Node,\n} from 'gatsby'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport * as PrismicDOM from 'prismic-dom'\nimport { ImgixUrlParams } from 'gatsby-plugin-imgix'\n\nexport type NodeID = string\n\nexport interface NodeTree {\n  [key: string]: Node\n}\n\nexport interface DocumentNodeInput extends NodeInput {\n  prismicId: PrismicDocument['id']\n  data: { [key: string]: NormalizedField }\n  dataString: string\n  dataRaw: PrismicDocument['data']\n  alternate_languages: NormalizedAlternateLanguagesField\n  url?: string\n}\n\nexport interface SliceNodeInput extends NodeInput {\n  slice_type: string\n  slice_label?: string\n  primary: { [key: string]: NormalizedField }\n  items: { [key: string]: NormalizedField }[]\n}\n\nexport interface DocumentsToNodesEnvironment {\n  createNode: (node: NodeInput) => void\n  createNodeId: (input: string) => string\n  createContentDigest: (input: string | object) => string\n  normalizeImageField: ImageFieldNormalizer\n  normalizeLinkField: LinkFieldNormalizer\n  normalizeSlicesField: SlicesFieldNormalizer\n  normalizeStructuredTextField: StructuredTextFieldNormalizer\n  typePaths: TypePath[]\n  pluginOptions: PluginOptions\n  context:\n    | DocumentsToNodesEnvironmentNodeContext\n    | DocumentsToNodesEnvironmentBrowserContext\n}\n\nexport interface DocumentsToNodesEnvironmentNodeContext {\n  gatsbyContext: SourceNodesArgs\n}\n\nexport interface DocumentsToNodesEnvironmentBrowserContext {\n  hasNodeById: (id: string) => boolean\n  getNodeById: <T>(id: string) => T & Node\n}\n\nexport interface TypePath {\n  path: string[]\n  type: GraphQLType | string\n}\n\nexport type FieldNormalizer<T, N> = (\n  apiId: string,\n  field: T,\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => N | Promise<N>\n\nexport type ImageFieldNormalizer = FieldNormalizer<\n  ImageField,\n  NormalizedImageField\n>\n\nexport type LinkFieldNormalizer = FieldNormalizer<\n  LinkField,\n  NormalizedLinkField\n>\n\nexport type SlicesFieldNormalizer = FieldNormalizer<\n  SliceIDsField,\n  NormalizedSlicesField\n>\n\nexport type StructuredTextFieldNormalizer = FieldNormalizer<\n  StructuredTextField,\n  NormalizedStructuredTextField\n>\n\nexport type Field =\n  | StructuredTextField\n  | ImageField\n  | SlicesField\n  | GroupField\n  | LinkField\n  | AlternateLanguagesField\n  | string\n  | number\n  | boolean\n  | null\n\nexport type NormalizedField =\n  | NormalizedStructuredTextField\n  | NormalizedImageField\n  | NormalizedSlicesField\n  | NormalizedGroupField\n  | NormalizedLinkField\n  | NormalizedAlternateLanguagesField\n  | Field\n\nexport type StructuredTextField = {\n  type: string\n  text: string\n  spans: { [key: string]: unknown }\n}[]\n\nexport interface NormalizedStructuredTextField {\n  html: string\n  text: string\n  raw: StructuredTextField\n}\n\nexport type SlicesField = Slice[]\n\ninterface Slice {\n  slice_type: string\n  slice_label: string | null\n  items: { [key: string]: Field }[]\n  primary: { [key: string]: Field }\n}\n\nexport type SliceIDsField = NodeID[]\n\nexport type NormalizedSlicesField = NodeID[]\n\nexport enum LinkFieldType {\n  Any = 'Any',\n  Document = 'Document',\n  Media = 'Media',\n  Web = 'Web',\n}\n\nexport interface LinkField {\n  link_type: LinkFieldType\n  isBroken: boolean\n  url?: string\n  target?: string\n  size?: number\n  id?: string\n  type?: string\n  tags?: string[]\n  lang?: string\n  slug?: string\n  uid?: string\n}\n\nexport interface NormalizedLinkField extends LinkField {\n  url: string\n  document?: NodeID\n  raw: LinkField\n}\n\nexport interface ImageField {\n  alt?: string\n  copyright?: string\n  dimensions?: { width: number; height: number }\n  url?: string\n  // This should be ImageThumbnailField, but TypeScript does not let us\n  // type unknown field types separatly from known without widening the type.\n  [key: string]: unknown\n}\n\nexport interface NormalizedImageField extends ImageField {\n  thumbnails?: { [key: string]: NormalizedImageField }\n  fixed?: FixedObject\n  fluid?: FluidObject\n  localFile?: NodeID\n}\n\nexport type AlternateLanguagesField = LinkField[]\n\nexport type NormalizedAlternateLanguagesField = AlternateLanguagesField\n\nexport type GroupField = { [key: string]: Field }[]\n\nexport type NormalizedGroupField = { [key: string]: NormalizedField }[]\n\nexport enum FieldType {\n  Boolean = 'Boolean',\n  Color = 'Color',\n  Date = 'Date',\n  Embed = 'Embed',\n  GeoPoint = 'GeoPoint',\n  Group = 'Group',\n  Image = 'Image',\n  Link = 'Link',\n  Number = 'Number',\n  Select = 'Select',\n  Slice = 'Slice',\n  Slices = 'Slices',\n  StructuredText = 'StructuredText',\n  Text = 'Text',\n  Timestamp = 'Timestamp',\n  UID = 'UID',\n  // Internal plugin-specific field not defined in the in Prismic schema.\n  AlternateLanguages = 'AlternateLanguages',\n}\n\nexport enum GraphQLType {\n  ID = 'ID',\n  Boolean = 'Boolean',\n  String = 'String',\n  Float = 'Float',\n  Date = 'Date',\n  JSON = 'JSON',\n  Link = 'PrismicLinkType',\n  Image = 'PrismicImageType',\n  ImageThumbnail = 'PrismicImageThumbnailType',\n  ImageThumbnails = 'PrismicImageThumbnailsType',\n  Embed = 'PrismicEmbedType',\n  GeoPoint = 'PrismicGeoPointType',\n  StructuredText = 'PrismicStructuredTextType',\n  AllDocumentTypes = 'PrismicAllDocumentTypes',\n  Group = 'Group',\n  Slices = 'Slices',\n  AlternateLanguages = 'AlternateLanguages',\n}\n\nexport interface GraphQLTypeObj {\n  type: GraphQLType | string\n  extensions?: { [key: string]: any }\n  resolve?: Function\n}\n\ninterface BaseFieldConfigSchema {\n  label?: string\n  labels?: { [key: string]: string[] }\n  placeholder?: string\n  [key: string]: unknown\n}\n\nexport interface BaseFieldSchema {\n  type: FieldType\n  config: BaseFieldConfigSchema\n}\n\nexport interface ImageFieldSchema extends BaseFieldSchema {\n  type: FieldType.Image\n  config: ImageFieldConfigSchema\n}\n\ninterface ThumbnailSchema {\n  name: string\n  width?: string\n  height?: string\n}\n\ninterface ImageFieldConfigSchema extends BaseFieldConfigSchema {\n  constraint?: { width?: number; height?: number }\n  thumbnails?: ThumbnailSchema[]\n}\n\nexport interface SlicesFieldSchema extends BaseFieldSchema {\n  type: FieldType.Slices\n  fieldset: string\n  config: SlicesFieldConfigSchema\n}\n\ninterface SlicesFieldConfigSchema extends BaseFieldConfigSchema {\n  choices: SliceChoicesSchema\n}\n\nexport interface SliceChoicesSchema {\n  [sliceId: string]: SliceFieldSchema\n}\n\nenum SliceChoiceDisplay {\n  List = 'list',\n  Grid = 'grid',\n}\n\nexport interface SliceFieldSchema extends BaseFieldSchema {\n  type: FieldType.Slice\n  fieldset: string\n  description: string\n  icon: string\n  display: SliceChoiceDisplay\n  repeat?: FieldsSchema\n  'non-repeat'?: FieldsSchema\n}\n\nexport interface GroupFieldSchema extends BaseFieldSchema {\n  type: FieldType.Group\n  config: GroupFieldConfigSchema\n}\n\ninterface GroupFieldConfigSchema extends BaseFieldConfigSchema {\n  fields: FieldsSchema\n}\n\nexport type FieldSchema =\n  | BaseFieldSchema\n  | ImageFieldSchema\n  | SlicesFieldSchema\n  | GroupFieldSchema\n  | SliceFieldSchema\n\nexport interface FieldsSchema {\n  [fieldId: string]: FieldSchema\n}\n\nexport interface Schema {\n  [tabName: string]: {\n    [fieldId: string]: FieldSchema\n  }\n}\n\nexport interface Schemas {\n  [schemaId: string]: Schema\n}\n\nexport type LinkResolver = (doc: object) => string\nexport type PluginLinkResolver = (input: {\n  key?: string\n  value?: unknown\n  node: PrismicDocument\n}) => LinkResolver\n\nexport type HTMLSerializer = typeof PrismicDOM.HTMLSerializer\nexport type PluginHTMLSerializer = (input: {\n  key: string\n  value: unknown\n  node: PrismicDocument\n}) => HTMLSerializer\n\ntype ShouldDownloadImage = (input: {\n  key: string\n  value: unknown\n  node: PrismicDocument\n}) => boolean | Promise<boolean>\n\nexport type BrowserPluginOptions = GatsbyPluginOptions &\n  Pick<\n    PluginOptions,\n    | 'repositoryName'\n    | 'accessToken'\n    | 'fetchLinks'\n    | 'schemas'\n    | 'lang'\n    | 'typePathsFilenamePrefix'\n    | 'prismicToolbar'\n  >\n\nexport interface PluginOptions extends GatsbyPluginOptions {\n  repositoryName: string\n  releaseID?: string\n  accessToken?: string\n  linkResolver?: PluginLinkResolver\n  htmlSerializer?: PluginHTMLSerializer\n  fetchLinks?: string[]\n  schemas: Schemas\n  lang?: string\n  shouldDownloadImage?: ShouldDownloadImage\n  shouldNormalizeImage?: ShouldDownloadImage\n  typePathsFilenamePrefix?: string\n  prismicToolbar?: boolean | 'legacy'\n  imageImgixParams?: ImgixUrlParams\n  imagePlaceholderImgixParams?: ImgixUrlParams\n  webhookSecret?: string\n}\n\nexport interface WebhookBase {\n  type: 'api-update' | 'test-trigger'\n  domain: string\n  apiUrl: string\n  secret: string | null\n}\n\nexport interface TestWebhook extends WebhookBase {\n  type: 'test-trigger'\n}\n\ninterface Operations<T> {\n  update?: T[]\n  addition?: T[]\n  deletion?: T[]\n}\n\nexport interface PrismicWebhook extends WebhookBase {\n  type: 'api-update'\n  masterRef?: string\n  releases: Operations<WebhookRelease>\n  masks: Operations<WebhookMask>\n  tags: Operations<WebhookTag>\n  documents: string[]\n  experiments?: Operations<WebhookExperiment>\n}\n\nexport interface WebhookRelease {\n  id: string\n  ref: string\n  label: string\n  documents: string[]\n}\n\nexport interface WebhookMask {\n  id: string\n  label: string\n}\n\nexport interface WebhookTag {\n  id: string\n}\n\n// Legacy fields\ninterface WebhookExperimentVariation {\n  id: string\n  ref: string\n  label: string\n}\ninterface WebhookExperiment {\n  id: string\n  name: string\n  variations: WebhookExperimentVariation[]\n}\n","import { msg, mapObjVals, isEmptyObj, buildSchemaTypeName } from './utils'\n\nimport {\n  GatsbyGraphQLType,\n  NodePluginSchema,\n  CreateSchemaCustomizationArgs,\n} from 'gatsby'\nimport {\n  BaseFieldSchema,\n  FieldSchema,\n  FieldType,\n  GraphQLType,\n  GraphQLTypeObj,\n  GroupFieldSchema,\n  ImageFieldSchema,\n  Schema,\n  Schemas,\n  SliceFieldSchema,\n  SlicesFieldSchema,\n  TypePath,\n  SliceIDsField,\n} from './types'\n\n/**\n * Enqueues a GraphQL type definition to be created at a later time.\n *\n * @param typeDef GraphQL type definition.\n */\ntype EnqueueTypeDef = (typeDef: GatsbyGraphQLType) => void\n\n/**\n * Enqueues a TypePath to the store.\n *\n * @param path Path to the field.\n * @param type GraphQL type identifier for the field.\n */\ntype EnqueueTypePath = (path: string[], type: GraphQLType | string) => void\n\ninterface SchemasToTypeDefsContext {\n  customTypeApiId: string\n  sliceZoneId?: string\n  gatsbyContext: CreateSchemaCustomizationArgs\n  enqueueTypeDef: EnqueueTypeDef\n  enqueueTypePath: EnqueueTypePath\n}\n\nconst fieldToType = (\n  apiId: string,\n  field: FieldSchema,\n  path: string[],\n  context: SchemasToTypeDefsContext,\n): GraphQLTypeObj | GraphQLType | string => {\n  const {\n    customTypeApiId,\n    enqueueTypeDef,\n    enqueueTypePath,\n    gatsbyContext,\n    sliceZoneId,\n  } = context\n  const { schema: gatsbySchema, reporter } = gatsbyContext\n\n  // Casting to `FieldType | string` since we may come across an unsupported\n  // field type. This will happen when Prismic introduces new field types.\n  switch (field.type as FieldType | string) {\n    case FieldType.UID:\n    case FieldType.Color:\n    case FieldType.Select:\n    case FieldType.Text: {\n      const type = GraphQLType.String\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Boolean: {\n      const type = GraphQLType.Boolean\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.StructuredText: {\n      const type = GraphQLType.StructuredText\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Number: {\n      const type = GraphQLType.Float\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Date:\n    case FieldType.Timestamp: {\n      const type = GraphQLType.Date\n      enqueueTypePath([...path, apiId], type)\n      return { type, extensions: { dateformat: {} } }\n    }\n\n    case FieldType.GeoPoint: {\n      const type = GraphQLType.GeoPoint\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Embed: {\n      const type = GraphQLType.Embed\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Image: {\n      const type = GraphQLType.Image\n      enqueueTypePath([...path, apiId], type)\n\n      const thumbnails = (field as ImageFieldSchema)?.config?.thumbnails\n      if (thumbnails)\n        for (const thumbnail of thumbnails)\n          enqueueTypePath(\n            [...path, apiId, 'thumbnails', thumbnail.name],\n            GraphQLType.ImageThumbnail,\n          )\n\n      return type\n    }\n\n    case FieldType.Link: {\n      const type = GraphQLType.Link\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Group: {\n      const groupTypeName = buildSchemaTypeName(\n        `${customTypeApiId} ${apiId} GroupType`,\n      )\n      enqueueTypeDef(\n        gatsbySchema.buildObjectType({\n          name: groupTypeName,\n          fields: mapObjVals(\n            (subfield, subfieldApiId) =>\n              fieldToType(subfieldApiId, subfield, [...path, apiId], context),\n            (field as GroupFieldSchema).config.fields,\n          ) as { [key: string]: GraphQLType },\n          extensions: { infer: false },\n        }),\n      )\n\n      const type = `[${groupTypeName}]`\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    case FieldType.Slices: {\n      const slicesTypeName = buildSchemaTypeName(\n        `${customTypeApiId} ${apiId} SlicesType`,\n      )\n      const sliceChoices = (field as SlicesFieldSchema).config.choices\n      const sliceChoiceTypes = Object.entries(sliceChoices).map(\n        ([sliceChoiceApiId, sliceChoice]) =>\n          fieldToType(sliceChoiceApiId, sliceChoice, [...path, apiId], {\n            ...context,\n            sliceZoneId: apiId,\n          }),\n      )\n\n      enqueueTypeDef(\n        gatsbySchema.buildUnionType({\n          name: slicesTypeName,\n          types: sliceChoiceTypes as string[],\n        }),\n      )\n\n      const type = `[${slicesTypeName}]`\n      enqueueTypePath([...path, apiId], type)\n      return {\n        type,\n        resolve: (parent: SliceIDsField, _args: any, context: any, info: any) =>\n          context.nodeModel.getNodesByIds({ ids: parent[info.path.key] }),\n      }\n    }\n\n    case FieldType.Slice: {\n      const {\n        'non-repeat': primaryFields,\n        repeat: itemsFields,\n      } = field as SliceFieldSchema\n\n      const sliceFieldTypes: { [key: string]: string } = {\n        slice_type: `${GraphQLType.String}!`,\n        slice_label: GraphQLType.String,\n      }\n\n      if (primaryFields && !isEmptyObj(primaryFields)) {\n        const primaryTypeName = buildSchemaTypeName(\n          `${customTypeApiId} ${sliceZoneId} ${apiId} PrimaryType`,\n        )\n\n        enqueueTypeDef(\n          gatsbySchema.buildObjectType({\n            name: primaryTypeName,\n            fields: mapObjVals(\n              (primaryField, primaryFieldApiId) =>\n                fieldToType(\n                  primaryFieldApiId,\n                  primaryField,\n                  [...path, apiId, 'primary'],\n                  context,\n                ),\n              primaryFields,\n            ) as { [key: string]: GraphQLType },\n          }),\n        )\n\n        enqueueTypePath([...path, apiId, 'primary'], primaryTypeName)\n        sliceFieldTypes.primary = primaryTypeName\n      }\n\n      if (itemsFields && !isEmptyObj(itemsFields)) {\n        const itemTypeName = buildSchemaTypeName(\n          `${customTypeApiId} ${sliceZoneId} ${apiId} ItemType`,\n        )\n\n        enqueueTypeDef(\n          gatsbySchema.buildObjectType({\n            name: itemTypeName,\n            fields: mapObjVals(\n              (itemField, itemFieldApiId) =>\n                fieldToType(\n                  itemFieldApiId,\n                  itemField,\n                  [...path, apiId, 'items'],\n                  context,\n                ),\n              itemsFields,\n            ) as { [key: string]: GraphQLType },\n          }),\n        )\n\n        const type = `[${itemTypeName}]`\n        enqueueTypePath([...path, apiId, 'items'], type)\n        sliceFieldTypes.items = type\n      }\n\n      const type = buildSchemaTypeName(\n        `${customTypeApiId} ${sliceZoneId} ${apiId}`,\n      )\n\n      enqueueTypeDef(\n        gatsbySchema.buildObjectType({\n          name: type,\n          fields: sliceFieldTypes,\n          interfaces: ['PrismicSliceType', 'Node'],\n          extensions: { infer: false },\n        }),\n      )\n\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n\n    // Internal plugin-specific field not defined in the Prismic schema.\n    case FieldType.AlternateLanguages: {\n      // The types are intentionally different here. We need to handle\n      // AlternateLanguages in a unique way in `documentToNodes.js`.\n      enqueueTypePath([...path, apiId], FieldType.AlternateLanguages)\n      return `[${GraphQLType.Link}!]!`\n    }\n\n    default: {\n      const fieldPath = [...path, apiId].join('.')\n      reporter.warn(\n        msg(\n          `Unsupported field type \"${field.type}\" detected for field \"${fieldPath}\". JSON type will be used.`,\n        ),\n      )\n\n      const type = GraphQLType.JSON\n      enqueueTypePath([...path, apiId], type)\n      return type\n    }\n  }\n}\n\nconst schemaToTypeDefs = (\n  apiId: string,\n  schema: Schema,\n  context: SchemasToTypeDefsContext,\n) => {\n  const { enqueueTypeDef, enqueueTypePath, gatsbyContext } = context\n  const { schema: gatsbySchema } = gatsbyContext\n\n  // UID fields are defined at the same level as data fields, but are a level\n  // above data in API responses. Pulling it out separately here allows us to\n  // process the UID field differently than the data fields.\n  const { uid: uidField, ...dataFields } = Object.values(schema).reduce(\n    (acc, tab) => {\n      for (const fieldApiId in tab) acc[fieldApiId] = tab[fieldApiId]\n      return acc\n    },\n    {},\n  )\n\n  // UID fields must be conditionally processed since not all custom types\n  // implement a UID field.\n  let uidFieldType: string | undefined\n  if (uidField)\n    uidFieldType = fieldToType('uid', uidField, [apiId], context) as string\n\n  // The alternate languages field acts as a list of Link fields. Note:\n  // AlternateLanguages is an internal plugin-specific type, not from Prismic.\n  const alternateLanguagesFieldType = fieldToType(\n    'alternate_languages',\n    { type: FieldType.AlternateLanguages } as BaseFieldSchema,\n    [apiId],\n    context,\n  )\n\n  // Create a type for all data fields.\n  const dataTypeName = buildSchemaTypeName(`${apiId} DataType`)\n  enqueueTypePath([apiId, 'data'], dataTypeName)\n  enqueueTypeDef(\n    gatsbySchema.buildObjectType({\n      name: dataTypeName,\n      fields: mapObjVals(\n        (dataField, dataFieldApiId) =>\n          fieldToType(dataFieldApiId, dataField, [apiId, 'data'], context),\n        dataFields,\n      ) as { [key: string]: GraphQLType },\n      extensions: { infer: false },\n    }),\n  )\n\n  // Create the main schema type.\n  const schemaTypeName = buildSchemaTypeName(apiId)\n  const schemaFieldTypes: {\n    [key: string]: GraphQLTypeObj | GraphQLType | string\n  } = {\n    data: dataTypeName,\n    dataRaw: `${GraphQLType.JSON}!`,\n    dataString: `${GraphQLType.String}!`,\n    first_publication_date: {\n      type: `${GraphQLType.Date}!`,\n      extensions: { dateformat: {} },\n    },\n    href: `${GraphQLType.String}!`,\n    url: GraphQLType.String,\n    lang: `${GraphQLType.String}!`,\n    last_publication_date: {\n      type: `${GraphQLType.Date}!`,\n      extensions: { dateformat: {} },\n    },\n    tags: `[${GraphQLType.String}!]!`,\n    alternate_languages: alternateLanguagesFieldType as string,\n    type: `${GraphQLType.String}!`,\n    prismicId: `${GraphQLType.ID}!`,\n    _previewable: `${GraphQLType.ID}!`,\n  }\n  if (uidFieldType) schemaFieldTypes.uid = uidFieldType\n\n  enqueueTypePath([apiId], schemaTypeName)\n  enqueueTypeDef(\n    gatsbySchema.buildObjectType({\n      name: schemaTypeName,\n      fields: schemaFieldTypes as { [key: string]: GraphQLType },\n      interfaces: ['PrismicDocument', 'Node'],\n      extensions: { infer: false },\n    }),\n  )\n}\n\n/**\n * Returns an GraphQL type containing all image thumbnail field names. If no thumbnails are configured, a placeholder type is returned.\n *\n * @param typePaths Array of TypePaths for all schemas.\n * @param gatsbySchema Gatsby node schema.\n *\n * @returns GraphQL type to support image thumbnail fields.\n */\nconst buildImageThumbnailsType = (\n  typePaths: TypePath[],\n  gatsbySchema: NodePluginSchema,\n) => {\n  const keys = typePaths\n    .filter((typePath) => typePath.type === GraphQLType.ImageThumbnail)\n    .map((typePath) => typePath.path[typePath.path.length - 1])\n\n  if (keys.length < 1)\n    return gatsbySchema.buildScalarType({\n      name: GraphQLType.ImageThumbnails,\n      serialize: () => null,\n    })\n\n  const fieldTypes = keys.reduce((acc, key) => {\n    acc[key] = GraphQLType.ImageThumbnail\n    return acc\n  }, {} as { [key: string]: GraphQLType.ImageThumbnail })\n\n  return gatsbySchema.buildObjectType({\n    name: GraphQLType.ImageThumbnails,\n    fields: fieldTypes,\n  })\n}\n\n/**\n * Converts an object mapping custom type API IDs to JSON schemas to an array\n * of GraphQL type definitions. The result is intended to be called with\n * Gatsby's `createTypes` action.\n *\n * @param schemas An object mapping custom type API IDs to JSON schemas.\n *\n * @returns An array of GraphQL type definitions.\n */\nexport const schemasToTypeDefs = (\n  schemas: Schemas,\n  gatsbyContext: CreateSchemaCustomizationArgs,\n) => {\n  const { schema: gatsbySchema } = gatsbyContext\n\n  const typeDefs: GatsbyGraphQLType[] = []\n  const enqueueTypeDef: EnqueueTypeDef = (typeDef) =>\n    void typeDefs.push(typeDef)\n\n  const typePaths: TypePath[] = []\n  const enqueueTypePath: EnqueueTypePath = (path, type) =>\n    void typePaths.push({ path, type })\n\n  const context = { gatsbyContext, enqueueTypeDef, enqueueTypePath }\n\n  for (const apiId in schemas)\n    schemaToTypeDefs(apiId, schemas[apiId], {\n      ...context,\n      customTypeApiId: apiId,\n    })\n\n  // Union type for all schemas.\n  enqueueTypeDef(\n    gatsbySchema.buildUnionType({\n      name: GraphQLType.AllDocumentTypes,\n      types: Object.keys(schemas).map((apiId) => buildSchemaTypeName(apiId)),\n    }),\n  )\n\n  // Type for all image thumbnail fields.\n  enqueueTypeDef(buildImageThumbnailsType(typePaths, gatsbySchema))\n\n  return { typeDefs, typePaths }\n}\n","export const BROWSER_STORE_KEY = '__GATSBY_SOURCE_PRISMIC__'\n\nexport const IMAGE_FIELD_KEYS = [\n  'alt',\n  'copyright',\n  'dimensions',\n  'url',\n] as const\n\nexport const API_PAGE_SIZE = 100\n\nexport const UUID_NAMESPACE = `638f7a53-c567-4eca-8fc1-b23efb1cfb2b`\n\nexport const PLACEHOLDER_NODE_TYPE_SUFFIX = '__PLACEHOLDER'\n","import { getApi } from 'prismic-javascript'\n\nimport { msg, chunk } from './utils'\nimport { API_PAGE_SIZE } from './constants'\n\nimport { SourceNodesArgs, Reporter } from 'gatsby'\nimport PrismicResolvedApi, {\n  QueryOptions,\n} from 'prismic-javascript/d.ts/ResolvedApi'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport { PluginOptions } from './types'\nimport ApiSearchResponse from 'prismic-javascript/d.ts/ApiSearchResponse'\n\nexport function toPrismicUrl(nameOrUrl: string) {\n  const urlRegex = /^https?:\\/\\/([^.]+)\\.(wroom\\.(?:test|io)|prismic\\.io)/\n  const addr = nameOrUrl.match(urlRegex)\n\n  return addr ? addr[0] + '/api/v2' : `https://${nameOrUrl}.prismic.io/api/v2`\n}\n\nexport const createClient = async (\n  repositoryName: string,\n  accessToken?: string,\n) => {\n  const url = toPrismicUrl(repositoryName)\n  return await getApi(url, { accessToken })\n}\n\nconst pagedGet = async (\n  client: PrismicResolvedApi,\n  queryOptions: QueryOptions,\n  page: number,\n  pageSize: number,\n  documents: PrismicDocument[],\n  reporter: Reporter,\n): Promise<PrismicDocument[]> => {\n  reporter.verbose(msg(`fetching documents page ${page}`))\n\n  const response = await client.query([], { ...queryOptions, page, pageSize })\n\n  for (const doc of response.results) documents.push(doc)\n\n  if (page * pageSize < response.total_results_size)\n    return await pagedGet(\n      client,\n      queryOptions,\n      page + 1,\n      pageSize,\n      documents,\n      reporter,\n    )\n\n  return documents\n}\n\nexport const fetchAllDocuments = async (\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n) => {\n  const {\n    repositoryName,\n    releaseID,\n    accessToken,\n    fetchLinks,\n    lang,\n  } = pluginOptions\n  const { reporter } = gatsbyContext\n\n  const client = await createClient(repositoryName, accessToken)\n\n  const queryOptions: QueryOptions = {}\n  if (releaseID) {\n    const ref = client.refs.find((r) => r.id === releaseID)\n    if (ref) {\n      queryOptions.ref = ref.ref\n    } else {\n      reporter.warn(\n        msg(\n          `A release with ID \"${releaseID}\" was not found. Defaulting to the master ref instead.`,\n        ),\n      )\n    }\n  }\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n  if (lang) queryOptions.lang = lang\n\n  return await pagedGet(client, queryOptions, 1, API_PAGE_SIZE, [], reporter)\n}\n\nexport async function fetchDocumentsByIds(\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  documents: string[],\n): Promise<PrismicDocument[]> {\n  const {\n    repositoryName,\n    releaseID,\n    accessToken,\n    fetchLinks,\n    lang,\n  } = pluginOptions\n\n  const { reporter } = gatsbyContext\n\n  const client = await createClient(repositoryName, accessToken)\n\n  const queryOptions: QueryOptions = {}\n\n  if (releaseID) {\n    const ref = client.refs.find((r) => r.id === releaseID)\n    if (ref) {\n      queryOptions.ref = ref.ref\n    } else {\n      reporter.warn(\n        msg(\n          `A release with ID \"${releaseID}\" was not found. Defaulting to the master ref instead.`,\n        ),\n      )\n    }\n  }\n\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n\n  if (lang) queryOptions.lang = lang\n\n  const chunks = chunk(documents, 100).map((docs) =>\n    client.getByIDs(docs, queryOptions),\n  )\n\n  const responses: ApiSearchResponse[] = await Promise.all(chunks)\n\n  return responses.flatMap((doc) => doc.results)\n}\n","import pick from 'lodash.pick'\nimport omit from 'lodash.omit'\n\nimport { mapObjValsP, buildSchemaTypeName } from './utils'\nimport { IMAGE_FIELD_KEYS } from './constants'\n\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport {\n  DocumentsToNodesEnvironment,\n  TypePath,\n  Field,\n  AlternateLanguagesField,\n  GroupField,\n  ImageField,\n  LinkField,\n  SlicesField,\n  StructuredTextField,\n  NormalizedField,\n  NormalizedAlternateLanguagesField,\n  LinkFieldType,\n  GraphQLType,\n  LinkResolver,\n  DocumentNodeInput,\n  SliceNodeInput,\n} from './types'\n\nconst getTypeForPath = (\n  path: TypePath['path'],\n  typePaths: TypePath[],\n): GraphQLType | string | undefined => {\n  const stringifiedPath = JSON.stringify(path)\n  const def = typePaths.find((x) => JSON.stringify(x.path) === stringifiedPath)\n\n  if (!def) return\n  if (/^\\[.*GroupType\\]$/.test(def.type)) return GraphQLType.Group\n  if (/^\\[.*SlicesType\\]$/.test(def.type)) return GraphQLType.Slices\n\n  return def.type\n}\n\nconst normalizeField = async (\n  apiId: string,\n  field: Field,\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n): Promise<NormalizedField> => {\n  const {\n    createNodeId,\n    createNode,\n    createContentDigest,\n    typePaths,\n    normalizeStructuredTextField,\n    normalizeLinkField,\n    normalizeImageField,\n    normalizeSlicesField,\n  } = env\n\n  const type = getTypeForPath([...path, apiId], typePaths)\n\n  switch (type) {\n    case GraphQLType.Image: {\n      const baseObj: ImageField = pick(field as ImageField, IMAGE_FIELD_KEYS)\n      const thumbsObj = omit(field as ImageField, IMAGE_FIELD_KEYS) as {\n        [key: string]: ImageField\n      }\n\n      const base = await normalizeImageField(apiId, baseObj, path, doc, env)\n      const thumbs = await mapObjValsP(\n        async (thumb) =>\n          await normalizeImageField(apiId, thumb, path, doc, env),\n        thumbsObj,\n      )\n\n      return { ...base, thumbnails: thumbs }\n    }\n\n    case GraphQLType.StructuredText: {\n      return await normalizeStructuredTextField(\n        apiId,\n        field as StructuredTextField,\n        path,\n        doc,\n        env,\n      )\n    }\n\n    case GraphQLType.Link: {\n      return await normalizeLinkField(apiId, field as LinkField, path, doc, env)\n    }\n\n    case GraphQLType.Group: {\n      return await normalizeObjs(\n        field as GroupField,\n        [...path, apiId],\n        doc,\n        env,\n      )\n    }\n\n    case GraphQLType.Slices: {\n      const sliceNodeIds = await Promise.all(\n        (field as SlicesField).map(async (slice, index) => {\n          const sliceNodeId = createNodeId(\n            `${doc.type} ${doc.id} ${apiId} ${index}`,\n          )\n\n          const normalizedPrimary = await normalizeObj(\n            slice.primary,\n            [...path, apiId, slice.slice_type, 'primary'],\n            doc,\n            env,\n          )\n\n          const normalizedItems = await normalizeObjs(\n            slice.items,\n            [...path, apiId, slice.slice_type, 'items'],\n            doc,\n            env,\n          )\n\n          const node: SliceNodeInput = {\n            id: sliceNodeId,\n            slice_type: slice.slice_type,\n            slice_label: slice.slice_label ?? undefined,\n            primary: normalizedPrimary,\n            items: normalizedItems,\n            internal: {\n              type: buildSchemaTypeName(\n                `${doc.type} ${apiId} ${slice.slice_type}`,\n              ),\n              contentDigest: createContentDigest(slice),\n            },\n          }\n\n          createNode(node)\n\n          return node.id\n        }),\n      )\n\n      return await normalizeSlicesField(\n        apiId,\n        sliceNodeIds,\n        [...path, apiId],\n        doc,\n        env,\n      )\n    }\n\n    // This field type is not an actual Prismic type and was assigned manually\n    // in `schemasToTypeDefs.ts`.\n    case GraphQLType.AlternateLanguages: {\n      // Treat the array of alternate language documents as a list of link\n      // fields. We need to force the link type to a Document since it is not\n      // there by default.\n      return await Promise.all(\n        (field as AlternateLanguagesField).map(\n          async (item) =>\n            await normalizeLinkField(\n              apiId,\n              {\n                ...item,\n                link_type: LinkFieldType.Document,\n              },\n              path,\n              doc,\n              env,\n            ),\n        ),\n      )\n    }\n\n    default: {\n      return field\n    }\n  }\n}\n\nconst normalizeObj = (\n  obj: { [key: string]: Field } = {},\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n): Promise<{ [key: string]: NormalizedField }> =>\n  mapObjValsP(\n    (field, fieldApiId) => normalizeField(fieldApiId, field, path, doc, env),\n    obj,\n  )\n\nconst normalizeObjs = (\n  objs: { [key: string]: Field }[] = [],\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => Promise.all(objs.map((obj) => normalizeObj(obj, path, doc, env)))\n\nexport const documentToNodes = async (\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => {\n  const { createNode, createContentDigest, createNodeId, pluginOptions } = env\n  const { linkResolver } = pluginOptions\n\n  let linkResolverForDoc: LinkResolver | undefined = undefined\n  if (linkResolver) linkResolverForDoc = linkResolver({ node: doc })\n\n  const docNodeId = createNodeId(doc.id)\n  const docUrl = linkResolverForDoc ? linkResolverForDoc(doc) : undefined\n\n  const normalizedData = await normalizeObj(\n    doc.data,\n    [doc.type, 'data'],\n    doc,\n    env,\n  )\n  const normalizedAlernativeLanguages = (await normalizeField(\n    'alternate_languages',\n    (doc.alternate_languages as unknown) as AlternateLanguagesField,\n    [doc.type],\n    doc,\n    env,\n  )) as NormalizedAlternateLanguagesField\n\n  const node: DocumentNodeInput = {\n    ...doc,\n    id: docNodeId,\n    prismicId: doc.id,\n    data: normalizedData,\n    dataString: JSON.stringify(doc.data),\n    dataRaw: doc.data,\n    alternate_languages: normalizedAlernativeLanguages,\n    url: docUrl,\n    internal: {\n      type: buildSchemaTypeName(doc.type),\n      contentDigest: createContentDigest(doc),\n    },\n    _previewable: doc.id,\n  }\n\n  createNode(node)\n\n  return node.id\n}\n\nexport const documentsToNodes = async (\n  docs: PrismicDocument[],\n  env: DocumentsToNodesEnvironment,\n) => await Promise.all(docs.map((doc) => documentToNodes(doc, env)))\n","import {\n  Link as PrismicDOMLink,\n  RichText as PrismicDOMRichText,\n} from 'prismic-dom'\nimport { createRemoteFileNode } from 'gatsby-source-filesystem'\n\nimport { msg } from './utils'\n\nimport { SourceNodesArgs } from 'gatsby'\nimport {\n  DocumentsToNodesEnvironment,\n  DocumentsToNodesEnvironmentNodeContext,\n  HTMLSerializer,\n  ImageFieldNormalizer,\n  LinkFieldNormalizer,\n  LinkFieldType,\n  LinkResolver,\n  NodeID,\n  PluginOptions,\n  SlicesFieldNormalizer,\n  StructuredTextFieldNormalizer,\n  TypePath,\n} from './types'\n\nconst normalizeImageField: ImageFieldNormalizer = async (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { createNode, createNodeId, pluginOptions, context } = env\n  const { gatsbyContext } = context as DocumentsToNodesEnvironmentNodeContext\n  const { store, cache, actions, reporter } = gatsbyContext\n  const { touchNode } = actions\n  let { shouldDownloadImage } = pluginOptions\n\n  let shouldAttemptToCreateRemoteFileNode = true\n  if (shouldDownloadImage)\n    shouldAttemptToCreateRemoteFileNode = await shouldDownloadImage({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  if (!shouldAttemptToCreateRemoteFileNode || !field.url) return field\n\n  let fileNodeID: NodeID | undefined = undefined\n  const cachedImageDataKey = `prismic-image-${field.url}`\n  const cachedImageData: { fileNodeID: string } = await cache.get(\n    cachedImageDataKey,\n  )\n\n  if (cachedImageData) {\n    fileNodeID = cachedImageData.fileNodeID\n    touchNode({ nodeId: fileNodeID })\n  } else {\n    try {\n      const fullQualityUrl = new URL(field.url)\n      // Remove auto parameter to download the original, full-quality image\n      // from Imgix. Prismic automatically adds `auto=format,compress`, which,\n      // when compounded with Sharp's compression, results in a doubly\n      // compressed image.\n      fullQualityUrl.searchParams.delete('auto')\n\n      const fileNode = await createRemoteFileNode({\n        url: fullQualityUrl.toString(),\n        store,\n        cache,\n        createNode,\n        createNodeId,\n        reporter,\n      })\n\n      if (fileNode) {\n        fileNodeID = fileNode.id\n        await cache.set(cachedImageDataKey, { fileNodeID })\n      }\n    } catch (error) {\n      reporter.error(\n        msg(`failed to create image node with URL: ${field.url}`),\n        new Error(error),\n      )\n    }\n  }\n\n  return { ...field, localFile: fileNodeID }\n}\n\nconst normalizeLinkField: LinkFieldNormalizer = (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { createNodeId, pluginOptions } = env\n  const { linkResolver } = pluginOptions\n\n  let linkResolverForField: LinkResolver | undefined = undefined\n  if (linkResolver)\n    linkResolverForField = linkResolver({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  let linkedDocId: NodeID | undefined = undefined\n  if (field && field.link_type === LinkFieldType.Document && field.id)\n    linkedDocId = createNodeId(field.id)\n\n  return {\n    ...field,\n    url: PrismicDOMLink.url(field, linkResolverForField),\n    document: linkedDocId,\n    raw: field,\n  }\n}\n\nconst normalizeSlicesField: SlicesFieldNormalizer = (\n  _apiId,\n  field,\n  _path,\n  _doc,\n  _env,\n) => field\n\nconst normalizeStructuredTextField: StructuredTextFieldNormalizer = (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { pluginOptions } = env\n  const { linkResolver, htmlSerializer } = pluginOptions\n\n  let linkResolverForField: LinkResolver | undefined = undefined\n  if (linkResolver)\n    linkResolverForField = linkResolver({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  let htmlSerializerForField: HTMLSerializer | undefined = undefined\n  if (htmlSerializer)\n    htmlSerializerForField = htmlSerializer({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  return {\n    html: PrismicDOMRichText.asHtml(\n      field,\n      linkResolverForField,\n      htmlSerializerForField,\n    ),\n    text: PrismicDOMRichText.asText(field),\n    raw: field,\n  }\n}\n\nexport const createEnvironment = (\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  typePaths: TypePath[],\n): DocumentsToNodesEnvironment => {\n  const { actions, createNodeId, createContentDigest } = gatsbyContext\n  const { createNode } = actions\n\n  return {\n    createNode,\n    createNodeId: (input: string) => createNodeId(input),\n    createContentDigest,\n    normalizeImageField,\n    normalizeLinkField,\n    normalizeSlicesField,\n    normalizeStructuredTextField,\n    typePaths,\n    pluginOptions,\n    context: { gatsbyContext },\n  }\n}\n","import { NodePluginSchema, GatsbyCache } from 'gatsby'\nimport { ImgixUrlParams } from 'gatsby-plugin-imgix'\nimport {\n  createImgixFixedType,\n  createImgixFluidType,\n  createImgixFixedSchemaFieldConfig,\n  createImgixFluidSchemaFieldConfig,\n  createImgixUrlSchemaFieldConfig,\n} from 'gatsby-plugin-imgix/dist/node'\n\ninterface PartialPrismicImageType {\n  url?: string\n  dimensions?: {\n    width: number\n    height: number\n  }\n}\n\ntype BuildPrismicImageTypesArgs = {\n  schema: NodePluginSchema\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const buildPrismicImageTypes = ({\n  schema,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: BuildPrismicImageTypesArgs) => {\n  const resolveUrl = (obj: PartialPrismicImageType) => obj.url\n  const resolveWidth = (obj: PartialPrismicImageType) => obj.dimensions?.width\n  const resolveHeight = (obj: PartialPrismicImageType) => obj.dimensions?.height\n\n  const PrismicImageFixedType = createImgixFixedType({\n    name: 'PrismicImageFixedType',\n    cache,\n  })\n\n  const PrismicImageFluidType = createImgixFluidType({\n    name: 'PrismicImageFluidType',\n    cache,\n  })\n\n  const PrismicImageType = schema.buildObjectType({\n    name: 'PrismicImageType',\n    description: 'An image field with optional constrained thumbnails.',\n    interfaces: ['PrismicImageInterface'],\n    fields: {\n      alt: 'String',\n      copyright: 'String',\n      dimensions: 'PrismicImageDimensionsType',\n      url: createImgixUrlSchemaFieldConfig({\n        resolveUrl,\n        defaultImgixParams,\n      }),\n      fixed: createImgixFixedSchemaFieldConfig({\n        type: PrismicImageFixedType,\n        resolveUrl,\n        resolveWidth,\n        resolveHeight,\n        cache,\n        defaultImgixParams,\n        defaultPlaceholderImgixParams,\n      }),\n      fluid: createImgixFluidSchemaFieldConfig({\n        type: PrismicImageFluidType,\n        resolveUrl,\n        resolveWidth,\n        resolveHeight,\n        cache,\n        defaultImgixParams,\n        defaultPlaceholderImgixParams,\n      }),\n      localFile: {\n        type: 'File',\n        extensions: { link: {} },\n      },\n      thumbnails: 'PrismicImageThumbnailsType',\n    },\n  })\n\n  const PrismicImageThumbnailType = schema.buildObjectType({\n    name: 'PrismicImageThumbnailType',\n    description: 'An image thumbnail with constraints.',\n    interfaces: ['PrismicImageInterface'],\n    fields: {\n      alt: 'String',\n      copyright: 'String',\n      dimensions: 'PrismicImageDimensionsType',\n      url: createImgixUrlSchemaFieldConfig({\n        resolveUrl,\n        defaultImgixParams,\n      }),\n      fixed: createImgixFixedSchemaFieldConfig({\n        type: PrismicImageFixedType,\n        resolveUrl,\n        resolveWidth,\n        resolveHeight,\n        cache,\n        defaultImgixParams,\n      }),\n      fluid: createImgixFluidSchemaFieldConfig({\n        type: PrismicImageFluidType,\n        resolveUrl,\n        resolveWidth,\n        resolveHeight,\n        cache,\n        defaultImgixParams,\n      }),\n      localFile: {\n        type: 'File',\n        extensions: { link: {} },\n      },\n    },\n  })\n\n  // The following types must be separated to in order to pass them separately\n  // to two different `createTypes` calls in gatsby-node.ts. `createTypes`\n  // requires that all passed types are of the same class.\n  return [\n    // Imgix GraphQLObjectType instances\n    [PrismicImageFixedType, PrismicImageFluidType],\n    // Prismic GatsbyGraphQLObjectType instances\n    [PrismicImageType, PrismicImageThumbnailType],\n  ]\n}\n\nconst gql = (query: TemplateStringsArray) => String(query).replace(`\\n`, ` `)\n\nexport const types = gql`\n  \"A text field with formatting options.\"\n  type PrismicStructuredTextType {\n    \"The HTML value of the text using \\`prismic-dom\\` and the HTML serializer.\"\n    html: String\n    \"The plain text value of the text using \\`prismic-dom\\`.\"\n    text: String\n    \"The field's value without transformations exactly as it comes from the Prismic API.\"\n    raw: JSON\n  }\n\n  \"A field for storing geo-coordinates.\"\n  type PrismicGeoPointType {\n    \"The latitude value of the geo-coordinate.\"\n    latitude: Float\n    \"The longitude value of the geo-coordinate.\"\n    longitude: Float\n  }\n\n  \"Embed videos, songs, tweets, slices, etc.\"\n  type PrismicEmbedType {\n    \"The ID of the resource author. Fetched via oEmbed data.\"\n    author_id: ID\n    \"The name of the author/owner of the resource. Fetched via oEmbed data.\"\n    author_name: String\n    \"A URL for the author/owner of the resource. Fetched via oEmbed data.\"\n    author_url: String\n    \"The suggested cache lifetime for this resource, in seconds. Consumers may choose to use this value or not. Fetched via oEmbed data.\"\n    cache_age: String\n    \"The URL of the resource.\"\n    embed_url: String\n    \"The HTML required to display the resource. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities. Fetched via oEmbed data.\"\n    html: String\n    \"The name of the resource.\"\n    name: String\n    \"The name of the resource provider. Fetched via oEmbed data.\"\n    provider_name: String\n    \"The URL of the resource provider. Fetched via oEmbed data.\"\n    provider_url: String\n    \"The width of the resource's thumbnail. Fetched via oEmbed data.\"\n    thumbnail_height: Int\n    \"A URL to a thumbnail image representing the resource. Fetched via oEmbed data.\"\n    thumbnail_url: String\n    \"The width of the resource's thumbnail. Fetched via oEmbed data.\"\n    thumbnail_width: Int\n    \"A text title, describing the resource. Fetched via oEmbed data.\"\n    title: String\n    \"The resource type. Fetched via oEmbed data.\"\n    type: String\n    \"The oEmbed version number.\"\n    version: String\n    \"The source URL of the resource. Fetched via oEmbed data.\"\n    url: String\n    \"The width in pixel of the resource. Fetched via oEmbed data.\"\n    width: Int\n    \"The height in pixel of the resource. Fetched via oEmbed data.\"\n    height: Int\n    \"The ID of the resource media. Fetched via oEmbed data.\"\n    media_id: ID\n    \"A description for the resource.\"\n    description: String\n    \"The ID of a video.\"\n    video_id: ID\n  }\n\n  \"Dimensions for images.\"\n  type PrismicImageDimensionsType {\n    \"Width of the image in pixels.\"\n    width: Int!\n    \"Height of the image in pixels.\"\n    height: Int!\n  }\n\n  \"Types of links.\"\n  enum PrismicLinkTypes {\n    \"Any of the other types\"\n    Any\n    \"Internal content\"\n    Document\n    \"Internal media content\"\n    Media\n    \"URL\"\n    Web\n  }\n\n  \"Link to web, media, and internal content.\"\n  type PrismicLinkType {\n    \"The type of link.\"\n    link_type: PrismicLinkTypes!\n    \"If a Document link, \\`true\\` if linked document does not exist, \\`false\\` otherwise.\"\n    isBroken: Boolean\n    \"The document's URL derived via the link resolver.\"\n    url: String\n    \"The link's target.\"\n    target: String\n    \"If a Media link, the size of the file.\"\n    size: Int\n    \"If a Document link, the linked document's Prismic ID.\"\n    id: ID\n    \"If a Document link, the linked document's Prismic custom type API ID\"\n    type: String\n    \"If a Document link, the linked document's list of tags.\"\n    tags: [String]\n    \"If a Document link, the linked document's language.\"\n    lang: String\n    \"If a Document link, the linked document's slug.\"\n    slug: String\n    \"If a Document link, the linked document's UID.\"\n    uid: String\n    \"If a Document link, the linked document.\"\n    document: PrismicAllDocumentTypes @link\n    \"The field's value without transformations exactly as it comes from the Prismic API.\"\n    raw: JSON\n  }\n\n  interface PrismicSliceType {\n    \"The slice type API ID.\"\n    slice_type: String!\n\n    \"The slice label.\"\n    slice_label: String\n  }\n\n  interface PrismicImageInterface {\n    \"The image's alternative text.\"\n    alt: String\n    \"The image's copyright text.\"\n    copyright: String\n    \"The image's dimensions.\"\n    dimensions: PrismicImageDimensionsType\n    \"The image's URL on Prismic's CDN.\"\n    url: String\n    \"The locally downloaded image if \\`shouldNormalizeImage\\` returns true.\"\n    localFile: File\n    fixed: PrismicImageFixedType\n    fluid: PrismicImageFluidType\n  }\n\n  interface PrismicDocument {\n    \"The document's data object without transformations exactly as it comes from the Prismic API.\"\n    dataRaw: JSON!\n    \"The document's data object without transformations. The object is stringified via \\`JSON.stringify\\` to eliminate the need to declare subfields.\"\n    dataString: String\n      @deprecated(reason: \"Use \\`dataRaw\\` instead which returns JSON.\")\n    \"The document's initial publication date.\"\n    first_publication_date(\n      \"Format the date using Moment.js' date tokens, e.g. \\`date(formatString: \\\\\"YYYY MMMM DD\\\\\")\\`. See https://momentjs.com/docs/#/displaying/format/ for documentation for different tokens.\"\n      formatString: String\n      \"Returns a string generated with Moment.js' \\`fromNow\\` function\"\n      fromNow: Boolean\n      \"Returns the difference between this date and the current time. Defaults to \\\\\"milliseconds\\\\\" but you can also pass in as the measurement \\\\\"years\\\\\", \\\\\"months\\\\\", \\\\\"weeks\\\\\", \\\\\"days\\\\\", \\\\\"hours\\\\\", \\\\\"minutes\\\\\", and \\\\\"seconds\\\\\".\"\n      difference: String\n      \"Configures the locale Moment.js will use to format the date.\"\n      locale: String\n    ): Date\n    \"The document's Prismic API URL.\"\n    href: String\n    \"The document's URL derived via the link resolver.\"\n    url: String\n    \"Globally unique identifier. Note that this differs from the \\`prismicID\\` field.\"\n    id: ID!\n    \"The document's language.\"\n    lang: String!\n    \"The document's most recent publication date\"\n    last_publication_date(\n      \"Format the date using Moment.js' date tokens, e.g. \\`date(formatString: \\\\\"YYYY MMMM DD\\\\\")\\`. See https://momentjs.com/docs/#/displaying/format/ for documentation for different tokens.\"\n      formatString: String\n      \"Returns a string generated with Moment.js' \\`fromNow\\` function\"\n      fromNow: Boolean\n      \"Returns the difference between this date and the current time. Defaults to \\\\\"milliseconds\\\\\" but you can also pass in as the measurement \\\\\"years\\\\\", \\\\\"months\\\\\", \\\\\"weeks\\\\\", \\\\\"days\\\\\", \\\\\"hours\\\\\", \\\\\"minutes\\\\\", and \\\\\"seconds\\\\\".\"\n      difference: String\n      \"Configures the locale Moment.js will use to format the date.\"\n      locale: String\n    ): Date\n    \"The document's list of tags.\"\n    tags: [String!]!\n    \"Alternate languages for the document.\"\n    alternate_languages: [PrismicLinkType!]!\n    \"The document's Prismic API ID type.\"\n    type: String!\n    \"The document's Prismic ID.\"\n    prismicId: ID!\n    \"Marks the document as previewable using Prismic's preview system. Include this field if updates to the document should be previewable by content editors before publishing. **Note: the value of this field is not stable and should not be used directly**.\"\n    _previewable: ID!\n  }\n`\n","import fs from 'fs'\nimport path from 'path'\nimport md5 from 'md5'\n\nimport { validatePluginOptions } from './validateOptions'\nimport { schemasToTypeDefs } from './schemasToTypeDefs'\nimport { fetchAllDocuments } from './api'\nimport { documentsToNodes } from './documentsToNodes'\nimport { createEnvironment } from './environment.node'\nimport { types, buildPrismicImageTypes } from './gqlTypes'\nimport { msg } from './utils'\n\nimport {\n  GatsbyNode,\n  SourceNodesArgs,\n  GatsbyGraphQLType,\n  CreateSchemaCustomizationArgs,\n} from 'gatsby'\nimport { PluginOptions, TypePath, PrismicWebhook } from './types'\nimport { isPrismicWebhook, validateSecret, handleWebhook } from './webhook'\n\nexport const createSchemaCustomization: NonNullable<\n  GatsbyNode['createSchemaCustomization']\n> = async (\n  args: CreateSchemaCustomizationArgs,\n  pluginOptions: PluginOptions,\n) => {\n  const { typeDefs } = schemasToTypeDefs(pluginOptions.schemas, args)\n\n  createPrismicTypes(pluginOptions, args, typeDefs)\n}\n\nconst createPrismicTypes = (\n  pluginOptions: PluginOptions,\n  gatsbyContext: CreateSchemaCustomizationArgs,\n  typeDefs: GatsbyGraphQLType[],\n) => {\n  /**\n   * Create types derived from Prismic custom type schemas.\n   */\n  const { actions, reporter, schema, cache } = gatsbyContext\n  const { createTypes } = actions\n\n  const createTypesActivity = reporter.activityTimer(msg('create types'))\n\n  createTypesActivity.start()\n  reporter.verbose(msg('starting to create types'))\n\n  const [imgixImageTypes, imageTypes] = buildPrismicImageTypes({\n    schema,\n    cache,\n    defaultImgixParams: pluginOptions.imageImgixParams,\n    defaultPlaceholderImgixParams: pluginOptions.imagePlaceholderImgixParams,\n  })\n  createTypes(typeDefs)\n  createTypes(imgixImageTypes)\n  createTypes(imageTypes)\n  createTypes(types)\n\n  createTypesActivity.end()\n}\n\nconst buildAll = async (\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  typePaths: TypePath[],\n) => {\n  const { reporter } = gatsbyContext\n\n  const fetchDocumentsActivity = reporter.activityTimer(msg('fetch documents'))\n  const createNodesActivity = reporter.activityTimer(msg('create nodes'))\n\n  /**\n   * Fetch documents from Prismic.\n   */\n  fetchDocumentsActivity.start()\n  reporter.verbose(msg('starting to fetch documents'))\n\n  const documents = await fetchAllDocuments(pluginOptions, gatsbyContext)\n\n  reporter.verbose(msg(`fetched ${documents.length} documents`))\n  fetchDocumentsActivity.end()\n\n  /**\n   * Create nodes for all documents.\n   */\n  createNodesActivity.start()\n  reporter.verbose(msg('starting to create nodes'))\n\n  const env = createEnvironment(pluginOptions, gatsbyContext, typePaths)\n  // TODO: Implement queue like `schemasToTypeDefs` and create nodes here.\n  await documentsToNodes(documents, env)\n\n  createNodesActivity.end()\n}\n\nconst writeTypePaths = (\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  typePaths: TypePath[],\n  program: any,\n) => {\n  /**\n   * Write type paths to public for use in Prismic previews.\n   */\n  const { reporter } = gatsbyContext\n\n  const writeTypePathsActivity = reporter.activityTimer(\n    msg('write out type paths'),\n  )\n\n  writeTypePathsActivity.start()\n\n  reporter.verbose(msg('starting to write out type paths'))\n\n  const schemasDigest = md5(JSON.stringify(pluginOptions.schemas))\n  const typePathsFilename = path.resolve(\n    program.directory,\n    'public',\n    [pluginOptions.typePathsFilenamePrefix, schemasDigest, '.json']\n      .filter((part) => part !== undefined && part !== null)\n      .join(''),\n  )\n\n  reporter.verbose(msg(`writing out type paths to : ${typePathsFilename}`))\n  fs.writeFileSync(typePathsFilename, JSON.stringify(typePaths))\n\n  writeTypePathsActivity.end()\n}\n\nexport const sourceNodes: NonNullable<GatsbyNode['sourceNodes']> = async (\n  gatsbyContext: SourceNodesArgs,\n  pluginOptions: PluginOptions,\n) => {\n  const {\n    reporter,\n    store,\n    webhookBody,\n    getNodes,\n    actions: { touchNode },\n  } = gatsbyContext\n  const { program } = store.getState()\n\n  /**\n   * Validate plugin options. Set default options where necessary. If any\n   * plugin options are invalid, stop immediately.\n   */\n  try {\n    pluginOptions = validatePluginOptions(pluginOptions)\n  } catch (error) {\n    reporter.error(msg('invalid plugin options'))\n    reporter.panic(error)\n  }\n\n  const { typePaths } = schemasToTypeDefs(\n    pluginOptions.schemas,\n    (gatsbyContext as unknown) as CreateSchemaCustomizationArgs,\n  )\n\n  if (!webhookBody || JSON.stringify(webhookBody) === '{}') {\n    /** Initial build or rebuild everything */\n    await buildAll(pluginOptions, gatsbyContext, typePaths)\n    writeTypePaths(pluginOptions, gatsbyContext, typePaths, program)\n  } else if (\n    isPrismicWebhook(webhookBody) &&\n    validateSecret(pluginOptions, webhookBody)\n  ) {\n    /** Respond to the webhook here */\n\n    // touch nodes to prevent garbage collection\n    getNodes().forEach((node) => touchNode({ nodeId: node.id }))\n\n    const prismicWebhook = webhookBody as PrismicWebhook\n    await handleWebhook(pluginOptions, gatsbyContext, typePaths, prismicWebhook)\n  } else {\n    /**\n     * Webhook destined for another plugin,\n     * touch nodes to prevent garbage collection\n     */\n    getNodes().forEach((node) => touchNode({ nodeId: node.id }))\n  }\n}\n\nexport const onPreExtractQueries: NonNullable<\n  GatsbyNode['onPreExtractQueries']\n> = (gatsbyContext) => {\n  const { store } = gatsbyContext\n  const { program } = store.getState()\n\n  // Add fragments for GatsbyPrismicImage to .cache/fragments.\n  fs.copyFileSync(\n    path.resolve(__dirname, '../fragments.js'),\n    path.resolve(\n      program.directory,\n      '.cache/fragments/gatsby-source-prismic-fragments.js',\n    ),\n  )\n}\n","import { SourceNodesArgs } from 'gatsby'\nimport { WebhookBase, PluginOptions, PrismicWebhook, TypePath } from 'types'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\n\nimport { fetchDocumentsByIds } from './api'\nimport { documentsToNodes } from './documentsToNodes'\nimport { createEnvironment } from './environment.node'\nimport { msg } from './utils'\n\ntype maybeWebhook = WebhookBase | any\n\nexport function validateSecret(\n  pluginOptions: PluginOptions,\n  webhookBody: maybeWebhook,\n): boolean {\n  // if(!pluginOptions.webhookSecret && !webhookBody) return false;\n  if (!pluginOptions.webhookSecret) return true\n  if (pluginOptions.webhookSecret && !webhookBody) return false\n  return pluginOptions.webhookSecret === webhookBody.secret\n}\n\nexport function isPrismicUrl(url: string | undefined): boolean {\n  if (!url) return false\n  const regexp = /^https?:\\/\\/([^.]+)\\.(wroom\\.(?:test|io)|prismic\\.io)\\/api\\/?/\n  return regexp.test(url)\n}\n\nexport function isPrismicWebhook(webhookBody: maybeWebhook): boolean {\n  if (!webhookBody) return false\n\n  if (typeof webhookBody !== 'object') return false\n\n  if (webhookBody.type === 'test-trigger') return false\n\n  return isPrismicUrl(webhookBody.apiUrl)\n}\n\nexport async function handleWebhook(\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  typePaths: TypePath[],\n  webhook: PrismicWebhook,\n) {\n  const { releaseID } = pluginOptions\n  const { reporter } = gatsbyContext\n\n  reporter.info(msg('Processing webhook'))\n\n  // eventually we could handle changes to mask and custom types here :)\n\n  const mainApiDocuments = webhook.documents || []\n\n  const releaseDocuments = [\n    ...(webhook.releases.update || []),\n    ...(webhook.releases.addition || []),\n    ...(webhook.releases.deletion || []),\n  ].reduce((acc, release) => {\n    if (release.id !== releaseID) return acc\n\n    return [...acc, ...(release.documents || [])]\n  }, [] as string[])\n\n  const documentsToCheck: string[] = releaseID\n    ? [...releaseDocuments, ...mainApiDocuments]\n    : mainApiDocuments\n\n  reporter.info(\n    msg(\n      `checking ${documentsToCheck.length} ${\n        documentsToCheck.length > 1 ? 'documents' : 'document'\n      }`,\n    ),\n  )\n\n  const documentsToUpdate: PrismicDocument[] = documentsToCheck.length\n    ? await fetchDocumentsByIds(pluginOptions, gatsbyContext, documentsToCheck)\n    : []\n\n  const documentsToUpdateIds = documentsToUpdate.map((doc) => doc.id)\n\n  const documentsToRemove = documentsToCheck.filter(\n    (id) => documentsToUpdateIds.includes(id) === false,\n  )\n\n  if (documentsToRemove.length) {\n    await handleWebhookDeletions(gatsbyContext, documentsToRemove)\n  }\n\n  if (documentsToUpdate.length) {\n    await handleWebhookUpdates(\n      pluginOptions,\n      gatsbyContext,\n      typePaths,\n      documentsToUpdate,\n    )\n  }\n\n  reporter.info(msg('Processed webhook'))\n}\n\nexport async function handleWebhookUpdates(\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  typePaths: TypePath[],\n  documents: PrismicDocument[],\n) {\n  const { reporter } = gatsbyContext\n\n  reporter.info(\n    msg(\n      `Updating ${documents.length} ${\n        documents.length > 1 ? 'documents' : 'document'\n      }`,\n    ),\n  )\n\n  const env = createEnvironment(pluginOptions, gatsbyContext, typePaths)\n\n  const processedDocuments = await documentsToNodes(documents, env)\n\n  reporter.info(\n    msg(\n      `Updated ${processedDocuments.length} ${\n        processedDocuments.length > 1 ? 'documents' : 'document'\n      } `,\n    ),\n  )\n}\n\nexport async function handleWebhookDeletions(\n  gatsbyContext: SourceNodesArgs,\n  documents: string[],\n) {\n  const { reporter, actions, getNode, createNodeId } = gatsbyContext\n  const { deleteNode } = actions\n\n  reporter.info(\n    msg(\n      `removing ${documents.length} ${\n        documents.length > 1 ? 'documents' : 'document'\n      }`,\n    ),\n  )\n\n  const count = documents\n    .map((id) => createNodeId(id))\n    .map(getNode)\n    .reduce((acc: number, node) => {\n      deleteNode({ node })\n      return acc + 1\n    }, 0)\n\n  reporter.info(msg(`removed ${count} ${count > 1 ? 'documents' : 'document'}`))\n}\n"],"names":["baseSchema","repositoryName","struct","accessToken","releaseID","schemas","linkResolver","htmlSerializer","fetchLinks","lang","typePathsFilenamePrefix","prismicToolbar","imageImgixParams","auto","fit","q","imagePlaceholderImgixParams","w","blur","plugins","PluginOptions","shouldDownloadImage","webhookSecret","msg","pathResolver","schemasDigest","message","mapObjVals","fn","obj","result","key","mapObjValsP","keys","Object","Promise","all","map","isEmptyObj","_","buildSchemaTypeName","apiId","pascalCase","transform","pascalCaseTransformMerge","LinkFieldType","FieldType","GraphQLType","SliceChoiceDisplay","fieldToType","field","path","context","customTypeApiId","enqueueTypeDef","enqueueTypePath","gatsbyContext","sliceZoneId","schema","gatsbySchema","reporter","type","UID","Color","Select","Text","String","Boolean","StructuredText","Number","Float","Date","Timestamp","extensions","dateformat","GeoPoint","Embed","Image","thumbnails","config","_field$config","thumbnail","name","ImageThumbnail","Link","Group","groupTypeName","buildObjectType","fields","subfield","subfieldApiId","infer","Slices","slicesTypeName","sliceChoiceTypes","entries","choices","sliceChoiceApiId","sliceChoice","buildUnionType","types","resolve","parent","_args","info","nodeModel","getNodesByIds","ids","Slice","non-repeat","primaryFields","repeat","itemsFields","sliceFieldTypes","slice_type","slice_label","primaryTypeName","primaryField","primaryFieldApiId","primary","itemTypeName","itemField","itemFieldApiId","items","interfaces","AlternateLanguages","fieldPath","join","warn","JSON","schemaToTypeDefs","values","reduce","acc","tab","fieldApiId","uid","uidField","dataFields","uidFieldType","alternateLanguagesFieldType","dataTypeName","dataField","dataFieldApiId","schemaTypeName","schemaFieldTypes","data","dataRaw","dataString","first_publication_date","href","url","last_publication_date","tags","alternate_languages","prismicId","ID","_previewable","schemasToTypeDefs","typeDefs","typeDef","push","typePaths","AllDocumentTypes","filter","typePath","length","buildScalarType","ImageThumbnails","serialize","fieldTypes","buildImageThumbnailsType","IMAGE_FIELD_KEYS","createClient","nameOrUrl","addr","match","toPrismicUrl","getApi","normalizeField","doc","env","createNodeId","createNode","createContentDigest","normalizeStructuredTextField","normalizeLinkField","normalizeImageField","normalizeSlicesField","stringifiedPath","stringify","def","find","x","test","getTypeForPath","baseObj","pick","thumbsObj","omit","base","thumb","thumbs","normalizeObjs","slice","index","sliceNodeId","id","normalizeObj","normalizedPrimary","normalizedItems","node","undefined","internal","contentDigest","sliceNodeIds","item","link_type","Document","objs","documentsToNodes","docs","pluginOptions","linkResolverForDoc","docNodeId","docUrl","normalizedData","normalizedAlernativeLanguages","documentToNodes","_path","shouldAttemptToCreateRemoteFileNode","fileNodeID","cachedImageDataKey","cache","get","cachedImageData","localFile","touchNode","nodeId","fullQualityUrl","URL","searchParams","delete","createRemoteFileNode","toString","store","fileNode","set","error","Error","actions","value","linkResolverForField","linkedDocId","PrismicDOMLink","document","raw","_apiId","_doc","_env","htmlSerializerForField","html","PrismicDOMRichText","asHtml","text","asText","createEnvironment","input","query","replace","args","createTypes","createTypesActivity","activityTimer","start","verbose","imgixImageTypes","imageTypes","defaultImgixParams","defaultPlaceholderImgixParams","resolveUrl","resolveWidth","dimensions","_obj$dimensions","width","resolveHeight","_obj$dimensions2","height","PrismicImageFixedType","createImgixFixedType","PrismicImageFluidType","createImgixFluidType","description","alt","copyright","createImgixUrlSchemaFieldConfig","fixed","createImgixFixedSchemaFieldConfig","fluid","createImgixFluidSchemaFieldConfig","link","buildPrismicImageTypes","end","createPrismicTypes","program","getState","fs","copyFileSync","__dirname","directory","webhookBody","getNodes","coerced","validatePluginOptions","panic","fetchDocumentsActivity","createNodesActivity","client","queryOptions","ref","refs","r","pagedGet","page","pageSize","documents","response","results","total_results_size","fetchAllDocuments","buildAll","writeTypePathsActivity","md5","typePathsFilename","part","writeFileSync","writeTypePaths","apiUrl","isPrismicWebhook","secret","validateSecret","forEach","webhook","documentsToUpdate","processedDocuments","handleWebhookUpdates","documentsToUpdateIds","documentsToRemove","documentsToCheck","includes","getNode","deleteNode","count","handleWebhookDeletions","mainApiDocuments","releaseDocuments","releases","update","addition","deletion","release","chunks","arr","size","i","a","chunk","getByIDs","responses","flatMap","fetchDocumentsByIds","handleWebhook"],"mappings":"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"}