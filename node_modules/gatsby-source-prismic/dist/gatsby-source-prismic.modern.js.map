{"version":3,"file":"gatsby-source-prismic.modern.js","sources":["../src/validateOptions.ts","../src/utils.ts","../src/constants.ts","../src/api.ts","../src/types.ts","../src/documentsToNodes.ts","../src/environment.browser.ts","../src/usePrismicPreview.ts","../src/mergePrismicPreviewData.ts","../src/usePreviewStore.tsx","../src/withPreview.tsx","../src/withPreviewResolver.tsx","../src/withUnpublishedPreview.tsx"],"sourcesContent":["import * as struct from 'superstruct'\n\nimport { PluginOptions, BrowserPluginOptions } from './types'\n\nconst baseSchema = {\n  repositoryName: struct.string(),\n  accessToken: struct.optional(struct.string()),\n  releaseID: struct.optional(struct.string()),\n  schemas: struct.record(struct.string(), struct.object()),\n  linkResolver: struct.defaulted(struct.func(), () => () => () => {}),\n  htmlSerializer: struct.defaulted(struct.func(), () => () => () => {}),\n  fetchLinks: struct.defaulted(struct.array(struct.string()), []),\n  lang: struct.defaulted(struct.string(), '*'),\n  typePathsFilenamePrefix: struct.defaulted(\n    struct.string(),\n    'prismic-typepaths---',\n  ),\n  prismicToolbar: struct.defaulted(\n    struct.union([struct.boolean(), struct.enums(['legacy'])]),\n    false,\n  ),\n  imageImgixParams: struct.defaulted(\n    struct.record(\n      struct.string(),\n      struct.optional(\n        struct.union([struct.string(), struct.number(), struct.boolean()]),\n      ),\n    ),\n    { auto: 'format,compress', fit: 'max', q: 50 },\n  ),\n  imagePlaceholderImgixParams: struct.defaulted(\n    struct.record(\n      struct.string(),\n      struct.optional(\n        struct.union([struct.string(), struct.number(), struct.boolean()]),\n      ),\n    ),\n    { w: 100, blur: 15, q: 20 },\n  ),\n  plugins: struct.defaulted(struct.empty(struct.array()), []),\n} as const\n\nconst PluginOptions = struct.object({\n  ...baseSchema,\n  shouldDownloadImage: struct.defaulted(\n    struct.optional(struct.func()),\n    () => () => false,\n  ),\n  webhookSecret: struct.optional(struct.string()),\n})\n\nconst BrowserPluginOptions = struct.object({\n  ...baseSchema,\n  pathResolver: struct.optional(struct.func()),\n  schemasDigest: struct.string(),\n})\n\nexport const validatePluginOptions = (pluginOptions: PluginOptions) => {\n  const coerced = struct.coerce(pluginOptions, PluginOptions)\n  struct.assert(coerced, PluginOptions)\n  return (coerced as unknown) as PluginOptions\n}\n\nexport const validateBrowserOptions = (\n  browserOptions: BrowserPluginOptions,\n) => {\n  const coerced = struct.coerce(browserOptions, BrowserPluginOptions)\n  struct.assert(coerced, BrowserPluginOptions)\n  return (coerced as unknown) as BrowserPluginOptions\n}\n","import * as React from 'react'\nimport { pascalCase, pascalCaseTransformMerge } from 'pascal-case'\n\n/**\n * Returns a namespaced string intended for logging.\n *\n * @param message Message to namespace.\n *\n * @returns Namespaced message.\n */\nexport const msg = (message: string) => `gatsby-source-prismic - ${message}`\n\n/**\n * Maps key-value tuples of an object to new key-value tuples to create a new\n * object.\n *\n * @param fn Function that maps a key-value tuple to a new key-value tuple.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped key-values.\n */\nexport const mapObj = <T1, T2>(\n  fn: (entry: [string, T1]) => [string, T2],\n  obj: { [key: string]: T1 },\n): { [key: string]: T2 } => {\n  const entries = Object.entries(obj)\n  const pairs = entries.map((x) => fn(x))\n\n  const result: { [key: string]: T2 } = {}\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [k, v] = pairs[i]\n    result[k] = v\n  }\n\n  return result\n}\n\n/**\n * Maps key-value tuples of an object to new key-value tuples to create a new\n * object. The mapper function can be async.\n *\n * @param fn Function that maps a key-value tuple to a new key-value tuple.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped key-values.\n */\nexport const mapObjP = async <T1, T2>(\n  fn: (entry: [string, T1]) => Promise<[string, T2]>,\n  obj: { [key: string]: T1 },\n): Promise<{ [key: string]: T2 }> => {\n  const entries = Object.entries(obj)\n  const pairs = await Promise.all(entries.map((x) => Promise.resolve(fn(x))))\n\n  const result: { [key: string]: T2 } = {}\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [k, v] = pairs[i]\n    result[k] = v\n  }\n\n  return result\n}\n\n/**\n * Maps values of an object to new values.\n *\n * @param fn Function that maps a value and key to a new value.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped values.\n */\nexport const mapObjVals = <T1, T2>(\n  fn: (val: T1, key: string) => T2,\n  obj: { [key: string]: T1 },\n): { [key: string]: T2 } => {\n  const result: { [key: string]: T2 } = {}\n\n  for (const key in obj) result[key] = fn(obj[key], key)\n\n  return result\n}\n\n/**\n * Maps values of an object to new values.\n *\n * @param fn Function that maps a value and key to a new value.\n * @param obj Object to map to a new object.\n *\n * @returns New object with mapped values.\n */\nexport const mapObjValsP = async <T1, T2>(\n  fn: (val: T1, key: string) => Promise<T2>,\n  obj: { [key: string]: T1 },\n): Promise<{ [key: string]: T2 }> => {\n  const result: { [key: string]: T2 } = {}\n\n  const keys = Object.keys(obj)\n  await Promise.all(\n    keys.map(async (key) => {\n      result[key] = await fn(obj[key], key)\n    }),\n  )\n\n  return result\n}\n\n/**\n * Returns true if the provided object has no keys, false otherwise.\n *\n * @param obj Object to check.\n *\n * @returns `true` if `obj` has no keys, `false` otherwise.\n */\nexport const isEmptyObj = (obj: object) => {\n  for (const _ in obj) return false\n  return true\n}\n\n/**\n * Returns a valid GraphQL type name for a Prismic schema.\n *\n * @param apiId API ID of the schema.\n *\n * @returns Type name for the schema.\n */\nexport const buildSchemaTypeName = (apiId: string) =>\n  pascalCase(`Prismic ${apiId}`, { transform: pascalCaseTransformMerge })\n\n/**\n * Determines whether the current context is the browser.\n *\n * @returns `true` if the current context is the browser, `false` otherwise.\n */\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const getComponentDisplayName = (\n  WrappedComponent: React.ComponentType<any>,\n) => WrappedComponent.displayName || WrappedComponent.name || 'Component'\n\n/**\n * Separates an array in to an array of arrays\n * @param arr The array to chunk\n * @param size the maximum size for each of the resulting arrays\n */\nexport function chunk<T>(arr: T[], size: number): Array<T[]> {\n  const chunks = []\n\n  let i = 0\n\n  while (i < arr.length) {\n    const a = arr.slice(i, (i += size))\n    chunks.push(a)\n  }\n\n  return chunks\n}\n","export const BROWSER_STORE_KEY = '__GATSBY_SOURCE_PRISMIC__'\n\nexport const IMAGE_FIELD_KEYS = [\n  'alt',\n  'copyright',\n  'dimensions',\n  'url',\n] as const\n\nexport const API_PAGE_SIZE = 100\n\nexport const UUID_NAMESPACE = `638f7a53-c567-4eca-8fc1-b23efb1cfb2b`\n\nexport const PLACEHOLDER_NODE_TYPE_SUFFIX = '__PLACEHOLDER'\n","import { getApi } from 'prismic-javascript'\n\nimport { msg, chunk } from './utils'\nimport { API_PAGE_SIZE } from './constants'\n\nimport { SourceNodesArgs, Reporter } from 'gatsby'\nimport PrismicResolvedApi, {\n  QueryOptions,\n} from 'prismic-javascript/d.ts/ResolvedApi'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport { PluginOptions } from './types'\nimport ApiSearchResponse from 'prismic-javascript/d.ts/ApiSearchResponse'\n\nexport function toPrismicUrl(nameOrUrl: string) {\n  const urlRegex = /^https?:\\/\\/([^.]+)\\.(wroom\\.(?:test|io)|prismic\\.io)/\n  const addr = nameOrUrl.match(urlRegex)\n\n  return addr ? addr[0] + '/api/v2' : `https://${nameOrUrl}.prismic.io/api/v2`\n}\n\nexport const createClient = async (\n  repositoryName: string,\n  accessToken?: string,\n) => {\n  const url = toPrismicUrl(repositoryName)\n  return await getApi(url, { accessToken })\n}\n\nconst pagedGet = async (\n  client: PrismicResolvedApi,\n  queryOptions: QueryOptions,\n  page: number,\n  pageSize: number,\n  documents: PrismicDocument[],\n  reporter: Reporter,\n): Promise<PrismicDocument[]> => {\n  reporter.verbose(msg(`fetching documents page ${page}`))\n\n  const response = await client.query([], { ...queryOptions, page, pageSize })\n\n  for (const doc of response.results) documents.push(doc)\n\n  if (page * pageSize < response.total_results_size)\n    return await pagedGet(\n      client,\n      queryOptions,\n      page + 1,\n      pageSize,\n      documents,\n      reporter,\n    )\n\n  return documents\n}\n\nexport const fetchAllDocuments = async (\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n) => {\n  const {\n    repositoryName,\n    releaseID,\n    accessToken,\n    fetchLinks,\n    lang,\n  } = pluginOptions\n  const { reporter } = gatsbyContext\n\n  const client = await createClient(repositoryName, accessToken)\n\n  const queryOptions: QueryOptions = {}\n  if (releaseID) {\n    const ref = client.refs.find((r) => r.id === releaseID)\n    if (ref) {\n      queryOptions.ref = ref.ref\n    } else {\n      reporter.warn(\n        msg(\n          `A release with ID \"${releaseID}\" was not found. Defaulting to the master ref instead.`,\n        ),\n      )\n    }\n  }\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n  if (lang) queryOptions.lang = lang\n\n  return await pagedGet(client, queryOptions, 1, API_PAGE_SIZE, [], reporter)\n}\n\nexport async function fetchDocumentsByIds(\n  pluginOptions: PluginOptions,\n  gatsbyContext: SourceNodesArgs,\n  documents: string[],\n): Promise<PrismicDocument[]> {\n  const {\n    repositoryName,\n    releaseID,\n    accessToken,\n    fetchLinks,\n    lang,\n  } = pluginOptions\n\n  const { reporter } = gatsbyContext\n\n  const client = await createClient(repositoryName, accessToken)\n\n  const queryOptions: QueryOptions = {}\n\n  if (releaseID) {\n    const ref = client.refs.find((r) => r.id === releaseID)\n    if (ref) {\n      queryOptions.ref = ref.ref\n    } else {\n      reporter.warn(\n        msg(\n          `A release with ID \"${releaseID}\" was not found. Defaulting to the master ref instead.`,\n        ),\n      )\n    }\n  }\n\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n\n  if (lang) queryOptions.lang = lang\n\n  const chunks = chunk(documents, 100).map((docs) =>\n    client.getByIDs(docs, queryOptions),\n  )\n\n  const responses: ApiSearchResponse[] = await Promise.all(chunks)\n\n  return responses.flatMap((doc) => doc.results)\n}\n","import {\n  PluginOptions as GatsbyPluginOptions,\n  SourceNodesArgs,\n  NodeInput,\n  Node,\n} from 'gatsby'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport * as PrismicDOM from 'prismic-dom'\nimport { ImgixUrlParams } from 'gatsby-plugin-imgix'\n\nexport type NodeID = string\n\nexport interface NodeTree {\n  [key: string]: Node\n}\n\nexport interface DocumentNodeInput extends NodeInput {\n  prismicId: PrismicDocument['id']\n  data: { [key: string]: NormalizedField }\n  dataString: string\n  dataRaw: PrismicDocument['data']\n  alternate_languages: NormalizedAlternateLanguagesField\n  url?: string\n}\n\nexport interface SliceNodeInput extends NodeInput {\n  slice_type: string\n  slice_label?: string\n  primary: { [key: string]: NormalizedField }\n  items: { [key: string]: NormalizedField }[]\n}\n\nexport interface DocumentsToNodesEnvironment {\n  createNode: (node: NodeInput) => void\n  createNodeId: (input: string) => string\n  createContentDigest: (input: string | object) => string\n  normalizeImageField: ImageFieldNormalizer\n  normalizeLinkField: LinkFieldNormalizer\n  normalizeSlicesField: SlicesFieldNormalizer\n  normalizeStructuredTextField: StructuredTextFieldNormalizer\n  typePaths: TypePath[]\n  pluginOptions: PluginOptions\n  context:\n    | DocumentsToNodesEnvironmentNodeContext\n    | DocumentsToNodesEnvironmentBrowserContext\n}\n\nexport interface DocumentsToNodesEnvironmentNodeContext {\n  gatsbyContext: SourceNodesArgs\n}\n\nexport interface DocumentsToNodesEnvironmentBrowserContext {\n  hasNodeById: (id: string) => boolean\n  getNodeById: <T>(id: string) => T & Node\n}\n\nexport interface TypePath {\n  path: string[]\n  type: GraphQLType | string\n}\n\nexport type FieldNormalizer<T, N> = (\n  apiId: string,\n  field: T,\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => N | Promise<N>\n\nexport type ImageFieldNormalizer = FieldNormalizer<\n  ImageField,\n  NormalizedImageField\n>\n\nexport type LinkFieldNormalizer = FieldNormalizer<\n  LinkField,\n  NormalizedLinkField\n>\n\nexport type SlicesFieldNormalizer = FieldNormalizer<\n  SliceIDsField,\n  NormalizedSlicesField\n>\n\nexport type StructuredTextFieldNormalizer = FieldNormalizer<\n  StructuredTextField,\n  NormalizedStructuredTextField\n>\n\nexport type Field =\n  | StructuredTextField\n  | ImageField\n  | SlicesField\n  | GroupField\n  | LinkField\n  | AlternateLanguagesField\n  | string\n  | number\n  | boolean\n  | null\n\nexport type NormalizedField =\n  | NormalizedStructuredTextField\n  | NormalizedImageField\n  | NormalizedSlicesField\n  | NormalizedGroupField\n  | NormalizedLinkField\n  | NormalizedAlternateLanguagesField\n  | Field\n\nexport type StructuredTextField = {\n  type: string\n  text: string\n  spans: { [key: string]: unknown }\n}[]\n\nexport interface NormalizedStructuredTextField {\n  html: string\n  text: string\n  raw: StructuredTextField\n}\n\nexport type SlicesField = Slice[]\n\ninterface Slice {\n  slice_type: string\n  slice_label: string | null\n  items: { [key: string]: Field }[]\n  primary: { [key: string]: Field }\n}\n\nexport type SliceIDsField = NodeID[]\n\nexport type NormalizedSlicesField = NodeID[]\n\nexport enum LinkFieldType {\n  Any = 'Any',\n  Document = 'Document',\n  Media = 'Media',\n  Web = 'Web',\n}\n\nexport interface LinkField {\n  link_type: LinkFieldType\n  isBroken: boolean\n  url?: string\n  target?: string\n  size?: number\n  id?: string\n  type?: string\n  tags?: string[]\n  lang?: string\n  slug?: string\n  uid?: string\n}\n\nexport interface NormalizedLinkField extends LinkField {\n  url: string\n  document?: NodeID\n  raw: LinkField\n}\n\nexport interface ImageField {\n  alt?: string\n  copyright?: string\n  dimensions?: { width: number; height: number }\n  url?: string\n  // This should be ImageThumbnailField, but TypeScript does not let us\n  // type unknown field types separatly from known without widening the type.\n  [key: string]: unknown\n}\n\nexport interface NormalizedImageField extends ImageField {\n  thumbnails?: { [key: string]: NormalizedImageField }\n  fixed?: FixedObject\n  fluid?: FluidObject\n  localFile?: NodeID\n}\n\nexport type AlternateLanguagesField = LinkField[]\n\nexport type NormalizedAlternateLanguagesField = AlternateLanguagesField\n\nexport type GroupField = { [key: string]: Field }[]\n\nexport type NormalizedGroupField = { [key: string]: NormalizedField }[]\n\nexport enum FieldType {\n  Boolean = 'Boolean',\n  Color = 'Color',\n  Date = 'Date',\n  Embed = 'Embed',\n  GeoPoint = 'GeoPoint',\n  Group = 'Group',\n  Image = 'Image',\n  Link = 'Link',\n  Number = 'Number',\n  Select = 'Select',\n  Slice = 'Slice',\n  Slices = 'Slices',\n  StructuredText = 'StructuredText',\n  Text = 'Text',\n  Timestamp = 'Timestamp',\n  UID = 'UID',\n  // Internal plugin-specific field not defined in the in Prismic schema.\n  AlternateLanguages = 'AlternateLanguages',\n}\n\nexport enum GraphQLType {\n  ID = 'ID',\n  Boolean = 'Boolean',\n  String = 'String',\n  Float = 'Float',\n  Date = 'Date',\n  JSON = 'JSON',\n  Link = 'PrismicLinkType',\n  Image = 'PrismicImageType',\n  ImageThumbnail = 'PrismicImageThumbnailType',\n  ImageThumbnails = 'PrismicImageThumbnailsType',\n  Embed = 'PrismicEmbedType',\n  GeoPoint = 'PrismicGeoPointType',\n  StructuredText = 'PrismicStructuredTextType',\n  AllDocumentTypes = 'PrismicAllDocumentTypes',\n  Group = 'Group',\n  Slices = 'Slices',\n  AlternateLanguages = 'AlternateLanguages',\n}\n\nexport interface GraphQLTypeObj {\n  type: GraphQLType | string\n  extensions?: { [key: string]: any }\n  resolve?: Function\n}\n\ninterface BaseFieldConfigSchema {\n  label?: string\n  labels?: { [key: string]: string[] }\n  placeholder?: string\n  [key: string]: unknown\n}\n\nexport interface BaseFieldSchema {\n  type: FieldType\n  config: BaseFieldConfigSchema\n}\n\nexport interface ImageFieldSchema extends BaseFieldSchema {\n  type: FieldType.Image\n  config: ImageFieldConfigSchema\n}\n\ninterface ThumbnailSchema {\n  name: string\n  width?: string\n  height?: string\n}\n\ninterface ImageFieldConfigSchema extends BaseFieldConfigSchema {\n  constraint?: { width?: number; height?: number }\n  thumbnails?: ThumbnailSchema[]\n}\n\nexport interface SlicesFieldSchema extends BaseFieldSchema {\n  type: FieldType.Slices\n  fieldset: string\n  config: SlicesFieldConfigSchema\n}\n\ninterface SlicesFieldConfigSchema extends BaseFieldConfigSchema {\n  choices: SliceChoicesSchema\n}\n\nexport interface SliceChoicesSchema {\n  [sliceId: string]: SliceFieldSchema\n}\n\nenum SliceChoiceDisplay {\n  List = 'list',\n  Grid = 'grid',\n}\n\nexport interface SliceFieldSchema extends BaseFieldSchema {\n  type: FieldType.Slice\n  fieldset: string\n  description: string\n  icon: string\n  display: SliceChoiceDisplay\n  repeat?: FieldsSchema\n  'non-repeat'?: FieldsSchema\n}\n\nexport interface GroupFieldSchema extends BaseFieldSchema {\n  type: FieldType.Group\n  config: GroupFieldConfigSchema\n}\n\ninterface GroupFieldConfigSchema extends BaseFieldConfigSchema {\n  fields: FieldsSchema\n}\n\nexport type FieldSchema =\n  | BaseFieldSchema\n  | ImageFieldSchema\n  | SlicesFieldSchema\n  | GroupFieldSchema\n  | SliceFieldSchema\n\nexport interface FieldsSchema {\n  [fieldId: string]: FieldSchema\n}\n\nexport interface Schema {\n  [tabName: string]: {\n    [fieldId: string]: FieldSchema\n  }\n}\n\nexport interface Schemas {\n  [schemaId: string]: Schema\n}\n\nexport type LinkResolver = (doc: object) => string\nexport type PluginLinkResolver = (input: {\n  key?: string\n  value?: unknown\n  node: PrismicDocument\n}) => LinkResolver\n\nexport type HTMLSerializer = typeof PrismicDOM.HTMLSerializer\nexport type PluginHTMLSerializer = (input: {\n  key: string\n  value: unknown\n  node: PrismicDocument\n}) => HTMLSerializer\n\ntype ShouldDownloadImage = (input: {\n  key: string\n  value: unknown\n  node: PrismicDocument\n}) => boolean | Promise<boolean>\n\nexport type BrowserPluginOptions = GatsbyPluginOptions &\n  Pick<\n    PluginOptions,\n    | 'repositoryName'\n    | 'accessToken'\n    | 'fetchLinks'\n    | 'schemas'\n    | 'lang'\n    | 'typePathsFilenamePrefix'\n    | 'prismicToolbar'\n  >\n\nexport interface PluginOptions extends GatsbyPluginOptions {\n  repositoryName: string\n  releaseID?: string\n  accessToken?: string\n  linkResolver?: PluginLinkResolver\n  htmlSerializer?: PluginHTMLSerializer\n  fetchLinks?: string[]\n  schemas: Schemas\n  lang?: string\n  shouldDownloadImage?: ShouldDownloadImage\n  shouldNormalizeImage?: ShouldDownloadImage\n  typePathsFilenamePrefix?: string\n  prismicToolbar?: boolean | 'legacy'\n  imageImgixParams?: ImgixUrlParams\n  imagePlaceholderImgixParams?: ImgixUrlParams\n  webhookSecret?: string\n}\n\nexport interface WebhookBase {\n  type: 'api-update' | 'test-trigger'\n  domain: string\n  apiUrl: string\n  secret: string | null\n}\n\nexport interface TestWebhook extends WebhookBase {\n  type: 'test-trigger'\n}\n\ninterface Operations<T> {\n  update?: T[]\n  addition?: T[]\n  deletion?: T[]\n}\n\nexport interface PrismicWebhook extends WebhookBase {\n  type: 'api-update'\n  masterRef?: string\n  releases: Operations<WebhookRelease>\n  masks: Operations<WebhookMask>\n  tags: Operations<WebhookTag>\n  documents: string[]\n  experiments?: Operations<WebhookExperiment>\n}\n\nexport interface WebhookRelease {\n  id: string\n  ref: string\n  label: string\n  documents: string[]\n}\n\nexport interface WebhookMask {\n  id: string\n  label: string\n}\n\nexport interface WebhookTag {\n  id: string\n}\n\n// Legacy fields\ninterface WebhookExperimentVariation {\n  id: string\n  ref: string\n  label: string\n}\ninterface WebhookExperiment {\n  id: string\n  name: string\n  variations: WebhookExperimentVariation[]\n}\n","import pick from 'lodash.pick'\nimport omit from 'lodash.omit'\n\nimport { mapObjValsP, buildSchemaTypeName } from './utils'\nimport { IMAGE_FIELD_KEYS } from './constants'\n\nimport { Document as PrismicDocument } from 'prismic-javascript/d.ts/documents'\nimport {\n  DocumentsToNodesEnvironment,\n  TypePath,\n  Field,\n  AlternateLanguagesField,\n  GroupField,\n  ImageField,\n  LinkField,\n  SlicesField,\n  StructuredTextField,\n  NormalizedField,\n  NormalizedAlternateLanguagesField,\n  LinkFieldType,\n  GraphQLType,\n  LinkResolver,\n  DocumentNodeInput,\n  SliceNodeInput,\n} from './types'\n\nconst getTypeForPath = (\n  path: TypePath['path'],\n  typePaths: TypePath[],\n): GraphQLType | string | undefined => {\n  const stringifiedPath = JSON.stringify(path)\n  const def = typePaths.find((x) => JSON.stringify(x.path) === stringifiedPath)\n\n  if (!def) return\n  if (/^\\[.*GroupType\\]$/.test(def.type)) return GraphQLType.Group\n  if (/^\\[.*SlicesType\\]$/.test(def.type)) return GraphQLType.Slices\n\n  return def.type\n}\n\nconst normalizeField = async (\n  apiId: string,\n  field: Field,\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n): Promise<NormalizedField> => {\n  const {\n    createNodeId,\n    createNode,\n    createContentDigest,\n    typePaths,\n    normalizeStructuredTextField,\n    normalizeLinkField,\n    normalizeImageField,\n    normalizeSlicesField,\n  } = env\n\n  const type = getTypeForPath([...path, apiId], typePaths)\n\n  switch (type) {\n    case GraphQLType.Image: {\n      const baseObj: ImageField = pick(field as ImageField, IMAGE_FIELD_KEYS)\n      const thumbsObj = omit(field as ImageField, IMAGE_FIELD_KEYS) as {\n        [key: string]: ImageField\n      }\n\n      const base = await normalizeImageField(apiId, baseObj, path, doc, env)\n      const thumbs = await mapObjValsP(\n        async (thumb) =>\n          await normalizeImageField(apiId, thumb, path, doc, env),\n        thumbsObj,\n      )\n\n      return { ...base, thumbnails: thumbs }\n    }\n\n    case GraphQLType.StructuredText: {\n      return await normalizeStructuredTextField(\n        apiId,\n        field as StructuredTextField,\n        path,\n        doc,\n        env,\n      )\n    }\n\n    case GraphQLType.Link: {\n      return await normalizeLinkField(apiId, field as LinkField, path, doc, env)\n    }\n\n    case GraphQLType.Group: {\n      return await normalizeObjs(\n        field as GroupField,\n        [...path, apiId],\n        doc,\n        env,\n      )\n    }\n\n    case GraphQLType.Slices: {\n      const sliceNodeIds = await Promise.all(\n        (field as SlicesField).map(async (slice, index) => {\n          const sliceNodeId = createNodeId(\n            `${doc.type} ${doc.id} ${apiId} ${index}`,\n          )\n\n          const normalizedPrimary = await normalizeObj(\n            slice.primary,\n            [...path, apiId, slice.slice_type, 'primary'],\n            doc,\n            env,\n          )\n\n          const normalizedItems = await normalizeObjs(\n            slice.items,\n            [...path, apiId, slice.slice_type, 'items'],\n            doc,\n            env,\n          )\n\n          const node: SliceNodeInput = {\n            id: sliceNodeId,\n            slice_type: slice.slice_type,\n            slice_label: slice.slice_label ?? undefined,\n            primary: normalizedPrimary,\n            items: normalizedItems,\n            internal: {\n              type: buildSchemaTypeName(\n                `${doc.type} ${apiId} ${slice.slice_type}`,\n              ),\n              contentDigest: createContentDigest(slice),\n            },\n          }\n\n          createNode(node)\n\n          return node.id\n        }),\n      )\n\n      return await normalizeSlicesField(\n        apiId,\n        sliceNodeIds,\n        [...path, apiId],\n        doc,\n        env,\n      )\n    }\n\n    // This field type is not an actual Prismic type and was assigned manually\n    // in `schemasToTypeDefs.ts`.\n    case GraphQLType.AlternateLanguages: {\n      // Treat the array of alternate language documents as a list of link\n      // fields. We need to force the link type to a Document since it is not\n      // there by default.\n      return await Promise.all(\n        (field as AlternateLanguagesField).map(\n          async (item) =>\n            await normalizeLinkField(\n              apiId,\n              {\n                ...item,\n                link_type: LinkFieldType.Document,\n              },\n              path,\n              doc,\n              env,\n            ),\n        ),\n      )\n    }\n\n    default: {\n      return field\n    }\n  }\n}\n\nconst normalizeObj = (\n  obj: { [key: string]: Field } = {},\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n): Promise<{ [key: string]: NormalizedField }> =>\n  mapObjValsP(\n    (field, fieldApiId) => normalizeField(fieldApiId, field, path, doc, env),\n    obj,\n  )\n\nconst normalizeObjs = (\n  objs: { [key: string]: Field }[] = [],\n  path: TypePath['path'],\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => Promise.all(objs.map((obj) => normalizeObj(obj, path, doc, env)))\n\nexport const documentToNodes = async (\n  doc: PrismicDocument,\n  env: DocumentsToNodesEnvironment,\n) => {\n  const { createNode, createContentDigest, createNodeId, pluginOptions } = env\n  const { linkResolver } = pluginOptions\n\n  let linkResolverForDoc: LinkResolver | undefined = undefined\n  if (linkResolver) linkResolverForDoc = linkResolver({ node: doc })\n\n  const docNodeId = createNodeId(doc.id)\n  const docUrl = linkResolverForDoc ? linkResolverForDoc(doc) : undefined\n\n  const normalizedData = await normalizeObj(\n    doc.data,\n    [doc.type, 'data'],\n    doc,\n    env,\n  )\n  const normalizedAlernativeLanguages = (await normalizeField(\n    'alternate_languages',\n    (doc.alternate_languages as unknown) as AlternateLanguagesField,\n    [doc.type],\n    doc,\n    env,\n  )) as NormalizedAlternateLanguagesField\n\n  const node: DocumentNodeInput = {\n    ...doc,\n    id: docNodeId,\n    prismicId: doc.id,\n    data: normalizedData,\n    dataString: JSON.stringify(doc.data),\n    dataRaw: doc.data,\n    alternate_languages: normalizedAlernativeLanguages,\n    url: docUrl,\n    internal: {\n      type: buildSchemaTypeName(doc.type),\n      contentDigest: createContentDigest(doc),\n    },\n    _previewable: doc.id,\n  }\n\n  createNode(node)\n\n  return node.id\n}\n\nexport const documentsToNodes = async (\n  docs: PrismicDocument[],\n  env: DocumentsToNodesEnvironment,\n) => await Promise.all(docs.map((doc) => documentToNodes(doc, env)))\n","import {\n  Link as PrismicDOMLink,\n  RichText as PrismicDOMRichText,\n} from 'prismic-dom'\nimport { buildImgixFixed, buildImgixFluid } from 'gatsby-plugin-imgix'\nimport { v5 as uuidv5 } from 'uuid'\nimport md5 from 'md5'\n\nimport { createClient } from './api'\nimport { documentToNodes } from './documentsToNodes'\nimport { buildSchemaTypeName } from './utils'\nimport { UUID_NAMESPACE, PLACEHOLDER_NODE_TYPE_SUFFIX } from './constants'\n\nimport { NodeInput } from 'gatsby'\nimport { QueryOptions } from 'prismic-javascript/d.ts/ResolvedApi'\nimport {\n  BrowserPluginOptions,\n  DocumentsToNodesEnvironment,\n  DocumentsToNodesEnvironmentBrowserContext,\n  HTMLSerializer,\n  ImageFieldNormalizer,\n  LinkField,\n  LinkFieldNormalizer,\n  LinkFieldType,\n  LinkResolver,\n  NormalizedLinkField,\n  SlicesFieldNormalizer,\n  StructuredTextFieldNormalizer,\n  TypePath,\n  NodeID,\n} from './types'\n\ninterface UnbrokenDocumentLinkField extends LinkField {\n  link_type: LinkFieldType.Document\n  id: string\n  isBroken: false\n}\n\nconst loadLinkFieldDocument = async (\n  field: UnbrokenDocumentLinkField,\n  env: DocumentsToNodesEnvironment,\n) => {\n  const {\n    createNode,\n    createNodeId,\n    createContentDigest,\n    pluginOptions,\n    context,\n  } = env\n  if (field.link_type !== LinkFieldType.Document || !field.id || field.isBroken)\n    return\n\n  const { hasNodeById } = context as DocumentsToNodesEnvironmentBrowserContext\n  const { repositoryName, accessToken, fetchLinks } = pluginOptions\n\n  const linkedDocId = createNodeId(field.id)\n\n  // Skip the fetch process if the node already exists in the store.\n  if (hasNodeById(linkedDocId)) return\n\n  // Create a placeholder node in the store to prevent infinite recursion. This\n  // placeholder will be replaced with the actual node during the\n  // `documentToNodes` call.\n  createNode({\n    id: linkedDocId,\n    internal: {\n      type: buildSchemaTypeName(field.type!) + PLACEHOLDER_NODE_TYPE_SUFFIX,\n      contentDigest: createContentDigest(linkedDocId),\n    },\n  })\n\n  const queryOptions: QueryOptions = {}\n  if (fetchLinks) queryOptions.fetchLinks = fetchLinks\n\n  // Query Prismic's API for the document.\n  const client = await createClient(repositoryName, accessToken)\n  const doc = await client.getByID(field.id, queryOptions)\n\n  await documentToNodes(doc, env)\n}\n\nconst normalizeImageField: ImageFieldNormalizer = async (\n  _apiId,\n  field,\n  _path,\n  _doc,\n  env,\n) => {\n  const { pluginOptions } = env\n\n  const url = field.url\n  if (!url) return field\n\n  const fixed = buildImgixFixed({\n    url,\n    sourceWidth: field.dimensions!.width,\n    sourceHeight: field.dimensions!.height,\n    args: {\n      imgixParams: pluginOptions.imageImgixParams,\n      placeholderImgixParams: pluginOptions.imagePlaceholderImgixParams,\n    },\n  })\n\n  const fluid = buildImgixFluid({\n    url,\n    sourceWidth: field.dimensions!.width,\n    sourceHeight: field.dimensions!.height,\n    args: {\n      imgixParams: pluginOptions.imageImgixParams,\n      placeholderImgixParams: pluginOptions.imagePlaceholderImgixParams,\n    },\n  })\n\n  return { ...field, fixed, fluid }\n}\n\n// TODO: Abstract proxy handler for any `getNodeById` needs (e.g. Slices).\nconst normalizeLinkField: LinkFieldNormalizer = async (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { createNodeId, pluginOptions, context } = env\n  const { getNodeById } = context as DocumentsToNodesEnvironmentBrowserContext\n  const { linkResolver } = pluginOptions\n\n  let linkResolverForField: LinkResolver | undefined = undefined\n  if (linkResolver)\n    linkResolverForField = linkResolver({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  let linkedDocId: NodeID | undefined = undefined\n  if (field && field.link_type === LinkFieldType.Document && field.id)\n    linkedDocId = createNodeId(field.id)\n\n  if (\n    field &&\n    field.link_type === LinkFieldType.Document &&\n    field.id &&\n    !field.isBroken\n  )\n    await loadLinkFieldDocument(field as UnbrokenDocumentLinkField, env)\n\n  return new Proxy(\n    {\n      ...field,\n      url: PrismicDOMLink.url(field, linkResolverForField),\n      document: linkedDocId,\n      raw: field,\n    },\n    {\n      get: (obj, prop: keyof NormalizedLinkField) => {\n        if (prop === 'document') {\n          if (\n            field &&\n            field.link_type === LinkFieldType.Document &&\n            !field.isBroken &&\n            linkedDocId\n          )\n            return getNodeById(linkedDocId)\n\n          return null\n        }\n\n        return obj[prop]\n      },\n    },\n  )\n}\n\nconst normalizeSlicesField: SlicesFieldNormalizer = (\n  _apiId,\n  field,\n  _path,\n  _doc,\n  env,\n) => {\n  const { context } = env\n  const {\n    hasNodeById,\n    getNodeById,\n  } = context as DocumentsToNodesEnvironmentBrowserContext\n\n  return new Proxy(field, {\n    get: (obj, prop: number) => {\n      const id = obj[prop]\n\n      if (hasNodeById(id)) {\n        const node = getNodeById(id)\n        return { ...node, __typename: node.internal.type }\n      }\n\n      return id\n    },\n  })\n}\n\nconst normalizeStructuredTextField: StructuredTextFieldNormalizer = async (\n  apiId,\n  field,\n  _path,\n  doc,\n  env,\n) => {\n  const { pluginOptions } = env\n  const { linkResolver, htmlSerializer } = pluginOptions\n\n  let linkResolverForField: LinkResolver | undefined = undefined\n  if (linkResolver)\n    linkResolverForField = linkResolver({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  let htmlSerializerForField: HTMLSerializer | undefined = undefined\n  if (htmlSerializer)\n    htmlSerializerForField = htmlSerializer({\n      key: apiId,\n      value: field,\n      node: doc,\n    })\n\n  return {\n    html: PrismicDOMRichText.asHtml(\n      field,\n      linkResolverForField,\n      htmlSerializerForField,\n    ),\n    text: PrismicDOMRichText.asText(field),\n    raw: field,\n  }\n}\n\nexport const createEnvironment = (\n  pluginOptions: BrowserPluginOptions,\n  typePaths: TypePath[],\n): DocumentsToNodesEnvironment => {\n  const nodeStore = new Map()\n\n  const createNode = (node: NodeInput) => void nodeStore.set(node.id, node)\n  const createNodeId = (input: string) => uuidv5(input, UUID_NAMESPACE)\n  const createContentDigest = (input: unknown) => md5(JSON.stringify(input))\n  const hasNodeById = (id: string) => nodeStore.has(id)\n  const getNodeById = (id: string) => nodeStore.get(id)\n\n  return {\n    createNode,\n    createNodeId,\n    createContentDigest,\n    normalizeImageField,\n    normalizeLinkField,\n    normalizeSlicesField,\n    normalizeStructuredTextField,\n    typePaths,\n    pluginOptions,\n    context: { hasNodeById, getNodeById },\n  }\n}\n","import { useReducer, useEffect, useCallback, useMemo } from 'react'\nimport { set as setCookie } from 'es-cookie'\nimport { previewCookie } from 'prismic-javascript'\nimport { camelCase } from 'camel-case'\n\nimport { validateBrowserOptions } from './validateOptions'\nimport { createClient } from './api'\nimport { createEnvironment } from './environment.browser'\nimport { documentToNodes } from './documentsToNodes'\nimport { isBrowser } from './utils'\nimport { BROWSER_STORE_KEY } from './constants'\n\nimport { Node } from 'gatsby'\nimport { QueryOptions } from 'prismic-javascript/d.ts/ResolvedApi'\nimport {\n  PluginOptions,\n  DocumentsToNodesEnvironmentBrowserContext,\n  BrowserPluginOptions,\n} from './types'\n\nexport type UsePrismicPreviewOptions = Pick<\n  PluginOptions,\n  | 'repositoryName'\n  | 'accessToken'\n  | 'linkResolver'\n  | 'htmlSerializer'\n  | 'fetchLinks'\n  | 'lang'\n  | 'typePathsFilenamePrefix'\n> & {\n  pathResolver?: PluginOptions['linkResolver']\n  schemasDigest?: string\n}\n\nenum ActionType {\n  IS_NOT_PREVIEW = 'IS_NOT_PREVIEW',\n  IS_PREVIEW = 'IS_PREVIEW',\n  DOCUMENT_LOADED = 'DOCUMENT_LOADED',\n  RESET = 'RESET',\n}\n\ninterface Action {\n  type: ActionType\n  payload?: {\n    rootNode: Node\n    path?: string\n  }\n}\n\ninterface State {\n  isPreview?: boolean\n  isLoading: boolean\n  previewData?: { [key: string]: Node }\n  path?: string\n}\n\nconst initialState: State = {\n  isPreview: undefined,\n  isLoading: false,\n  previewData: undefined,\n  path: undefined,\n}\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case ActionType.IS_NOT_PREVIEW: {\n      return { ...state, isPreview: false, isLoading: false }\n    }\n\n    case ActionType.IS_PREVIEW: {\n      return { ...state, isPreview: true, isLoading: true }\n    }\n\n    case ActionType.DOCUMENT_LOADED: {\n      if (!action.payload)\n        return { ...state, isPreview: false, isLoading: false }\n\n      const { rootNode, path } = action.payload\n      const type = camelCase(rootNode.internal.type)\n      const previewData = { [type]: rootNode }\n\n      return { ...state, previewData, path, isPreview: true, isLoading: false }\n    }\n\n    case ActionType.RESET: {\n      return initialState\n    }\n\n    default:\n      throw new Error('Invalid error')\n  }\n}\n\nexport const usePrismicPreview = (options: UsePrismicPreviewOptions) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  // @ts-expect-error\n  const hydratedOptions: UsePrismicPreviewOptions & {\n    plugins: []\n    schemas: {}\n    lang: string\n    typePathsFilenamePrefix: string\n    schemasDigest: string\n  } = useMemo(() => {\n    if (!isBrowser) return options\n\n    const context = window[BROWSER_STORE_KEY][options.repositoryName]\n\n    if (!context)\n      throw new Error(\n        `Could not find plugin context for repository: \"${options.repositoryName}\". Check that a gatsby-source-plugin instance exists for that repository. `,\n      )\n\n    return validateBrowserOptions({\n      ...context.pluginOptions,\n      schemasDigest: context.schemasDigest,\n      // Need to include an empty object because environment.browser.ts is\n      // expecting it. We do not include the actual schemas in the browser.\n      schemas: {},\n      ...options,\n    })\n  }, [options])\n\n  const { token, documentId } = useMemo(() => {\n    if (!isBrowser) return {}\n\n    const params = new URLSearchParams(window.location.search)\n\n    return {\n      token: params.get('token') ?? undefined,\n      documentId: params.get('documentId') ?? undefined,\n    }\n  }, [isBrowser ? window.location.search : undefined])\n\n  /**\n   * Set the preview status as soon as possible.\n   */\n  useEffect(() => {\n    const isPreview = Boolean(token && documentId)\n\n    dispatch({\n      type: isPreview ? ActionType.IS_PREVIEW : ActionType.IS_NOT_PREVIEW,\n    })\n  }, [token, documentId])\n\n  const asyncEffect = useCallback(async () => {\n    if (!state.isPreview || !token || !documentId) return\n\n    setCookie(previewCookie, token)\n\n    const queryOptions: QueryOptions = {}\n    if (hydratedOptions.fetchLinks)\n      queryOptions.fetchLinks = hydratedOptions.fetchLinks\n\n    // Query Prismic's API for the document.\n    const client = await createClient(\n      hydratedOptions.repositoryName,\n      hydratedOptions.accessToken,\n    )\n    const doc = await client.getByID(documentId, queryOptions)\n\n    // Process the document into nodes.\n    const typePathsRes = await fetch(\n      `/${hydratedOptions.typePathsFilenamePrefix}${hydratedOptions.schemasDigest}.json`,\n      { headers: { 'Content-Type': 'application/json' } },\n    )\n    const typePaths = await typePathsRes.json()\n    const env = createEnvironment(\n      hydratedOptions as BrowserPluginOptions,\n      typePaths,\n    )\n    const { context } = env\n    const { getNodeById } = context as DocumentsToNodesEnvironmentBrowserContext\n    const rootNodeId = await documentToNodes(doc, env)\n    const rootNode = getNodeById(rootNodeId)\n\n    const resolvedPathResolver =\n      hydratedOptions.pathResolver ?? hydratedOptions.linkResolver\n    const path = resolvedPathResolver\n      ? resolvedPathResolver({ node: doc })(doc)\n      : undefined\n\n    dispatch({ type: ActionType.DOCUMENT_LOADED, payload: { rootNode, path } })\n  }, [state.isPreview])\n\n  useEffect(() => {\n    asyncEffect()\n  }, [asyncEffect])\n\n  return state\n}\n","import { Node } from 'gatsby'\nimport isPlainObject from 'lodash.isplainobject'\n\nimport { NodeTree } from './types'\n\n// Root node field used to compare static data with preview data. If values are\n// equal, the preview node can be treated as an updated version of the static\n// node.\nconst PREVIEWABLE_NODE_ID_FIELD = '_previewable'\n\n// TODO: Remove in v4.0.0\n// Same as PREVIEWABLE_NODE_ID_FIELD, but the legacy version that will be phased out in v4.0.0.\nconst LEGACY_PREVIEWABLE_NODE_ID_FIELD = 'prismicId'\n\nconst traverseAndReplace = (node: any, replacementNode: Node): any => {\n  if (isPlainObject(node)) {\n    // If the nodes share an ID, replace it.\n    if (\n      node[PREVIEWABLE_NODE_ID_FIELD] ===\n      replacementNode[PREVIEWABLE_NODE_ID_FIELD]\n    )\n      return replacementNode\n\n    // TODO: Remove in v4.0.0\n    if (\n      node[LEGACY_PREVIEWABLE_NODE_ID_FIELD] ===\n      replacementNode[LEGACY_PREVIEWABLE_NODE_ID_FIELD]\n    ) {\n      console.warn(\n        'Warning: Merging nested preview data using the prismicId field will be deprecated in gatsby-source-prismic v4.0.0.\\n\\nIf you are relying on this functionality, please update your GraphQL query to include the _previewable field on documents that should be previewable.',\n      )\n      return replacementNode\n    }\n\n    // We did not find the Node to replace. Iterate all properties and continue\n    // to find the Node.\n    const newNode: typeof node = {}\n    for (const subnodeKey in node)\n      newNode[subnodeKey] = traverseAndReplace(\n        node[subnodeKey],\n        replacementNode,\n      )\n    return newNode\n  }\n\n  // Iterate all elements in the node to find the Node.\n  if (Array.isArray(node))\n    return node.map((subnode) => traverseAndReplace(subnode, replacementNode))\n\n  // If the node is not an object or array, it cannot be a Node.\n  return node\n}\n\nexport interface MergePrismicPreviewDataArgs {\n  staticData?: NodeTree\n  previewData?: NodeTree\n  /**\n   * Determines the method with which the function merges preview data into static data.\n   *\n   * - `traverseAndReplace`: Traverse static data nodes and replace with preview data if IDs match.\n   * - `rootReplaceOrInsert`: Replace or insert preview data at the root level.\n   */\n  strategy?: 'traverseAndReplace' | 'rootReplaceOrInsert'\n}\n\n/**\n * Merges preview data with static data. Different merge strategies can be used\n * for different environments.\n */\nexport const mergePrismicPreviewData = ({\n  staticData,\n  previewData,\n  strategy = 'traverseAndReplace',\n}: MergePrismicPreviewDataArgs): NodeTree | undefined => {\n  if (!staticData && !previewData) return\n  if (!staticData) return previewData\n  if (!previewData) return staticData\n\n  switch (strategy) {\n    // Unpublished previews must return data at the root to ensure it is always\n    // available. If staticData and previewData share root-level keys, they are\n    // merged. Otherwise, data will be sibilings.\n    case 'rootReplaceOrInsert':\n      return { ...staticData, ...previewData }\n\n    // Traverse static data nodes and replace with preview data if IDs match.\n    case 'traverseAndReplace':\n    default: {\n      const previewDataRootNodeKey = Object.keys(previewData)[0]\n\n      // TODO: Remove in v4.0.0.\n      if (\n        staticData.hasOwnProperty(previewDataRootNodeKey) &&\n        !staticData[previewDataRootNodeKey][PREVIEWABLE_NODE_ID_FIELD] &&\n        !staticData[previewDataRootNodeKey][LEGACY_PREVIEWABLE_NODE_ID_FIELD]\n      ) {\n        // TODO: Add link to more details on _previewable.\n        console.warn(\n          'Warning: Merging preview data implicitly will be deprecated in gatsby-source-prismic v4.0.0.\\n\\nIf you are relying on this functionality, please update your GraphQL query to include the _previewable field on documents that should be previewable.',\n        )\n        return { ...staticData, ...previewData }\n      }\n\n      return traverseAndReplace(staticData, previewData[previewDataRootNodeKey])\n    }\n  }\n}\n","import * as React from 'react'\nimport { NodeTree } from './types'\n\nconst DEFAULT_INITIAL_PAGES = {}\nconst DEFAULT_INITIAL_ENABLED = false\n\nexport enum ActionType {\n  AddPage,\n  EnablePreviews,\n  DisablePreviews,\n}\n\ntype Action =\n  | {\n      type: ActionType.AddPage\n      payload: { path: string; data: NodeTree }\n    }\n  | { type: Exclude<ActionType, ActionType.AddPage> }\n\ninterface State {\n  pages: Record<string, NodeTree>\n  enabled: boolean\n}\n\nconst createInitialState = (initialState?: Partial<State>): State => ({\n  pages: DEFAULT_INITIAL_PAGES,\n  enabled: DEFAULT_INITIAL_ENABLED,\n  ...initialState,\n})\n\nconst reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case ActionType.AddPage: {\n      return {\n        ...state,\n        pages: {\n          ...state.pages,\n          [action.payload.path]: action.payload.data,\n        },\n        enabled: true,\n      }\n    }\n\n    case ActionType.EnablePreviews: {\n      return { ...state, enabled: true }\n    }\n\n    case ActionType.DisablePreviews: {\n      return { ...state, enabled: false }\n    }\n  }\n}\n\nconst PreviewStoreContext = React.createContext([\n  createInitialState(),\n  () => {},\n] as [State, React.Dispatch<Action>])\n\nexport type PreviewStoreProviderProps = {\n  children?: React.ReactNode\n  initialPages?: State['pages']\n  initialEnabled?: State['enabled']\n}\n\nexport const PreviewStoreProvider = ({\n  children,\n  initialPages = DEFAULT_INITIAL_PAGES,\n  initialEnabled = DEFAULT_INITIAL_ENABLED,\n}: PreviewStoreProviderProps) => {\n  const reducerTuple = React.useReducer(\n    reducer,\n    createInitialState({\n      pages: initialPages,\n      enabled: initialEnabled,\n    }),\n  )\n\n  return (\n    <PreviewStoreContext.Provider value={reducerTuple}>\n      {children}\n    </PreviewStoreContext.Provider>\n  )\n}\n\nexport const usePreviewStore = () => React.useContext(PreviewStoreContext)\n","import * as React from 'react'\nimport { PageProps } from 'gatsby'\n\nimport {\n  mergePrismicPreviewData,\n  MergePrismicPreviewDataArgs,\n} from './mergePrismicPreviewData'\nimport { usePreviewStore } from './usePreviewStore'\nimport { getComponentDisplayName } from './utils'\nimport { NodeTree } from './types'\n\ntype WithPreviewArgs = {\n  mergeStrategy?: MergePrismicPreviewDataArgs['strategy']\n}\n\nexport const withPreview = <TProps extends PageProps>(\n  WrappedComponent: React.ComponentType<TProps>,\n  options?: WithPreviewArgs,\n): React.ComponentType<TProps> => {\n  const WithPreview = (props: TProps) => {\n    const [state] = usePreviewStore()\n\n    const path = props.location.pathname\n    const staticData = props.data as NodeTree\n    const previewData = state.pages[path]\n\n    const data = React.useMemo(\n      () =>\n        state.enabled\n          ? mergePrismicPreviewData({\n              staticData,\n              previewData,\n              strategy: options?.mergeStrategy,\n            })\n          : staticData,\n      [state.enabled, staticData, previewData],\n    )\n\n    return <WrappedComponent {...props} data={data} />\n  }\n  WithPreview.displayName = `withPreview(${getComponentDisplayName(\n    WrappedComponent,\n  )})`\n\n  return WithPreview\n}\n","import * as React from 'react'\nimport { navigate, PageProps } from 'gatsby'\n\nimport {\n  usePrismicPreview,\n  UsePrismicPreviewOptions,\n} from './usePrismicPreview'\nimport { usePreviewStore, ActionType } from './usePreviewStore'\nimport { getComponentDisplayName } from './utils'\n\nexport interface WithPreviewResolverProps {\n  isPreview: boolean | undefined\n  isLoading: boolean\n}\n\nexport const withPreviewResolver = <TProps extends PageProps>(\n  WrappedComponent: React.ComponentType<TProps>,\n  options: UsePrismicPreviewOptions,\n): React.ComponentType<TProps> => {\n  const WithPreviewResolver = (props: TProps) => {\n    const [, dispatch] = usePreviewStore()\n\n    const { isLoading, isPreview, previewData, path } = usePrismicPreview(\n      options,\n    )\n\n    React.useEffect(() => {\n      if (isPreview && previewData && path) {\n        dispatch({\n          type: ActionType.AddPage,\n          payload: { path, data: previewData },\n        })\n        navigate(path)\n      }\n    }, [isPreview, previewData, path, dispatch])\n\n    return (\n      <WrappedComponent\n        {...props}\n        isPreview={isPreview}\n        isLoading={isLoading}\n      />\n    )\n  }\n  WithPreviewResolver.displayName = `withPreviewResolver(${getComponentDisplayName(\n    WrappedComponent,\n  )})`\n\n  return WithPreviewResolver\n}\n","import * as React from 'react'\nimport { PageProps } from 'gatsby'\n\nimport { usePreviewStore } from './usePreviewStore'\nimport { withPreview } from './withPreview'\nimport { msg, getComponentDisplayName } from './utils'\n\ntype WithUnpublishedPreviewArgs = {\n  templateMap: Record<string, React.ComponentType<any>>\n}\n\nexport const withUnpublishedPreview = <TProps extends PageProps>(\n  WrappedComponent: React.ComponentType<TProps>,\n  options: WithUnpublishedPreviewArgs,\n): React.ComponentType<TProps> => {\n  const WithUnpublishedPreview = (props: TProps) => {\n    const [state] = usePreviewStore()\n    const path = props.location.pathname\n    const isPreview = state.pages.hasOwnProperty(path)\n\n    if (isPreview) {\n      const previewData = state.pages[path]\n      const key = Object.keys(previewData)[0]\n      const type = previewData[key].type as string\n      const TemplateComp = options.templateMap[type]\n\n      if (TemplateComp) return <TemplateComp {...props} />\n      else\n        console.warn(\n          msg(\n            `An unpublished preview was detected, but a template component could not be found for a custom type of \"${type}\". Check that the templateMap option in withUnpublishedPreview includes a component for \"${type}\". withUnpublishedPreview will yield to the wrapped component to render.`,\n          ),\n        )\n    }\n\n    return <WrappedComponent {...props} />\n  }\n  WithUnpublishedPreview.displayName = `withUnpublishedPreview(${getComponentDisplayName(\n    WrappedComponent,\n  )})`\n\n  return withPreview(WithUnpublishedPreview, {\n    // In an unpublished preview, we have to assume the component accepts the\n    // preview data as a root-level field.\n    mergeStrategy: 'rootReplaceOrInsert',\n  })\n}\n"],"names":["baseSchema","repositoryName","struct","accessToken","releaseID","schemas","linkResolver","htmlSerializer","fetchLinks","lang","typePathsFilenamePrefix","prismicToolbar","imageImgixParams","auto","fit","q","imagePlaceholderImgixParams","w","blur","plugins","BrowserPluginOptions","shouldDownloadImage","webhookSecret","pathResolver","schemasDigest","mapObjValsP","async","fn","obj","result","keys","Object","Promise","all","map","key","buildSchemaTypeName","apiId","pascalCase","transform","pascalCaseTransformMerge","isBrowser","window","getComponentDisplayName","WrappedComponent","displayName","name","IMAGE_FIELD_KEYS","createClient","url","nameOrUrl","addr","match","toPrismicUrl","getApi","LinkFieldType","FieldType","GraphQLType","SliceChoiceDisplay","normalizeField","field","path","doc","env","createNodeId","createNode","createContentDigest","typePaths","normalizeStructuredTextField","normalizeLinkField","normalizeImageField","normalizeSlicesField","stringifiedPath","JSON","stringify","def","find","x","test","type","Group","Slices","getTypeForPath","Image","baseObj","pick","thumbsObj","omit","thumbnails","thumb","StructuredText","Link","normalizeObjs","sliceNodeIds","slice","index","sliceNodeId","id","normalizedPrimary","normalizeObj","primary","slice_type","normalizedItems","items","node","slice_label","undefined","internal","contentDigest","AlternateLanguages","item","link_type","Document","fieldApiId","objs","documentToNodes","pluginOptions","linkResolverForDoc","docNodeId","docUrl","normalizedData","data","normalizedAlernativeLanguages","alternate_languages","prismicId","dataString","dataRaw","_previewable","_apiId","_path","_doc","fixed","buildImgixFixed","sourceWidth","dimensions","width","sourceHeight","height","args","imgixParams","placeholderImgixParams","fluid","buildImgixFluid","context","getNodeById","linkResolverForField","value","linkedDocId","isBroken","hasNodeById","queryOptions","client","getByID","loadLinkFieldDocument","Proxy","PrismicDOMLink","document","raw","get","prop","__typename","htmlSerializerForField","html","PrismicDOMRichText","asHtml","text","asText","ActionType","initialState","isPreview","isLoading","previewData","reducer","state","action","IS_NOT_PREVIEW","IS_PREVIEW","DOCUMENT_LOADED","payload","rootNode","[object Object]","camelCase","RESET","Error","usePrismicPreview","options","dispatch","useReducer","hydratedOptions","useMemo","browserOptions","coerced","validateBrowserOptions","token","documentId","params","URLSearchParams","location","search","useEffect","Boolean","asyncEffect","useCallback","setCookie","previewCookie","typePathsRes","fetch","headers","Content-Type","json","nodeStore","Map","set","input","uuidv5","md5","has","createEnvironment","resolvedPathResolver","traverseAndReplace","replacementNode","isPlainObject","console","warn","newNode","subnodeKey","Array","isArray","subnode","mergePrismicPreviewData","staticData","strategy","previewDataRootNodeKey","hasOwnProperty","DEFAULT_INITIAL_PAGES","createInitialState","pages","enabled","AddPage","EnablePreviews","DisablePreviews","PreviewStoreContext","React","PreviewStoreProvider","children","initialPages","initialEnabled","reducerTuple","Provider","usePreviewStore","withPreview","WithPreview","props","pathname","mergeStrategy","withPreviewResolver","WithPreviewResolver","navigate","withUnpublishedPreview","WithUnpublishedPreview","TemplateComp","templateMap"],"mappings":"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"}