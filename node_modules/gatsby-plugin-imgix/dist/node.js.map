{"version":3,"file":"node.js","sources":["../src/utils.ts","../src/builders.ts","../src/shared.ts","../src/createImgixUrlFieldConfig.ts","../src/createImgixBase64FieldConfig.ts","../src/createImgixFixedFieldConfig.ts","../src/createImgixFluidFieldConfig.ts"],"sourcesContent":["import _fetch, { Response } from 'node-fetch'\nimport { GatsbyCache, Reporter } from 'gatsby'\nimport md5 from 'md5'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { Option } from 'fp-ts/lib/Option'\nimport { Semigroup, getObjectSemigroup } from 'fp-ts/lib/Semigroup'\nimport { Task } from 'fp-ts/lib/Task'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { flow } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams } from './types'\nimport { ImgixSourceDataResolver } from './shared'\n\nexport type Maybe<T> = T | undefined\nexport type Nullable<T> = Maybe<T | null>\nexport type OptionalPromise<T> = T | Promise<T>\n\nexport function invariant(\n  condition: unknown,\n  msg: string,\n  reporter: Reporter,\n): asserts condition {\n  if (!condition) reporter.panic(`Invariant failed: ${msg}`)\n}\n\nexport const noop = (): void => {\n  // noop\n}\n\nexport const transformUrlForWebProxy = (\n  url: string,\n  domain: string,\n): string => {\n  const instance = new URL(`https://${domain}`)\n  instance.pathname = encodeURIComponent(url)\n  return instance.toString()\n}\n\nexport const ns = (namespace = '', str: string): string => `${namespace}${str}`\n\n// getFromCache :: Cache -> String -> Task Option String\nexport const getFromCache = <A>(\n  key: string,\n  cache: GatsbyCache,\n): Task<Option<A>> => (): Promise<Option<A>> =>\n  cache.get(key).then((value?: A) => O.fromNullable(value))\n\n// setToCache :: Cache -> String -> Task Option String\nexport const setToCache = <A>(key: string, cache: GatsbyCache) => (\n  value: A,\n): Task<A> => (): Promise<A> => cache.set(key, value).then(() => value)\n\n// getFromCacheOr :: Cache, () => TaskEither A B -> String -> TaskEither A B\nexport const getFromCacheOr = <A, B>(\n  key: string,\n  cache: GatsbyCache,\n  f: () => TE.TaskEither<A, B>,\n): TE.TaskEither<A, B> =>\n  pipe(\n    getFromCache<B>(key, cache),\n    TE.rightTask,\n    TE.chain(\n      O.fold(\n        flow(\n          f,\n          TE.chain(flow(setToCache(key, cache), (x) => TE.rightTask<A, B>(x))),\n        ),\n        TE.right,\n      ),\n    ),\n  )\n\n// fetch :: String -> TaskEither Error Response\nexport const fetch = (url: string): TaskEither<Error, Response> =>\n  TE.tryCatch(\n    () => _fetch(url),\n    (reason) => new Error(String(reason)),\n  )\n\n// fetchJSON :: String -> TaskEither Error String\nexport const fetchJSON = <A>(url: string): TaskEither<Error, A> =>\n  pipe(\n    url,\n    fetch,\n    TE.chain((res) => TE.rightTask(() => res.json())),\n  )\n\n// fetchBase64 :: String -> TaskEither Error String\nexport const fetchBase64 = flow(\n  fetch,\n  TE.chain((res) => TE.rightTask(() => res.buffer())),\n  TE.chain((res) => TE.right(res.toString('base64'))),\n)\n\nexport const setURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.set(key, String(value))\n  return u.toString()\n}\n\nexport const appendURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.append(key, String(value))\n  return u.toString()\n}\n\nexport const deleteURLSearchParam = (key: string) => (url: string): string => {\n  const u = new URL(url)\n  u.searchParams.delete(key)\n  return u.toString()\n}\n\nexport const semigroupImgixUrlParams = getObjectSemigroup<ImgixUrlParams>()\n\nconst semigroupURLSearchParams: Semigroup<URLSearchParams> = {\n  concat: (x, y) => {\n    const product = new URLSearchParams(x.toString())\n    y.forEach((value, key) => {\n      value === undefined || value === null\n        ? product.delete(key)\n        : product.set(key, value)\n    })\n    return product\n  },\n}\n\nexport const setURLSearchParams = <K extends string>(url: string) => (\n  params: Record<K, string | undefined>,\n): string => {\n  const u = new URL(url)\n\n  const undefParams: K[] = pipe(\n    params,\n    R.reduceWithIndex([] as K[], (key, acc, value) =>\n      value === undefined ? A.cons(key, acc) : acc,\n    ),\n  )\n  const defParams = pipe(\n    params,\n    R.filter((param) => param !== undefined),\n  ) as Record<K, string>\n\n  const mergedParams = semigroupURLSearchParams.concat(\n    u.searchParams,\n    new URLSearchParams(defParams),\n  )\n  mergedParams.forEach((_, key) => {\n    if (undefParams.includes(key as K)) mergedParams.delete(key)\n  })\n  u.search = mergedParams.toString()\n\n  return u.toString()\n}\n\nexport const createURLSignature = (secureUrlToken: string) => (\n  url: string,\n): string =>\n  pipe(new URL(url), (u) => secureUrlToken + u.pathname + u.search, md5)\n\nexport const buildBase64URL = (contentType: string, base64: string): string =>\n  `data:${contentType};base64,${base64}`\n\nexport const signURL = (secureUrlToken: Option<string>) => (\n  url: string,\n): string =>\n  pipe(\n    secureUrlToken,\n    O.fold(\n      () => url,\n      (token) =>\n        pipe(\n          url,\n          deleteURLSearchParam('s'),\n          appendURLSearchParam('s', createURLSignature(token)(url)),\n        ),\n    ),\n  )\n\nexport const join = <A>(separator?: string) => (arr: A[]): string =>\n  arr.join(separator)\n\nexport const taskEitherFromSourceDataResolver = <TSource, TData>(\n  resolver: ImgixSourceDataResolver<TSource, TData>,\n  predicate?: (data: TData | null) => boolean,\n) => (source: TSource): TaskEither<Error, TData> =>\n  TE.tryCatch(\n    () =>\n      Promise.resolve(resolver(source)).then((data) => {\n        if (data === undefined || data === null)\n          return Promise.reject('Resolved data is null or undefined')\n\n        if (!predicate) return data\n\n        return predicate(data)\n          ? data\n          : Promise.reject('Resolved data is invalid.')\n      }),\n    (reason) => new Error(String(reason)),\n  )\n","import { FixedObject, FluidObject } from 'gatsby-image'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport { eqNumber } from 'fp-ts/lib/Eq'\nimport { ordNumber } from 'fp-ts/lib/Ord'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams, ImgixFixedArgs, ImgixFluidArgs } from './types'\nimport {\n  setURLSearchParams,\n  signURL,\n  semigroupImgixUrlParams,\n  join,\n} from './utils'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\n\n// Resolutions for `fixed` images. Same as `gatsby-plugin-sharp`.\nconst FIXED_RESOLUTIONS = [1, 1.5, 2]\n\n// Breakpoint factors for `fluid` images. Same as `gatsby-plugin-sharp`.\nconst FLUID_BREAKPOINT_FACTORS = [0.25, 0.5, 1.5, 2]\n\n// Default params for placeholder images.\nconst DEFAULT_LQIP_PARAMS: ImgixUrlParams = { w: 100, blur: 15, q: 20 }\n\nexport const buildImgixUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    params,\n    // TODO: Replace filterMap with map. filterMap is being used here just\n    // because it fibs the types a bit.\n    R.filterMap((param) =>\n      param === undefined ? O.some(undefined) : O.some(String(param)),\n    ),\n    setURLSearchParams(url),\n    signURL(O.fromNullable(secureUrlToken)),\n  )\n\nconst buildImgixLqipUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    semigroupImgixUrlParams.concat(DEFAULT_LQIP_PARAMS, params),\n    buildImgixUrl(url, secureUrlToken),\n  )\n\nconst buildImgixFixedSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    FIXED_RESOLUTIONS,\n    A.map((dpr) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, { dpr }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${dpr}x`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFixedArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFixedArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fixed image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fixed image object.\n */\nexport const buildImgixFixed = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFixedArgs): FixedObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n\n  let width: number\n  let height: number\n\n  if (args.width != undefined && args.height != undefined) {\n    width = args.width\n    height = args.height\n  } else if (args.width != undefined) {\n    width = args.width\n    height = Math.round(width / aspectRatio)\n  } else if (args.height != undefined) {\n    width = Math.round(args.height * aspectRatio)\n    height = args.height\n  } else {\n    width = DEFAULT_FIXED_WIDTH\n    height = Math.round(width / aspectRatio)\n  }\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  const srcSet = buildImgixFixedSrcSet(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  return {\n    base64,\n    width,\n    height,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n  }\n}\n\ntype BuildFluidSrcSetArgs = {\n  aspectRatio: number\n  maxWidth: number\n  srcSetBreakpoints?: number[]\n}\n\nconst buildImgixFluidSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n) => ({\n  aspectRatio,\n  maxWidth,\n  srcSetBreakpoints = FLUID_BREAKPOINT_FACTORS.map((x) => maxWidth * x),\n}: BuildFluidSrcSetArgs): string =>\n  pipe(\n    A.cons(maxWidth, srcSetBreakpoints),\n    A.uniq(eqNumber),\n    A.sort(ordNumber),\n    A.map((breakpoint) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, {\n          w: Math.round(breakpoint),\n          h: Math.round(breakpoint / aspectRatio),\n        }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${Math.round(breakpoint)}w`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFluidArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFluidArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fluid image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fluid image object.\n */\nexport const buildImgixFluid = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFluidArgs): FluidObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n  const maxWidth = args.maxWidth ?? DEFAULT_FLUID_MAX_WIDTH\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: maxWidth,\n    h: args.maxHeight,\n  })\n\n  const srcSet = buildImgixFluidSrcSet(\n    url,\n    secureUrlToken,\n  )(args.imgixParams ?? {})({\n    aspectRatio,\n    maxWidth: maxWidth,\n    srcSetBreakpoints: args.srcSetBreakpoints,\n  })\n\n  return {\n    base64,\n    aspectRatio,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n    sizes: '',\n  }\n}\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLInputObjectType,\n  GraphQLInputFieldConfigMap,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLString,\n  GraphQLBoolean,\n} from 'gatsby/graphql'\nimport imgixUrlParameters from 'imgix-url-params/dist/parameters.json'\nimport { camelCase } from 'camel-case'\n// import * as E from 'fp-ts/lib/Either'\nimport * as TE from 'fp-ts/lib/TaskEither'\n// import { Either } from 'fp-ts/lib/Either'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport { sequenceT } from 'fp-ts/lib/Apply'\n\nimport { ImgixMetadata } from './types'\nimport { buildImgixUrl } from './builders'\nimport {\n  getFromCacheOr,\n  fetchJSON,\n  taskEitherFromSourceDataResolver,\n  fetch,\n  buildBase64URL,\n} from './utils'\n\nexport const ImgixUrlParamsInputType = new GraphQLInputObjectType({\n  name: 'ImgixUrlParamsInput',\n  fields: Object.keys(imgixUrlParameters.parameters).reduce((fields, param) => {\n    const spec =\n      imgixUrlParameters.parameters[\n        param as keyof typeof imgixUrlParameters.parameters\n      ]\n\n    // The param name is camel-cased here to appease the GraphQL field\n    // requirements. This will need to be reversed with param-case when the\n    // URL is constructed in `buildImgixUrl`.\n    const name = camelCase(param)\n\n    const expects = spec.expects as { type: string }[]\n    const expectsTypes = Array.from(\n      new Set(expects.map((expect) => expect.type)),\n    )\n\n    // TODO: Clean up this mess.\n    const type = expectsTypes.every(\n      (type) => type === 'integer' || type === 'unit_scalar',\n    )\n      ? GraphQLInt\n      : expectsTypes.every(\n          (type) =>\n            type === 'integer' || type === 'unit_scalar' || type === 'number',\n        )\n      ? GraphQLFloat\n      : expectsTypes.every((type) => type === 'boolean')\n      ? GraphQLBoolean\n      : GraphQLString\n\n    fields[name] = {\n      type,\n      description:\n        spec.short_description +\n        // Ensure the description ends with a period.\n        (spec.short_description.slice(-1) === '.' ? '' : '.'),\n    }\n\n    // Add the default value as part of the description. Setting it as a\n    // GraphQL default value will automatically assign it in the final URL.\n    // Doing so would result in a huge number of unwanted params.\n    if ('default' in spec)\n      fields[name].description =\n        fields[name].description + ` Default: \\`${spec.default}\\`.`\n\n    // Add Imgix documentation URL as part of the description.\n    if ('url' in spec)\n      fields[name].description =\n        fields[name].description + ` [See docs](${spec.url}).`\n\n    // Create aliased fields.\n    if ('aliases' in spec)\n      for (const alias of spec.aliases)\n        fields[camelCase(alias)] = {\n          ...fields[name],\n          description: `Alias for \\`${name}\\`.`,\n        }\n\n    return fields\n  }, {} as GraphQLInputFieldConfigMap),\n})\n\nexport type ImgixSourceDataResolver<TSource, TData> = (\n  obj: TSource,\n) => TData | null | undefined | void | Promise<TData | null | undefined | void>\n\nexport const fetchImgixMetadata = (\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TE.TaskEither<Error, ImgixMetadata> =>\n  getFromCacheOr(`gatsby-plugin-imgix-metadata-${url}`, cache, () =>\n    pipe({ fm: 'json' }, buildImgixUrl(url, secureUrlToken), (u) =>\n      fetchJSON(u),\n    ),\n  )\n\nexport const fetchImgixBase64Url = (cache: GatsbyCache) => (\n  url: string,\n): TE.TaskEither<Error, string> =>\n  getFromCacheOr(`gatsby-plugin-imgix-base64-url-${url}`, cache, () =>\n    pipe(\n      url,\n      fetch,\n      TE.chain((res) =>\n        pipe(\n          TE.rightTask<Error, Buffer>(() => res.buffer()),\n          TE.chain((buffer) => TE.right(buffer.toString('base64'))),\n          TE.chain((base64) =>\n            TE.right(\n              buildBase64URL(String(res.headers.get('content-type')), base64),\n            ),\n          ),\n        ),\n      ),\n    ),\n  )\n\nconst sequenceTTE = sequenceT(TE.taskEither)\n\nexport const resolveDimensions = <TSource>(\n  source: TSource,\n  resolveWidth: ImgixSourceDataResolver<TSource, number>,\n  resolveHeight: ImgixSourceDataResolver<TSource, number>,\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TaskEither<Error, [number, number]> =>\n  pipe(\n    sequenceTTE(\n      taskEitherFromSourceDataResolver(resolveWidth)(source),\n      taskEitherFromSourceDataResolver(resolveHeight)(source),\n    ),\n    TE.fold(\n      () =>\n        pipe(\n          url,\n          fetchImgixMetadata(cache, secureUrlToken),\n          TE.map(\n            ({ PixelWidth, PixelHeight }) =>\n              [PixelWidth, PixelHeight] as [number, number],\n          ),\n        ),\n      TE.right,\n    ),\n  )\n\n// export const aspectRatio = (\n//   width: number,\n//   height: number,\n// ): Either<Error, number> =>\n//   height === 0\n//     ? E.left(new Error('Height cannot be 0'))\n//     : E.right(width / height)\n","import { GraphQLFieldConfig, GraphQLString } from 'gatsby/graphql'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { buildImgixUrl } from './builders'\nimport { ImgixSourceDataResolver, ImgixUrlParamsInputType } from './shared'\nimport { ImgixUrlParams } from './types'\nimport {\n  taskEitherFromSourceDataResolver,\n  semigroupImgixUrlParams,\n} from './utils'\n\nexport interface ImgixUrlArgs {\n  imgixParams?: ImgixUrlParams\n}\n\ninterface CreateImgixUrlFieldConfigArgs<TSource> {\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  secureUrlToken?: string\n  defaultImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixUrlFieldConfig = <TSource, TContext>({\n  resolveUrl,\n  secureUrlToken,\n  defaultImgixParams = {},\n}: CreateImgixUrlFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixUrlArgs\n> => ({\n  type: GraphQLString,\n  args: {\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (obj: TSource, args: ImgixUrlArgs): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.map((url) =>\n        pipe(\n          semigroupImgixUrlParams.concat(\n            defaultImgixParams,\n            args.imgixParams ?? {},\n          ),\n          buildImgixUrl(url, secureUrlToken),\n        ),\n      ),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n\nexport const createImgixUrlSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixUrlFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixUrlArgs> =>\n  createImgixUrlFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixUrlArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLFieldConfig,\n} from 'gatsby/graphql'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { fetchImgixBase64Url, ImgixSourceDataResolver } from './shared'\nimport { taskEitherFromSourceDataResolver } from './utils'\n\ninterface CreateImgixBase64UrlFieldConfigArgs {\n  resolveUrl?: ImgixSourceDataResolver<FixedObject | FluidObject, string>\n  cache: GatsbyCache\n}\n\nexport const createImgixBase64UrlFieldConfig = <TContext>({\n  resolveUrl = (obj: FixedObject | FluidObject): string | null | undefined =>\n    obj.base64,\n  cache,\n}: CreateImgixBase64UrlFieldConfigArgs): GraphQLFieldConfig<\n  FixedObject | FluidObject,\n  TContext\n> => ({\n  type: new GraphQLNonNull(GraphQLString),\n  resolve: (obj: FixedObject | FluidObject): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.chain(fetchImgixBase64Url(cache)),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLInt,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FixedObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFixedArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFixed, DEFAULT_FIXED_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFixedTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFixedType = ({\n  name,\n  cache,\n}: CreateImgixFixedTypeArgs): GraphQLObjectType<FixedObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      width: { type: new GraphQLNonNull(GraphQLInt) },\n      height: { type: new GraphQLNonNull(GraphQLInt) },\n    },\n  })\n\ninterface CreateImgixFixedFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FixedObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFixedFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFixedFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFixedArgs\n> => ({\n  type,\n  args: {\n    width: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FIXED_WIDTH,\n    },\n    height: {\n      type: GraphQLInt,\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFixedArgs,\n  ): Promise<FixedObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFixed({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFixedSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFixedFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFixedArgs> =>\n  createImgixFixedFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFixedArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FluidObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFluidArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFluid, DEFAULT_FLUID_MAX_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFluidTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFluidType = ({\n  name,\n  cache,\n}: CreateImgixFluidTypeArgs): GraphQLObjectType<FluidObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      aspectRatio: { type: new GraphQLNonNull(GraphQLFloat) },\n    },\n  })\n\ninterface CreateImgixFluidFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FluidObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFluidFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFluidFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFluidArgs\n> => ({\n  type,\n  args: {\n    maxWidth: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FLUID_MAX_WIDTH,\n    },\n    maxHeight: {\n      type: GraphQLInt,\n    },\n    srcSetBreakpoints: {\n      type: new GraphQLList(GraphQLInt),\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFluidArgs,\n  ): Promise<FluidObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFluid({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFluidSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFluidFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFluidArgs> =>\n  createImgixFluidFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFluidArgs\n  >\n"],"names":["noop","getFromCacheOr","key","cache","f","pipe","get","then","value","O","getFromCache","TE","flow","set","setToCache","x","fetch","url","_fetch","reason","Error","String","semigroupImgixUrlParams","res","buffer","toString","getObjectSemigroup","join","separator","arr","taskEitherFromSourceDataResolver","resolver","predicate","source","Promise","resolve","data","reject","FIXED_RESOLUTIONS","FLUID_BREAKPOINT_FACTORS","DEFAULT_LQIP_PARAMS","w","blur","q","buildImgixUrl","secureUrlToken","params","R","param","undefined","y","product","u","URL","undefParams","acc","A","defParams","mergedParams","searchParams","URLSearchParams","forEach","_","includes","search","setURLSearchParams","token","pathname","md5","createURLSignature","append","signURL","buildImgixLqipUrl","concat","ImgixUrlParamsInputType","GraphQLInputObjectType","name","fields","Object","keys","imgixUrlParameters","parameters","reduce","spec","camelCase","expectsTypes","Array","from","Set","expects","map","expect","type","every","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLString","description","short_description","slice","aliases","sequenceTTE","sequenceT","resolveDimensions","resolveWidth","resolveHeight","fm","json","fetchJSON","fetchImgixMetadata","PixelWidth","PixelHeight","createImgixUrlFieldConfig","resolveUrl","defaultImgixParams","args","imgixParams","defaultValue","obj","T","createImgixBase64UrlFieldConfig","base64","GraphQLNonNull","contentType","buildBase64URL","headers","fetchImgixBase64Url","createImgixFixedFieldConfig","defaultPlaceholderImgixParams","width","height","placeholderImgixParams","aspectRatio","sourceWidth","sourceHeight","Math","round","src","h","srcSet","baseUrl","dpr","buildImgixFixedSrcSet","srcWebp","srcSetWebp","buildImgixFixed","createImgixFluidFieldConfig","maxWidth","maxHeight","srcSetBreakpoints","GraphQLList","eqNumber","ordNumber","breakpoint","buildImgixFluidSrcSet","sizes","buildImgixFluid","GraphQLObjectType"],"mappings":"02BA6BaA,EAAO,aA4BPC,EAAiB,SAC5BC,EACAC,EACAC,UAEAC,OAjB0B,SAC1BH,EACAC,4BAEAA,EAAMG,IAAIJ,GAAKK,KAAK,SAACC,UAAcC,eAAeD,MAchDE,CAAgBR,EAAKC,GACrBQ,YACAA,QACEF,OACEG,OACER,EACAO,QAASC,OAjBO,SAAIV,EAAaC,mBACzCK,4BAC8BL,EAAMU,IAAIX,EAAKM,GAAOD,KAAK,kBAAMC,MAezCM,CAAWZ,EAAKC,GAAQ,SAACY,UAAMJ,YAAmBI,OAElEJ,YAMKK,EAAQ,SAACC,UACpBN,WACE,kBAAMO,EAAOD,IACb,SAACE,cAAeC,MAAMC,OAAOF,OAwCpBG,GA5BcV,OACzBI,EACAL,QAAS,SAACY,UAAQZ,YAAa,kBAAMY,EAAIC,aACzCb,QAAS,SAACY,UAAQZ,QAASY,EAAIE,SAAS,cAyBHC,wBAkE1BC,EAAO,SAAIC,mBAAwBC,UAC9CA,EAAIF,KAAKC,KAEEE,EAAmC,SAC9CC,EACAC,mBACIC,UACJtB,WACE,kBACEuB,QAAQC,QAAQJ,EAASE,IAAS1B,KAAK,SAAC6B,GACtC,OAAIA,MAAAA,EACKF,QAAQG,OAAO,sCAEnBL,EAEEA,EAAUI,GACbA,EACAF,QAAQG,OAAO,6BAJID,KAM3B,SAACjB,cAAeC,MAAMC,OAAOF,QCzL3BmB,EAAoB,CAAC,EAAG,IAAK,GAG7BC,EAA2B,CAAC,IAAM,GAAK,IAAK,GAG5CC,EAAsC,CAAEC,EAAG,IAAKC,KAAM,GAAIC,EAAG,IAEtDC,EAAgB,SAAC3B,EAAa4B,mBACzCC,UAEAzC,OACEyC,EAGAC,YAAY,SAACC,UACWvC,YAAZwC,IAAVD,OAA6BC,EAAoB5B,OAAO2B,MDkG5B,SAAmB/B,mBACnD6B,GAEA,IAdS/B,EAAGmC,EACJC,EAaFC,EAAI,IAAIC,IAAIpC,GAEZqC,EAAmBjD,OACvByC,EACAC,kBAAkB,GAAW,SAAC7C,EAAKqD,EAAK/C,eAC5ByC,IAAVzC,EAAsBgD,OAAOtD,EAAKqD,GAAOA,KAGvCE,EAAYpD,OAChByC,EACAC,SAAS,SAACC,eAAoBC,IAAVD,KAGhBU,GA3BG3C,EA4BPqC,EAAEO,aA5BQT,EA6BV,IAAIU,gBAAgBH,GA5BdN,EAAU,IAAIS,gBAAgB7C,EAAEU,YACtCyB,EAAEW,QAAQ,SAACrD,EAAON,GAChBM,MAAAA,EACI2C,SAAejD,GACfiD,EAAQtC,IAAIX,EAAKM,KAEhB2C,GA6BT,OALAO,EAAaG,QAAQ,SAACC,EAAG5D,GACnBoD,EAAYS,SAAS7D,IAAWwD,SAAoBxD,KAE1DkD,EAAEY,OAASN,EAAajC,WAEjB2B,EAAE3B,YCzHPwC,CAAmBhD,GDoIA,SAAC4B,mBACtB5B,UAEAZ,OACEwC,EACApC,OACE,kBAAMQ,GACN,SAACiD,UACC7D,OACEY,WAjE4CA,GACpD,IAAMmC,EAAI,IAAIC,IAAIpC,GAElB,OADAmC,EAAEO,oBAgE2B,KA/DtBP,EAAE3B,aAXuCjB,EAwDhB,SAACqC,mBACjC5B,UAEAZ,OAAK,IAAIgD,IAAIpC,GAAM,SAACmC,UAAMP,EAAiBO,EAAEe,SAAWf,EAAEY,QAAQI,IAgBhCC,CAAmBH,EAAnBG,CAA0BpD,YA1E5DA,GAEA,IAAMmC,EAAI,IAAIC,IAAIpC,GAElB,OADAmC,EAAEO,aAAaW,OAuEc,IAvEFjD,OAAOb,IAC3B4C,EAAE3B,cALyB,IAAcjB,MCnE9C+D,CAAQ9D,eAAeoC,OAGrB2B,EAAoB,SAACvD,EAAa4B,mBACtCC,UAEAzC,OACEiB,EAAwBmD,OAAOjC,EAAqBM,GACpDF,EAAc3B,EAAK4B,MCnBV6B,EAA0B,IAAIC,yBAAuB,CAChEC,KAAM,sBACNC,OAAQC,OAAOC,KAAKC,EAAmBC,YAAYC,OAAO,SAACL,EAAQ7B,GACjE,IAAMmC,EACJH,EAAmBC,WACjBjC,GAME4B,EAAOQ,YAAUpC,GAGjBqC,EAAeC,MAAMC,KACzB,IAAIC,IAFUL,EAAKM,QAEHC,IAAI,SAACC,UAAWA,EAAOC,SAInCA,EAAOP,EAAaQ,MACxB,SAACD,SAAkB,YAATA,GAA+B,gBAATA,IAE9BE,aACAT,EAAaQ,MACX,SAACD,SACU,YAATA,GAA+B,gBAATA,GAAmC,WAATA,IAEpDG,eACAV,EAAaQ,MAAM,SAACD,SAAkB,YAATA,IAC7BI,iBACAC,gBAuBJ,GArBApB,EAAOD,GAAQ,CACbgB,KAAAA,EACAM,YACEf,EAAKgB,mBAEiC,MAArChB,EAAKgB,kBAAkBC,OAAO,GAAa,GAAK,MAMjD,YAAajB,IACfN,EAAOD,GAAMsB,YACXrB,EAAOD,GAAMsB,0BAA6Bf,gBAG1C,QAASA,IACXN,EAAOD,GAAMsB,YACXrB,EAAOD,GAAMsB,2BAA6Bf,EAAKlE,UAG/C,YAAakE,EACf,+rBAAoBA,EAAKkB,wBACvBxB,EAAOO,2BACFP,EAAOD,IACVsB,0BAA4BtB,SAGlC,OAAOC,GACN,MAsCCyB,EAAcC,YAAU5F,cAEjB6F,EAAoB,SAC/BvE,EACAwE,EACAC,EACAvG,EACA0C,mBACI5B,UACJZ,OACEiG,EACExE,EAAiC2E,EAAjC3E,CAA+CG,GAC/CH,EAAiC4E,EAAjC5E,CAAgDG,IAElDtB,OACE,kBACEN,OACEY,EAhDwB,SAChCd,EACA0C,mBACI5B,UACJhB,kCAA+CgB,EAAOd,EAAO,kBAC3DE,OAAK,CAAEsG,GAAI,QAAU/D,EAAc3B,EAAK4B,GAAiB,SAACO,UFjBrC,SAAInC,UAC3BZ,OACEY,EACAD,EACAL,QAAS,SAACY,UAAQZ,YAAa,kBAAMY,EAAIqF,YEcvCC,CAAUzD,QA2CN0D,CAAmB3G,EAAO0C,GAC1BlC,MACE,kBACE,GADCoG,aAAYC,iBAIrBrG,YC/HOsG,EAA4B,gBACvCC,IAAAA,WACArE,IAAAA,mBACAsE,mBAAAA,aAAqB,WAKjB,CACJvB,KAAMK,gBACNmB,KAAM,CACJC,YAAa,CACXzB,KAAMlB,EACN4C,aAAc,KAGlBnF,QAAS,SAACoF,EAAcH,UACtB/G,OACEkH,EACAzF,EAAiCoF,GACjCvG,MAAO,SAACM,gBACNZ,OACEiB,EAAwBmD,OACtB0C,YACAC,EAAKC,2BAAe,IAEtBzE,EAAc3B,EAAK4B,MAGvBlC,OAAQ,kBAAM6G,UAAKvE,IAAYuE,MAZjCnH,MCtBSoH,EAAkC,oBAC7CP,WAAAA,aAAa,SAACK,UACZA,EAAIG,UACNvH,IAAAA,YAII,CACJyF,KAAM,IAAI+B,iBAAe1B,iBACzB9D,QAAS,SAACoF,UACRlH,OACEkH,EACAzF,EAAiCoF,GACjCvG,QF0E6B,SAACR,mBAClCc,UAEAhB,oCAAiDgB,EAAOd,EAAO,kBAC7DE,OACEY,EACAD,EACAL,QAAS,SAACY,UACRlB,OACEM,YAA4B,kBAAMY,EAAIC,WACtCb,QAAS,SAACa,UAAWb,QAASa,EAAOC,SAAS,aAC9Cd,QAAS,SAAC+G,UACR/G,QFiDkB,SAACiH,EAAqBF,iBAC1CE,aAAsBF,EEjDlBG,CAAexG,OAAOE,EAAIuG,QAAQxH,IAAI,iBAAkBoH,aEvFvDK,CAAoB5H,IAC7BQ,OAAQ,kBAAM6G,UAAKvE,IAAYuE,MAJjCnH,MC6BS2H,EAA8B,gBAEzCd,IAAAA,eACAT,aAAAA,aAAezG,QACf0G,cAAAA,aAAgB1G,IAChB6C,IAAAA,eACA1C,IAAAA,MACAgH,IAAAA,mBACAc,IAAAA,oCAKI,CACJrC,OAbAA,KAcAwB,KAAM,CACJc,MAAO,CACLtC,KAAME,aACNwB,aJ5D6B,KI8D/Ba,OAAQ,CACNvC,KAAME,cAERuB,YAAa,CACXzB,KAAMlB,EACN4C,aAAc,IAEhBc,uBAAwB,CACtBxC,KAAMlB,EACN4C,aAAc,KAGlBnF,QAAS,SACPoF,EACAH,UAEA/G,OACEkH,EACAzF,EACEoF,EACA,SAACjG,SAAuB,iBAARA,IAElBN,QAAS,SAACM,UACRZ,OACEY,EACAuF,EACEe,EACAd,EACAC,EACAvG,EACA0C,GAEFlC,MAAO,mBJhCc,gBASzBuH,EACAC,EATJlH,IAAAA,IAGA4B,IAAAA,mBACAuE,KAAAA,aAAO,KAEDiB,IALNC,cACAC,aASkBtF,MAAdmE,EAAKc,OAAqCjF,MAAfmE,EAAKe,QAClCD,EAAQd,EAAKc,MACbC,EAASf,EAAKe,QACSlF,MAAdmE,EAAKc,OACdA,EAAQd,EAAKc,MACbC,EAASK,KAAKC,MAAMP,EAAQG,IACJpF,MAAfmE,EAAKe,QACdD,EAAQM,KAAKC,MAAMrB,EAAKe,OAASE,GACjCF,EAASf,EAAKe,SAEdD,EApF+B,IAqF/BC,EAASK,KAAKC,MAAMP,EAAQG,IAG9B,IAAMX,EAASlD,EACbvD,EACA4B,EAFa2B,MAIV4C,EAAKC,YACLD,EAAKgB,yBAGJM,EAAM9F,EACV3B,EACA4B,EAFUD,MAIPwE,EAAKC,aACR5E,EAAGyF,EACHS,EAAGR,KAGCS,EAvEsB,SAACC,EAAiBhG,mBAC9CC,UAEAzC,OACEiC,EACAkB,MAAM,SAACsF,UACLzI,OACEiB,EAAwBmD,OAAO3B,EAAQ,CAAEgG,IAAAA,IACzClG,EAAciG,EAAShG,GACvB,SAAC5B,UAAWA,MAAO6H,UAGvBnH,EAAK,QA2DQoH,CACb9H,EACA4B,EAFakG,MAIV3B,EAAKC,aACR5E,EAAGyF,EACHS,EAAGR,KAGL,MAAO,CACLT,OAAAA,EACAQ,MAAAA,EACAC,OAAAA,EACAO,IAAAA,EACAM,QAASN,EACTE,OAAAA,EACAK,WAAYL,GI1BJM,CAAgB,CACdjI,IAAAA,EACAqH,iBACAC,kBACA1F,eAAAA,EACAuE,UACKA,GACHC,iBACKF,EACAC,EAAKC,aAEVe,4BACKH,EACAb,EAAKgB,iCAOpBzH,aAAc,kBAAM6G,UAAKvE,KArC3B5C,MCnCS8I,EAA8B,gBAEzCjC,IAAAA,eACAT,aAAAA,aAAezG,QACf0G,cAAAA,aAAgB1G,IAChB6C,IAAAA,eACA1C,IAAAA,MACAgH,IAAAA,mBACAc,IAAAA,oCAKI,CACJrC,OAbAA,KAcAwB,KAAM,CACJgC,SAAU,CACRxD,KAAME,aACNwB,aL5DiC,KK8DnC+B,UAAW,CACTzD,KAAME,cAERwD,kBAAmB,CACjB1D,KAAM,IAAI2D,cAAYzD,eAExBuB,YAAa,CACXzB,KAAMlB,EACN4C,aAAc,IAEhBc,uBAAwB,CACtBxC,KAAMlB,EACN4C,aAAc,KAGlBnF,QAAS,SACPoF,EACAH,UAEA/G,OACEkH,EACAzF,EACEoF,EACA,SAACjG,SAAuB,iBAARA,IAElBN,QAAS,SAACM,UACRZ,OACEY,EACAuF,EACEe,EACAd,EACAC,EACAvG,EACA0C,GAEFlC,MAAO,mBLsEc,oBAC7BM,IAAAA,IAGA4B,IAAAA,mBACAuE,KAAAA,aAAO,KAEDiB,IALNC,cACAC,aAKMa,YAAWhC,EAAKgC,wBA/Ke,IAiL/B1B,EAASlD,EACbvD,EACA4B,EAFa2B,MAIV4C,EAAKC,YACLD,EAAKgB,yBAGJM,EAAM9F,EACV3B,EACA4B,EAFUD,MAIPwE,EAAKC,aACR5E,EAAG2G,EACHT,EAAGvB,EAAKiC,aAGJT,EAhEsB,SAACC,EAAiBhG,mBAC9CC,0BAEAuF,IAAAA,YACAe,IAAAA,aACAE,kBAAAA,aAAoB/G,EAAyBmD,IAAI,SAAC3E,UAAMqI,EAAWrI,aAEnEV,OACEmD,OAAO4F,EAAUE,GACjB9F,OAAOgG,YACPhG,OAAOiG,aACPjG,MAAM,SAACkG,UACLrJ,OACEiB,EAAwBmD,OAAO3B,EAAQ,CACrCL,EAAG+F,KAAKC,MAAMiB,GACdf,EAAGH,KAAKC,MAAMiB,EAAarB,KAE7BzF,EAAciG,EAAShG,GACvB,SAAC5B,UAAWA,MAAOuH,KAAKC,MAAMiB,WAGlC/H,EAAK,SA2CQgI,CACb1I,EACA4B,EAFa8G,WAGbvC,EAAKC,2BAAe,GAHPsC,CAGW,CACxBtB,YAAAA,EACAe,SAAUA,EACVE,kBAAmBlC,EAAKkC,oBAG1B,MAAO,CACL5B,OAAAA,EACAW,YAAAA,EACAK,IAAAA,EACAM,QAASN,EACTE,OAAAA,EACAK,WAAYL,EACZgB,MAAO,IKhHCC,CAAgB,CACd5I,IAAAA,EACAqH,iBACAC,kBACA1F,eAAAA,EACAuE,UACKA,GACHC,iBACKF,EACAC,EAAKC,aAEVe,4BACKH,EACAb,EAAKgB,iCAOpBzH,aAAc,kBAAM6G,UAAKvE,KArC3B5C,sFDqC6C,SAC/C+G,UAEAY,EAA4BZ,iCA7GM,uBAI9B0C,oBAAkB,CACpBlF,OAJFA,KAKEC,OAAQ,CACN6C,OAAQD,EAAgC,CAAEtH,QAL9CA,QAMIuI,IAAK,CAAE9C,KAAM,IAAI+B,iBAAe1B,kBAChC2C,OAAQ,CAAEhD,KAAM,IAAI+B,iBAAe1B,kBACnC+C,QAAS,CAAEpD,KAAM,IAAI+B,iBAAe1B,kBACpCgD,WAAY,CAAErD,KAAM,IAAI+B,iBAAe1B,kBACvC2D,MAAO,CAAEhE,KAAM,IAAI+B,iBAAe1B,kBAClCiC,MAAO,CAAEtC,KAAM,IAAI+B,iBAAe7B,eAClCqC,OAAQ,CAAEvC,KAAM,IAAI+B,iBAAe7B,mGCgGQ,SAC/CsB,UAEA+B,EAA4B/B,iCA/GM,uBAI9B0C,oBAAkB,CACpBlF,OAJFA,KAKEC,OAAQ,CACN6C,OAAQD,EAAgC,CAAEtH,QAL9CA,QAMIuI,IAAK,CAAE9C,KAAM,IAAI+B,iBAAe1B,kBAChC2C,OAAQ,CAAEhD,KAAM,IAAI+B,iBAAe1B,kBACnC+C,QAAS,CAAEpD,KAAM,IAAI+B,iBAAe1B,kBACpCgD,WAAY,CAAErD,KAAM,IAAI+B,iBAAe1B,kBACvC2D,MAAO,CAAEhE,KAAM,IAAI+B,iBAAe1B,kBAClCoC,YAAa,CAAEzC,KAAM,IAAI+B,iBAAe5B,iGHaC,SAC7CqB,UAEAH,EAA0BG"}