{"version":3,"file":"gatsby-plugin-imgix.js","sources":["../src/utils.ts","../src/builders.ts"],"sourcesContent":["import _fetch, { Response } from 'node-fetch'\nimport { GatsbyCache, Reporter } from 'gatsby'\nimport md5 from 'md5'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { Option } from 'fp-ts/lib/Option'\nimport { Semigroup, getObjectSemigroup } from 'fp-ts/lib/Semigroup'\nimport { Task } from 'fp-ts/lib/Task'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { flow } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams } from './types'\nimport { ImgixSourceDataResolver } from './shared'\n\nexport type Maybe<T> = T | undefined\nexport type Nullable<T> = Maybe<T | null>\nexport type OptionalPromise<T> = T | Promise<T>\n\nexport function invariant(\n  condition: unknown,\n  msg: string,\n  reporter: Reporter,\n): asserts condition {\n  if (!condition) reporter.panic(`Invariant failed: ${msg}`)\n}\n\nexport const noop = (): void => {\n  // noop\n}\n\nexport const transformUrlForWebProxy = (\n  url: string,\n  domain: string,\n): string => {\n  const instance = new URL(`https://${domain}`)\n  instance.pathname = encodeURIComponent(url)\n  return instance.toString()\n}\n\nexport const ns = (namespace = '', str: string): string => `${namespace}${str}`\n\n// getFromCache :: Cache -> String -> Task Option String\nexport const getFromCache = <A>(\n  key: string,\n  cache: GatsbyCache,\n): Task<Option<A>> => (): Promise<Option<A>> =>\n  cache.get(key).then((value?: A) => O.fromNullable(value))\n\n// setToCache :: Cache -> String -> Task Option String\nexport const setToCache = <A>(key: string, cache: GatsbyCache) => (\n  value: A,\n): Task<A> => (): Promise<A> => cache.set(key, value).then(() => value)\n\n// getFromCacheOr :: Cache, () => TaskEither A B -> String -> TaskEither A B\nexport const getFromCacheOr = <A, B>(\n  key: string,\n  cache: GatsbyCache,\n  f: () => TE.TaskEither<A, B>,\n): TE.TaskEither<A, B> =>\n  pipe(\n    getFromCache<B>(key, cache),\n    TE.rightTask,\n    TE.chain(\n      O.fold(\n        flow(\n          f,\n          TE.chain(flow(setToCache(key, cache), (x) => TE.rightTask<A, B>(x))),\n        ),\n        TE.right,\n      ),\n    ),\n  )\n\n// fetch :: String -> TaskEither Error Response\nexport const fetch = (url: string): TaskEither<Error, Response> =>\n  TE.tryCatch(\n    () => _fetch(url),\n    (reason) => new Error(String(reason)),\n  )\n\n// fetchJSON :: String -> TaskEither Error String\nexport const fetchJSON = <A>(url: string): TaskEither<Error, A> =>\n  pipe(\n    url,\n    fetch,\n    TE.chain((res) => TE.rightTask(() => res.json())),\n  )\n\n// fetchBase64 :: String -> TaskEither Error String\nexport const fetchBase64 = flow(\n  fetch,\n  TE.chain((res) => TE.rightTask(() => res.buffer())),\n  TE.chain((res) => TE.right(res.toString('base64'))),\n)\n\nexport const setURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.set(key, String(value))\n  return u.toString()\n}\n\nexport const appendURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.append(key, String(value))\n  return u.toString()\n}\n\nexport const deleteURLSearchParam = (key: string) => (url: string): string => {\n  const u = new URL(url)\n  u.searchParams.delete(key)\n  return u.toString()\n}\n\nexport const semigroupImgixUrlParams = getObjectSemigroup<ImgixUrlParams>()\n\nconst semigroupURLSearchParams: Semigroup<URLSearchParams> = {\n  concat: (x, y) => {\n    const product = new URLSearchParams(x.toString())\n    y.forEach((value, key) => {\n      value === undefined || value === null\n        ? product.delete(key)\n        : product.set(key, value)\n    })\n    return product\n  },\n}\n\nexport const setURLSearchParams = <K extends string>(url: string) => (\n  params: Record<K, string | undefined>,\n): string => {\n  const u = new URL(url)\n\n  const undefParams: K[] = pipe(\n    params,\n    R.reduceWithIndex([] as K[], (key, acc, value) =>\n      value === undefined ? A.cons(key, acc) : acc,\n    ),\n  )\n  const defParams = pipe(\n    params,\n    R.filter((param) => param !== undefined),\n  ) as Record<K, string>\n\n  const mergedParams = semigroupURLSearchParams.concat(\n    u.searchParams,\n    new URLSearchParams(defParams),\n  )\n  mergedParams.forEach((_, key) => {\n    if (undefParams.includes(key as K)) mergedParams.delete(key)\n  })\n  u.search = mergedParams.toString()\n\n  return u.toString()\n}\n\nexport const createURLSignature = (secureUrlToken: string) => (\n  url: string,\n): string =>\n  pipe(new URL(url), (u) => secureUrlToken + u.pathname + u.search, md5)\n\nexport const buildBase64URL = (contentType: string, base64: string): string =>\n  `data:${contentType};base64,${base64}`\n\nexport const signURL = (secureUrlToken: Option<string>) => (\n  url: string,\n): string =>\n  pipe(\n    secureUrlToken,\n    O.fold(\n      () => url,\n      (token) =>\n        pipe(\n          url,\n          deleteURLSearchParam('s'),\n          appendURLSearchParam('s', createURLSignature(token)(url)),\n        ),\n    ),\n  )\n\nexport const join = <A>(separator?: string) => (arr: A[]): string =>\n  arr.join(separator)\n\nexport const taskEitherFromSourceDataResolver = <TSource, TData>(\n  resolver: ImgixSourceDataResolver<TSource, TData>,\n  predicate?: (data: TData | null) => boolean,\n) => (source: TSource): TaskEither<Error, TData> =>\n  TE.tryCatch(\n    () =>\n      Promise.resolve(resolver(source)).then((data) => {\n        if (data === undefined || data === null)\n          return Promise.reject('Resolved data is null or undefined')\n\n        if (!predicate) return data\n\n        return predicate(data)\n          ? data\n          : Promise.reject('Resolved data is invalid.')\n      }),\n    (reason) => new Error(String(reason)),\n  )\n","import { FixedObject, FluidObject } from 'gatsby-image'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport { eqNumber } from 'fp-ts/lib/Eq'\nimport { ordNumber } from 'fp-ts/lib/Ord'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams, ImgixFixedArgs, ImgixFluidArgs } from './types'\nimport {\n  setURLSearchParams,\n  signURL,\n  semigroupImgixUrlParams,\n  join,\n} from './utils'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\n\n// Resolutions for `fixed` images. Same as `gatsby-plugin-sharp`.\nconst FIXED_RESOLUTIONS = [1, 1.5, 2]\n\n// Breakpoint factors for `fluid` images. Same as `gatsby-plugin-sharp`.\nconst FLUID_BREAKPOINT_FACTORS = [0.25, 0.5, 1.5, 2]\n\n// Default params for placeholder images.\nconst DEFAULT_LQIP_PARAMS: ImgixUrlParams = { w: 100, blur: 15, q: 20 }\n\nexport const buildImgixUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    params,\n    // TODO: Replace filterMap with map. filterMap is being used here just\n    // because it fibs the types a bit.\n    R.filterMap((param) =>\n      param === undefined ? O.some(undefined) : O.some(String(param)),\n    ),\n    setURLSearchParams(url),\n    signURL(O.fromNullable(secureUrlToken)),\n  )\n\nconst buildImgixLqipUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    semigroupImgixUrlParams.concat(DEFAULT_LQIP_PARAMS, params),\n    buildImgixUrl(url, secureUrlToken),\n  )\n\nconst buildImgixFixedSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    FIXED_RESOLUTIONS,\n    A.map((dpr) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, { dpr }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${dpr}x`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFixedArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFixedArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fixed image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fixed image object.\n */\nexport const buildImgixFixed = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFixedArgs): FixedObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n\n  let width: number\n  let height: number\n\n  if (args.width != undefined && args.height != undefined) {\n    width = args.width\n    height = args.height\n  } else if (args.width != undefined) {\n    width = args.width\n    height = Math.round(width / aspectRatio)\n  } else if (args.height != undefined) {\n    width = Math.round(args.height * aspectRatio)\n    height = args.height\n  } else {\n    width = DEFAULT_FIXED_WIDTH\n    height = Math.round(width / aspectRatio)\n  }\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  const srcSet = buildImgixFixedSrcSet(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  return {\n    base64,\n    width,\n    height,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n  }\n}\n\ntype BuildFluidSrcSetArgs = {\n  aspectRatio: number\n  maxWidth: number\n  srcSetBreakpoints?: number[]\n}\n\nconst buildImgixFluidSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n) => ({\n  aspectRatio,\n  maxWidth,\n  srcSetBreakpoints = FLUID_BREAKPOINT_FACTORS.map((x) => maxWidth * x),\n}: BuildFluidSrcSetArgs): string =>\n  pipe(\n    A.cons(maxWidth, srcSetBreakpoints),\n    A.uniq(eqNumber),\n    A.sort(ordNumber),\n    A.map((breakpoint) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, {\n          w: Math.round(breakpoint),\n          h: Math.round(breakpoint / aspectRatio),\n        }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${Math.round(breakpoint)}w`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFluidArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFluidArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fluid image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fluid image object.\n */\nexport const buildImgixFluid = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFluidArgs): FluidObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n  const maxWidth = args.maxWidth ?? DEFAULT_FLUID_MAX_WIDTH\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: maxWidth,\n    h: args.maxHeight,\n  })\n\n  const srcSet = buildImgixFluidSrcSet(\n    url,\n    secureUrlToken,\n  )(args.imgixParams ?? {})({\n    aspectRatio,\n    maxWidth: maxWidth,\n    srcSetBreakpoints: args.srcSetBreakpoints,\n  })\n\n  return {\n    base64,\n    aspectRatio,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n    sizes: '',\n  }\n}\n"],"names":["url","TE","_fetch","reason","Error","String","res","buffer","toString","transformUrlForWebProxy","semigroupImgixUrlParams","getObjectSemigroup","join","separator","arr","FIXED_RESOLUTIONS","FLUID_BREAKPOINT_FACTORS","DEFAULT_LQIP_PARAMS","w","blur","q","buildImgixUrl","secureUrlToken","params","pipe","R","param","O","undefined","x","y","product","u","URL","undefParams","key","acc","value","A","defParams","mergedParams","searchParams","URLSearchParams","forEach","set","_","includes","search","setURLSearchParams","token","pathname","md5","createURLSignature","append","signURL","buildImgixLqipUrl","concat","width","height","args","aspectRatio","sourceWidth","sourceHeight","Math","round","base64","imgixParams","placeholderImgixParams","src","h","srcSet","baseUrl","dpr","buildImgixFixedSrcSet","srcWebp","srcSetWebp","maxWidth","maxHeight","srcSetBreakpoints","map","eqNumber","ordNumber","breakpoint","buildImgixFluidSrcSet","sizes","domain","instance","encodeURIComponent"],"mappings":"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"}