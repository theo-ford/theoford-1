{"version":3,"file":"gatsby-plugin-imgix.modern.js","sources":["../src/utils.ts","../src/builders.ts"],"sourcesContent":["import _fetch, { Response } from 'node-fetch'\nimport { GatsbyCache, Reporter } from 'gatsby'\nimport md5 from 'md5'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { Option } from 'fp-ts/lib/Option'\nimport { Semigroup, getObjectSemigroup } from 'fp-ts/lib/Semigroup'\nimport { Task } from 'fp-ts/lib/Task'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { flow } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams } from './types'\nimport { ImgixSourceDataResolver } from './shared'\n\nexport type Maybe<T> = T | undefined\nexport type Nullable<T> = Maybe<T | null>\nexport type OptionalPromise<T> = T | Promise<T>\n\nexport function invariant(\n  condition: unknown,\n  msg: string,\n  reporter: Reporter,\n): asserts condition {\n  if (!condition) reporter.panic(`Invariant failed: ${msg}`)\n}\n\nexport const noop = (): void => {\n  // noop\n}\n\nexport const transformUrlForWebProxy = (\n  url: string,\n  domain: string,\n): string => {\n  const instance = new URL(`https://${domain}`)\n  instance.pathname = encodeURIComponent(url)\n  return instance.toString()\n}\n\nexport const ns = (namespace = '', str: string): string => `${namespace}${str}`\n\n// getFromCache :: Cache -> String -> Task Option String\nexport const getFromCache = <A>(\n  key: string,\n  cache: GatsbyCache,\n): Task<Option<A>> => (): Promise<Option<A>> =>\n  cache.get(key).then((value?: A) => O.fromNullable(value))\n\n// setToCache :: Cache -> String -> Task Option String\nexport const setToCache = <A>(key: string, cache: GatsbyCache) => (\n  value: A,\n): Task<A> => (): Promise<A> => cache.set(key, value).then(() => value)\n\n// getFromCacheOr :: Cache, () => TaskEither A B -> String -> TaskEither A B\nexport const getFromCacheOr = <A, B>(\n  key: string,\n  cache: GatsbyCache,\n  f: () => TE.TaskEither<A, B>,\n): TE.TaskEither<A, B> =>\n  pipe(\n    getFromCache<B>(key, cache),\n    TE.rightTask,\n    TE.chain(\n      O.fold(\n        flow(\n          f,\n          TE.chain(flow(setToCache(key, cache), (x) => TE.rightTask<A, B>(x))),\n        ),\n        TE.right,\n      ),\n    ),\n  )\n\n// fetch :: String -> TaskEither Error Response\nexport const fetch = (url: string): TaskEither<Error, Response> =>\n  TE.tryCatch(\n    () => _fetch(url),\n    (reason) => new Error(String(reason)),\n  )\n\n// fetchJSON :: String -> TaskEither Error String\nexport const fetchJSON = <A>(url: string): TaskEither<Error, A> =>\n  pipe(\n    url,\n    fetch,\n    TE.chain((res) => TE.rightTask(() => res.json())),\n  )\n\n// fetchBase64 :: String -> TaskEither Error String\nexport const fetchBase64 = flow(\n  fetch,\n  TE.chain((res) => TE.rightTask(() => res.buffer())),\n  TE.chain((res) => TE.right(res.toString('base64'))),\n)\n\nexport const setURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.set(key, String(value))\n  return u.toString()\n}\n\nexport const appendURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.append(key, String(value))\n  return u.toString()\n}\n\nexport const deleteURLSearchParam = (key: string) => (url: string): string => {\n  const u = new URL(url)\n  u.searchParams.delete(key)\n  return u.toString()\n}\n\nexport const semigroupImgixUrlParams = getObjectSemigroup<ImgixUrlParams>()\n\nconst semigroupURLSearchParams: Semigroup<URLSearchParams> = {\n  concat: (x, y) => {\n    const product = new URLSearchParams(x.toString())\n    y.forEach((value, key) => {\n      value === undefined || value === null\n        ? product.delete(key)\n        : product.set(key, value)\n    })\n    return product\n  },\n}\n\nexport const setURLSearchParams = <K extends string>(url: string) => (\n  params: Record<K, string | undefined>,\n): string => {\n  const u = new URL(url)\n\n  const undefParams: K[] = pipe(\n    params,\n    R.reduceWithIndex([] as K[], (key, acc, value) =>\n      value === undefined ? A.cons(key, acc) : acc,\n    ),\n  )\n  const defParams = pipe(\n    params,\n    R.filter((param) => param !== undefined),\n  ) as Record<K, string>\n\n  const mergedParams = semigroupURLSearchParams.concat(\n    u.searchParams,\n    new URLSearchParams(defParams),\n  )\n  mergedParams.forEach((_, key) => {\n    if (undefParams.includes(key as K)) mergedParams.delete(key)\n  })\n  u.search = mergedParams.toString()\n\n  return u.toString()\n}\n\nexport const createURLSignature = (secureUrlToken: string) => (\n  url: string,\n): string =>\n  pipe(new URL(url), (u) => secureUrlToken + u.pathname + u.search, md5)\n\nexport const buildBase64URL = (contentType: string, base64: string): string =>\n  `data:${contentType};base64,${base64}`\n\nexport const signURL = (secureUrlToken: Option<string>) => (\n  url: string,\n): string =>\n  pipe(\n    secureUrlToken,\n    O.fold(\n      () => url,\n      (token) =>\n        pipe(\n          url,\n          deleteURLSearchParam('s'),\n          appendURLSearchParam('s', createURLSignature(token)(url)),\n        ),\n    ),\n  )\n\nexport const join = <A>(separator?: string) => (arr: A[]): string =>\n  arr.join(separator)\n\nexport const taskEitherFromSourceDataResolver = <TSource, TData>(\n  resolver: ImgixSourceDataResolver<TSource, TData>,\n  predicate?: (data: TData | null) => boolean,\n) => (source: TSource): TaskEither<Error, TData> =>\n  TE.tryCatch(\n    () =>\n      Promise.resolve(resolver(source)).then((data) => {\n        if (data === undefined || data === null)\n          return Promise.reject('Resolved data is null or undefined')\n\n        if (!predicate) return data\n\n        return predicate(data)\n          ? data\n          : Promise.reject('Resolved data is invalid.')\n      }),\n    (reason) => new Error(String(reason)),\n  )\n","import { FixedObject, FluidObject } from 'gatsby-image'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport { eqNumber } from 'fp-ts/lib/Eq'\nimport { ordNumber } from 'fp-ts/lib/Ord'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams, ImgixFixedArgs, ImgixFluidArgs } from './types'\nimport {\n  setURLSearchParams,\n  signURL,\n  semigroupImgixUrlParams,\n  join,\n} from './utils'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\n\n// Resolutions for `fixed` images. Same as `gatsby-plugin-sharp`.\nconst FIXED_RESOLUTIONS = [1, 1.5, 2]\n\n// Breakpoint factors for `fluid` images. Same as `gatsby-plugin-sharp`.\nconst FLUID_BREAKPOINT_FACTORS = [0.25, 0.5, 1.5, 2]\n\n// Default params for placeholder images.\nconst DEFAULT_LQIP_PARAMS: ImgixUrlParams = { w: 100, blur: 15, q: 20 }\n\nexport const buildImgixUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    params,\n    // TODO: Replace filterMap with map. filterMap is being used here just\n    // because it fibs the types a bit.\n    R.filterMap((param) =>\n      param === undefined ? O.some(undefined) : O.some(String(param)),\n    ),\n    setURLSearchParams(url),\n    signURL(O.fromNullable(secureUrlToken)),\n  )\n\nconst buildImgixLqipUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    semigroupImgixUrlParams.concat(DEFAULT_LQIP_PARAMS, params),\n    buildImgixUrl(url, secureUrlToken),\n  )\n\nconst buildImgixFixedSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    FIXED_RESOLUTIONS,\n    A.map((dpr) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, { dpr }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${dpr}x`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFixedArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFixedArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fixed image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fixed image object.\n */\nexport const buildImgixFixed = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFixedArgs): FixedObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n\n  let width: number\n  let height: number\n\n  if (args.width != undefined && args.height != undefined) {\n    width = args.width\n    height = args.height\n  } else if (args.width != undefined) {\n    width = args.width\n    height = Math.round(width / aspectRatio)\n  } else if (args.height != undefined) {\n    width = Math.round(args.height * aspectRatio)\n    height = args.height\n  } else {\n    width = DEFAULT_FIXED_WIDTH\n    height = Math.round(width / aspectRatio)\n  }\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  const srcSet = buildImgixFixedSrcSet(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  return {\n    base64,\n    width,\n    height,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n  }\n}\n\ntype BuildFluidSrcSetArgs = {\n  aspectRatio: number\n  maxWidth: number\n  srcSetBreakpoints?: number[]\n}\n\nconst buildImgixFluidSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n) => ({\n  aspectRatio,\n  maxWidth,\n  srcSetBreakpoints = FLUID_BREAKPOINT_FACTORS.map((x) => maxWidth * x),\n}: BuildFluidSrcSetArgs): string =>\n  pipe(\n    A.cons(maxWidth, srcSetBreakpoints),\n    A.uniq(eqNumber),\n    A.sort(ordNumber),\n    A.map((breakpoint) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, {\n          w: Math.round(breakpoint),\n          h: Math.round(breakpoint / aspectRatio),\n        }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${Math.round(breakpoint)}w`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFluidArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFluidArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fluid image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fluid image object.\n */\nexport const buildImgixFluid = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFluidArgs): FluidObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n  const maxWidth = args.maxWidth ?? DEFAULT_FLUID_MAX_WIDTH\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: maxWidth,\n    h: args.maxHeight,\n  })\n\n  const srcSet = buildImgixFluidSrcSet(\n    url,\n    secureUrlToken,\n  )(args.imgixParams ?? {})({\n    aspectRatio,\n    maxWidth: maxWidth,\n    srcSetBreakpoints: args.srcSetBreakpoints,\n  })\n\n  return {\n    base64,\n    aspectRatio,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n    sizes: '',\n  }\n}\n"],"names":["transformUrlForWebProxy","url","domain","instance","URL","pathname","encodeURIComponent","toString","semigroupImgixUrlParams","flow","TE","_fetch","reason","Error","String","res","buffer","getObjectSemigroup","join","separator","arr","FIXED_RESOLUTIONS","FLUID_BREAKPOINT_FACTORS","DEFAULT_LQIP_PARAMS","w","blur","q","buildImgixUrl","secureUrlToken","params","pipe","R","param","O","undefined","u","undefParams","key","acc","value","A","defParams","mergedParams","x","y","product","URLSearchParams","forEach","delete","set","semigroupURLSearchParams","searchParams","_","includes","search","setURLSearchParams","token","md5","createURLSignature","append","signURL","buildImgixLqipUrl","concat","buildImgixFixed","sourceWidth","sourceHeight","args","aspectRatio","width","height","Math","round","base64","imgixParams","placeholderImgixParams","src","h","srcSet","baseUrl","dpr","buildImgixFixedSrcSet","srcWebp","srcSetWebp","buildImgixFluid","maxWidth","maxHeight","srcSetBreakpoints","map","eqNumber","ordNumber","breakpoint","buildImgixFluidSrcSet","sizes"],"mappings":"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"}