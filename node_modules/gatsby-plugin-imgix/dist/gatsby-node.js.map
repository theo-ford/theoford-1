{"version":3,"file":"gatsby-node.js","sources":["../src/utils.ts","../src/gatsby-node.ts","../src/builders.ts","../src/shared.ts","../src/createImgixUrlFieldConfig.ts","../src/createImgixBase64FieldConfig.ts","../src/createImgixFixedFieldConfig.ts","../src/createImgixFluidFieldConfig.ts"],"sourcesContent":["import _fetch, { Response } from 'node-fetch'\nimport { GatsbyCache, Reporter } from 'gatsby'\nimport md5 from 'md5'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { Option } from 'fp-ts/lib/Option'\nimport { Semigroup, getObjectSemigroup } from 'fp-ts/lib/Semigroup'\nimport { Task } from 'fp-ts/lib/Task'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { flow } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams } from './types'\nimport { ImgixSourceDataResolver } from './shared'\n\nexport type Maybe<T> = T | undefined\nexport type Nullable<T> = Maybe<T | null>\nexport type OptionalPromise<T> = T | Promise<T>\n\nexport function invariant(\n  condition: unknown,\n  msg: string,\n  reporter: Reporter,\n): asserts condition {\n  if (!condition) reporter.panic(`Invariant failed: ${msg}`)\n}\n\nexport const noop = (): void => {\n  // noop\n}\n\nexport const transformUrlForWebProxy = (\n  url: string,\n  domain: string,\n): string => {\n  const instance = new URL(`https://${domain}`)\n  instance.pathname = encodeURIComponent(url)\n  return instance.toString()\n}\n\nexport const ns = (namespace = '', str: string): string => `${namespace}${str}`\n\n// getFromCache :: Cache -> String -> Task Option String\nexport const getFromCache = <A>(\n  key: string,\n  cache: GatsbyCache,\n): Task<Option<A>> => (): Promise<Option<A>> =>\n  cache.get(key).then((value?: A) => O.fromNullable(value))\n\n// setToCache :: Cache -> String -> Task Option String\nexport const setToCache = <A>(key: string, cache: GatsbyCache) => (\n  value: A,\n): Task<A> => (): Promise<A> => cache.set(key, value).then(() => value)\n\n// getFromCacheOr :: Cache, () => TaskEither A B -> String -> TaskEither A B\nexport const getFromCacheOr = <A, B>(\n  key: string,\n  cache: GatsbyCache,\n  f: () => TE.TaskEither<A, B>,\n): TE.TaskEither<A, B> =>\n  pipe(\n    getFromCache<B>(key, cache),\n    TE.rightTask,\n    TE.chain(\n      O.fold(\n        flow(\n          f,\n          TE.chain(flow(setToCache(key, cache), (x) => TE.rightTask<A, B>(x))),\n        ),\n        TE.right,\n      ),\n    ),\n  )\n\n// fetch :: String -> TaskEither Error Response\nexport const fetch = (url: string): TaskEither<Error, Response> =>\n  TE.tryCatch(\n    () => _fetch(url),\n    (reason) => new Error(String(reason)),\n  )\n\n// fetchJSON :: String -> TaskEither Error String\nexport const fetchJSON = <A>(url: string): TaskEither<Error, A> =>\n  pipe(\n    url,\n    fetch,\n    TE.chain((res) => TE.rightTask(() => res.json())),\n  )\n\n// fetchBase64 :: String -> TaskEither Error String\nexport const fetchBase64 = flow(\n  fetch,\n  TE.chain((res) => TE.rightTask(() => res.buffer())),\n  TE.chain((res) => TE.right(res.toString('base64'))),\n)\n\nexport const setURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.set(key, String(value))\n  return u.toString()\n}\n\nexport const appendURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.append(key, String(value))\n  return u.toString()\n}\n\nexport const deleteURLSearchParam = (key: string) => (url: string): string => {\n  const u = new URL(url)\n  u.searchParams.delete(key)\n  return u.toString()\n}\n\nexport const semigroupImgixUrlParams = getObjectSemigroup<ImgixUrlParams>()\n\nconst semigroupURLSearchParams: Semigroup<URLSearchParams> = {\n  concat: (x, y) => {\n    const product = new URLSearchParams(x.toString())\n    y.forEach((value, key) => {\n      value === undefined || value === null\n        ? product.delete(key)\n        : product.set(key, value)\n    })\n    return product\n  },\n}\n\nexport const setURLSearchParams = <K extends string>(url: string) => (\n  params: Record<K, string | undefined>,\n): string => {\n  const u = new URL(url)\n\n  const undefParams: K[] = pipe(\n    params,\n    R.reduceWithIndex([] as K[], (key, acc, value) =>\n      value === undefined ? A.cons(key, acc) : acc,\n    ),\n  )\n  const defParams = pipe(\n    params,\n    R.filter((param) => param !== undefined),\n  ) as Record<K, string>\n\n  const mergedParams = semigroupURLSearchParams.concat(\n    u.searchParams,\n    new URLSearchParams(defParams),\n  )\n  mergedParams.forEach((_, key) => {\n    if (undefParams.includes(key as K)) mergedParams.delete(key)\n  })\n  u.search = mergedParams.toString()\n\n  return u.toString()\n}\n\nexport const createURLSignature = (secureUrlToken: string) => (\n  url: string,\n): string =>\n  pipe(new URL(url), (u) => secureUrlToken + u.pathname + u.search, md5)\n\nexport const buildBase64URL = (contentType: string, base64: string): string =>\n  `data:${contentType};base64,${base64}`\n\nexport const signURL = (secureUrlToken: Option<string>) => (\n  url: string,\n): string =>\n  pipe(\n    secureUrlToken,\n    O.fold(\n      () => url,\n      (token) =>\n        pipe(\n          url,\n          deleteURLSearchParam('s'),\n          appendURLSearchParam('s', createURLSignature(token)(url)),\n        ),\n    ),\n  )\n\nexport const join = <A>(separator?: string) => (arr: A[]): string =>\n  arr.join(separator)\n\nexport const taskEitherFromSourceDataResolver = <TSource, TData>(\n  resolver: ImgixSourceDataResolver<TSource, TData>,\n  predicate?: (data: TData | null) => boolean,\n) => (source: TSource): TaskEither<Error, TData> =>\n  TE.tryCatch(\n    () =>\n      Promise.resolve(resolver(source)).then((data) => {\n        if (data === undefined || data === null)\n          return Promise.reject('Resolved data is null or undefined')\n\n        if (!predicate) return data\n\n        return predicate(data)\n          ? data\n          : Promise.reject('Resolved data is invalid.')\n      }),\n    (reason) => new Error(String(reason)),\n  )\n","import fs from 'fs'\nimport path from 'path'\nimport {\n  GatsbyNode,\n  CreateSchemaCustomizationArgs,\n  Node,\n  PluginOptions as GatsbyPluginOptions,\n} from 'gatsby'\n\nimport { createImgixUrlSchemaFieldConfig } from './createImgixUrlFieldConfig'\nimport {\n  createImgixFixedSchemaFieldConfig,\n  createImgixFixedType,\n} from './createImgixFixedFieldConfig'\nimport {\n  createImgixFluidSchemaFieldConfig,\n  createImgixFluidType,\n} from './createImgixFluidFieldConfig'\nimport { invariant, transformUrlForWebProxy, ns } from './utils'\nimport { ImgixUrlParams } from './types'\n\nenum ImgixSourceType {\n  AmazonS3 = 's3',\n  GoogleCloudStorange = 'gcs',\n  MicrosoftAzure = 'azure',\n  WebFolder = 'webFolder',\n  WebProxy = 'webProxy',\n}\n\ninterface BaseFieldOptions {\n  nodeType: string\n  fieldName: string\n}\n\ninterface FieldOptionsSingleUrl extends BaseFieldOptions {\n  getUrl: (node: Node) => string\n}\n\ninterface FieldOptionsMultipleUrls extends BaseFieldOptions {\n  getUrls: (node: Node) => string\n}\n\ntype FieldOptions = FieldOptionsSingleUrl | FieldOptionsMultipleUrls\n\ninterface PluginOptions extends GatsbyPluginOptions {\n  domain?: string\n  secureUrlToken?: string\n  sourceType?: ImgixSourceType\n  namespace?: string\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n  fields?: FieldOptions[]\n}\n\nexport const onCreateNode: GatsbyNode['onCreateNode'] = async (\n  gatsbyContext,\n  pluginOptions: PluginOptions,\n) => {\n  const { node, actions, reporter } = gatsbyContext\n  const { createNodeField } = actions\n\n  const { domain, secureUrlToken, sourceType, fields = [] } = pluginOptions\n  invariant(\n    Array.isArray(fields),\n    'fields must be an array of field options',\n    reporter,\n  )\n\n  const fieldOptions = fields.filter(\n    (fieldOptions) => fieldOptions.nodeType === node.internal.type,\n  )\n  if (fieldOptions.length < 1) return\n\n  for (const field of fieldOptions) {\n    let fieldValue = undefined as string | string[] | undefined\n\n    if ('getUrl' in field) {\n      fieldValue = field.getUrl(node)\n      invariant(\n        fieldValue === undefined ||\n          fieldValue === null ||\n          typeof fieldValue === 'string',\n        'getUrl must return a URL string',\n        reporter,\n      )\n    } else if ('getUrls' in field) {\n      fieldValue = field.getUrls(node)\n      invariant(\n        Array.isArray(fieldValue),\n        'getUrls must return an array of URLs',\n        reporter,\n      )\n    }\n\n    if (!fieldValue) continue\n\n    if (sourceType === ImgixSourceType.WebProxy) {\n      invariant(\n        domain !== undefined,\n        'an Imgix domain must be provided if sourceType is webProxy',\n        reporter,\n      )\n      invariant(\n        secureUrlToken !== undefined,\n        'a secure URL token must be provided if sourceType is webProxy',\n        reporter,\n      )\n\n      if (Array.isArray(fieldValue))\n        fieldValue = fieldValue.map((url) =>\n          transformUrlForWebProxy(url, domain),\n        )\n      else fieldValue = transformUrlForWebProxy(fieldValue, domain)\n    }\n\n    createNodeField({ node, name: field.fieldName, value: fieldValue })\n  }\n}\n\nexport const createSchemaCustomization: GatsbyNode['createSchemaCustomization'] = async (\n  gatsbyContext: CreateSchemaCustomizationArgs,\n  pluginOptions: PluginOptions,\n) => {\n  const { actions, cache, schema, reporter } = gatsbyContext\n  const { createTypes } = actions\n\n  const {\n    secureUrlToken,\n    sourceType,\n    namespace,\n    defaultImgixParams,\n    defaultPlaceholderImgixParams,\n    fields = [],\n  } = pluginOptions\n  invariant(\n    Array.isArray(fields),\n    'fields must be an array of field options',\n    reporter,\n  )\n  invariant(\n    sourceType !== ImgixSourceType.WebProxy || Boolean(secureUrlToken),\n    'a secure URL token must be provided if sourceType is webProxy',\n    reporter,\n  )\n\n  const ImgixFixedType = createImgixFixedType({\n    name: ns(namespace, 'ImgixFixed'),\n    cache,\n  })\n\n  const ImgixFluidType = createImgixFluidType({\n    name: ns(namespace, 'ImgixFluid'),\n    cache,\n  })\n\n  const ImgixImageType = schema.buildObjectType({\n    name: ns(namespace, 'ImgixImage'),\n    fields: {\n      url: createImgixUrlSchemaFieldConfig({\n        resolveUrl: (url: string) => url,\n        secureUrlToken,\n        defaultImgixParams,\n      }),\n      fixed: createImgixFixedSchemaFieldConfig({\n        type: ImgixFixedType,\n        resolveUrl: (url: string) => url,\n        secureUrlToken,\n        defaultImgixParams,\n        defaultPlaceholderImgixParams,\n        cache,\n      }),\n      fluid: createImgixFluidSchemaFieldConfig({\n        type: ImgixFluidType,\n        resolveUrl: (url: string) => url,\n        secureUrlToken: secureUrlToken,\n        defaultImgixParams,\n        defaultPlaceholderImgixParams,\n        cache,\n      }),\n    },\n  })\n\n  const fieldTypes = fields.map((fieldOptions) =>\n    schema.buildObjectType({\n      name: `${fieldOptions.nodeType}Fields`,\n      fields: {\n        [fieldOptions.fieldName]: {\n          type:\n            'getUrls' in fieldOptions\n              ? `[${ImgixImageType.config.name}]`\n              : ImgixImageType.config.name,\n        },\n      },\n    }),\n  )\n\n  createTypes([ImgixFixedType, ImgixFluidType])\n  createTypes(ImgixImageType)\n  createTypes(fieldTypes)\n}\n\nexport const onPreExtractQueries: GatsbyNode['onPreExtractQueries'] = (\n  gatsbyContext,\n) => {\n  const { store } = gatsbyContext\n  const { program } = store.getState()\n\n  // Add fragments for GatsbyImgixImage to .cache/fragments.\n  fs.copyFileSync(\n    path.resolve(__dirname, '../fragments.js'),\n    path.resolve(\n      program.directory,\n      '.cache/fragments/gatsby-plugin-imgix-fragments.js',\n    ),\n  )\n}\n","import { FixedObject, FluidObject } from 'gatsby-image'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport { eqNumber } from 'fp-ts/lib/Eq'\nimport { ordNumber } from 'fp-ts/lib/Ord'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams, ImgixFixedArgs, ImgixFluidArgs } from './types'\nimport {\n  setURLSearchParams,\n  signURL,\n  semigroupImgixUrlParams,\n  join,\n} from './utils'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\n\n// Resolutions for `fixed` images. Same as `gatsby-plugin-sharp`.\nconst FIXED_RESOLUTIONS = [1, 1.5, 2]\n\n// Breakpoint factors for `fluid` images. Same as `gatsby-plugin-sharp`.\nconst FLUID_BREAKPOINT_FACTORS = [0.25, 0.5, 1.5, 2]\n\n// Default params for placeholder images.\nconst DEFAULT_LQIP_PARAMS: ImgixUrlParams = { w: 100, blur: 15, q: 20 }\n\nexport const buildImgixUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    params,\n    // TODO: Replace filterMap with map. filterMap is being used here just\n    // because it fibs the types a bit.\n    R.filterMap((param) =>\n      param === undefined ? O.some(undefined) : O.some(String(param)),\n    ),\n    setURLSearchParams(url),\n    signURL(O.fromNullable(secureUrlToken)),\n  )\n\nconst buildImgixLqipUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    semigroupImgixUrlParams.concat(DEFAULT_LQIP_PARAMS, params),\n    buildImgixUrl(url, secureUrlToken),\n  )\n\nconst buildImgixFixedSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    FIXED_RESOLUTIONS,\n    A.map((dpr) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, { dpr }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${dpr}x`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFixedArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFixedArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fixed image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fixed image object.\n */\nexport const buildImgixFixed = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFixedArgs): FixedObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n\n  let width: number\n  let height: number\n\n  if (args.width != undefined && args.height != undefined) {\n    width = args.width\n    height = args.height\n  } else if (args.width != undefined) {\n    width = args.width\n    height = Math.round(width / aspectRatio)\n  } else if (args.height != undefined) {\n    width = Math.round(args.height * aspectRatio)\n    height = args.height\n  } else {\n    width = DEFAULT_FIXED_WIDTH\n    height = Math.round(width / aspectRatio)\n  }\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  const srcSet = buildImgixFixedSrcSet(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  return {\n    base64,\n    width,\n    height,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n  }\n}\n\ntype BuildFluidSrcSetArgs = {\n  aspectRatio: number\n  maxWidth: number\n  srcSetBreakpoints?: number[]\n}\n\nconst buildImgixFluidSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n) => ({\n  aspectRatio,\n  maxWidth,\n  srcSetBreakpoints = FLUID_BREAKPOINT_FACTORS.map((x) => maxWidth * x),\n}: BuildFluidSrcSetArgs): string =>\n  pipe(\n    A.cons(maxWidth, srcSetBreakpoints),\n    A.uniq(eqNumber),\n    A.sort(ordNumber),\n    A.map((breakpoint) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, {\n          w: Math.round(breakpoint),\n          h: Math.round(breakpoint / aspectRatio),\n        }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${Math.round(breakpoint)}w`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFluidArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFluidArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fluid image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fluid image object.\n */\nexport const buildImgixFluid = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFluidArgs): FluidObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n  const maxWidth = args.maxWidth ?? DEFAULT_FLUID_MAX_WIDTH\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: maxWidth,\n    h: args.maxHeight,\n  })\n\n  const srcSet = buildImgixFluidSrcSet(\n    url,\n    secureUrlToken,\n  )(args.imgixParams ?? {})({\n    aspectRatio,\n    maxWidth: maxWidth,\n    srcSetBreakpoints: args.srcSetBreakpoints,\n  })\n\n  return {\n    base64,\n    aspectRatio,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n    sizes: '',\n  }\n}\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLInputObjectType,\n  GraphQLInputFieldConfigMap,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLString,\n  GraphQLBoolean,\n} from 'gatsby/graphql'\nimport imgixUrlParameters from 'imgix-url-params/dist/parameters.json'\nimport { camelCase } from 'camel-case'\n// import * as E from 'fp-ts/lib/Either'\nimport * as TE from 'fp-ts/lib/TaskEither'\n// import { Either } from 'fp-ts/lib/Either'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport { sequenceT } from 'fp-ts/lib/Apply'\n\nimport { ImgixMetadata } from './types'\nimport { buildImgixUrl } from './builders'\nimport {\n  getFromCacheOr,\n  fetchJSON,\n  taskEitherFromSourceDataResolver,\n  fetch,\n  buildBase64URL,\n} from './utils'\n\nexport const ImgixUrlParamsInputType = new GraphQLInputObjectType({\n  name: 'ImgixUrlParamsInput',\n  fields: Object.keys(imgixUrlParameters.parameters).reduce((fields, param) => {\n    const spec =\n      imgixUrlParameters.parameters[\n        param as keyof typeof imgixUrlParameters.parameters\n      ]\n\n    // The param name is camel-cased here to appease the GraphQL field\n    // requirements. This will need to be reversed with param-case when the\n    // URL is constructed in `buildImgixUrl`.\n    const name = camelCase(param)\n\n    const expects = spec.expects as { type: string }[]\n    const expectsTypes = Array.from(\n      new Set(expects.map((expect) => expect.type)),\n    )\n\n    // TODO: Clean up this mess.\n    const type = expectsTypes.every(\n      (type) => type === 'integer' || type === 'unit_scalar',\n    )\n      ? GraphQLInt\n      : expectsTypes.every(\n          (type) =>\n            type === 'integer' || type === 'unit_scalar' || type === 'number',\n        )\n      ? GraphQLFloat\n      : expectsTypes.every((type) => type === 'boolean')\n      ? GraphQLBoolean\n      : GraphQLString\n\n    fields[name] = {\n      type,\n      description:\n        spec.short_description +\n        // Ensure the description ends with a period.\n        (spec.short_description.slice(-1) === '.' ? '' : '.'),\n    }\n\n    // Add the default value as part of the description. Setting it as a\n    // GraphQL default value will automatically assign it in the final URL.\n    // Doing so would result in a huge number of unwanted params.\n    if ('default' in spec)\n      fields[name].description =\n        fields[name].description + ` Default: \\`${spec.default}\\`.`\n\n    // Add Imgix documentation URL as part of the description.\n    if ('url' in spec)\n      fields[name].description =\n        fields[name].description + ` [See docs](${spec.url}).`\n\n    // Create aliased fields.\n    if ('aliases' in spec)\n      for (const alias of spec.aliases)\n        fields[camelCase(alias)] = {\n          ...fields[name],\n          description: `Alias for \\`${name}\\`.`,\n        }\n\n    return fields\n  }, {} as GraphQLInputFieldConfigMap),\n})\n\nexport type ImgixSourceDataResolver<TSource, TData> = (\n  obj: TSource,\n) => TData | null | undefined | void | Promise<TData | null | undefined | void>\n\nexport const fetchImgixMetadata = (\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TE.TaskEither<Error, ImgixMetadata> =>\n  getFromCacheOr(`gatsby-plugin-imgix-metadata-${url}`, cache, () =>\n    pipe({ fm: 'json' }, buildImgixUrl(url, secureUrlToken), (u) =>\n      fetchJSON(u),\n    ),\n  )\n\nexport const fetchImgixBase64Url = (cache: GatsbyCache) => (\n  url: string,\n): TE.TaskEither<Error, string> =>\n  getFromCacheOr(`gatsby-plugin-imgix-base64-url-${url}`, cache, () =>\n    pipe(\n      url,\n      fetch,\n      TE.chain((res) =>\n        pipe(\n          TE.rightTask<Error, Buffer>(() => res.buffer()),\n          TE.chain((buffer) => TE.right(buffer.toString('base64'))),\n          TE.chain((base64) =>\n            TE.right(\n              buildBase64URL(String(res.headers.get('content-type')), base64),\n            ),\n          ),\n        ),\n      ),\n    ),\n  )\n\nconst sequenceTTE = sequenceT(TE.taskEither)\n\nexport const resolveDimensions = <TSource>(\n  source: TSource,\n  resolveWidth: ImgixSourceDataResolver<TSource, number>,\n  resolveHeight: ImgixSourceDataResolver<TSource, number>,\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TaskEither<Error, [number, number]> =>\n  pipe(\n    sequenceTTE(\n      taskEitherFromSourceDataResolver(resolveWidth)(source),\n      taskEitherFromSourceDataResolver(resolveHeight)(source),\n    ),\n    TE.fold(\n      () =>\n        pipe(\n          url,\n          fetchImgixMetadata(cache, secureUrlToken),\n          TE.map(\n            ({ PixelWidth, PixelHeight }) =>\n              [PixelWidth, PixelHeight] as [number, number],\n          ),\n        ),\n      TE.right,\n    ),\n  )\n\n// export const aspectRatio = (\n//   width: number,\n//   height: number,\n// ): Either<Error, number> =>\n//   height === 0\n//     ? E.left(new Error('Height cannot be 0'))\n//     : E.right(width / height)\n","import { GraphQLFieldConfig, GraphQLString } from 'gatsby/graphql'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { buildImgixUrl } from './builders'\nimport { ImgixSourceDataResolver, ImgixUrlParamsInputType } from './shared'\nimport { ImgixUrlParams } from './types'\nimport {\n  taskEitherFromSourceDataResolver,\n  semigroupImgixUrlParams,\n} from './utils'\n\nexport interface ImgixUrlArgs {\n  imgixParams?: ImgixUrlParams\n}\n\ninterface CreateImgixUrlFieldConfigArgs<TSource> {\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  secureUrlToken?: string\n  defaultImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixUrlFieldConfig = <TSource, TContext>({\n  resolveUrl,\n  secureUrlToken,\n  defaultImgixParams = {},\n}: CreateImgixUrlFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixUrlArgs\n> => ({\n  type: GraphQLString,\n  args: {\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (obj: TSource, args: ImgixUrlArgs): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.map((url) =>\n        pipe(\n          semigroupImgixUrlParams.concat(\n            defaultImgixParams,\n            args.imgixParams ?? {},\n          ),\n          buildImgixUrl(url, secureUrlToken),\n        ),\n      ),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n\nexport const createImgixUrlSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixUrlFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixUrlArgs> =>\n  createImgixUrlFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixUrlArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLFieldConfig,\n} from 'gatsby/graphql'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { fetchImgixBase64Url, ImgixSourceDataResolver } from './shared'\nimport { taskEitherFromSourceDataResolver } from './utils'\n\ninterface CreateImgixBase64UrlFieldConfigArgs {\n  resolveUrl?: ImgixSourceDataResolver<FixedObject | FluidObject, string>\n  cache: GatsbyCache\n}\n\nexport const createImgixBase64UrlFieldConfig = <TContext>({\n  resolveUrl = (obj: FixedObject | FluidObject): string | null | undefined =>\n    obj.base64,\n  cache,\n}: CreateImgixBase64UrlFieldConfigArgs): GraphQLFieldConfig<\n  FixedObject | FluidObject,\n  TContext\n> => ({\n  type: new GraphQLNonNull(GraphQLString),\n  resolve: (obj: FixedObject | FluidObject): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.chain(fetchImgixBase64Url(cache)),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLInt,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FixedObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFixedArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFixed, DEFAULT_FIXED_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFixedTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFixedType = ({\n  name,\n  cache,\n}: CreateImgixFixedTypeArgs): GraphQLObjectType<FixedObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      width: { type: new GraphQLNonNull(GraphQLInt) },\n      height: { type: new GraphQLNonNull(GraphQLInt) },\n    },\n  })\n\ninterface CreateImgixFixedFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FixedObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFixedFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFixedFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFixedArgs\n> => ({\n  type,\n  args: {\n    width: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FIXED_WIDTH,\n    },\n    height: {\n      type: GraphQLInt,\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFixedArgs,\n  ): Promise<FixedObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFixed({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFixedSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFixedFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFixedArgs> =>\n  createImgixFixedFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFixedArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FluidObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFluidArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFluid, DEFAULT_FLUID_MAX_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFluidTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFluidType = ({\n  name,\n  cache,\n}: CreateImgixFluidTypeArgs): GraphQLObjectType<FluidObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      aspectRatio: { type: new GraphQLNonNull(GraphQLFloat) },\n    },\n  })\n\ninterface CreateImgixFluidFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FluidObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFluidFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFluidFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFluidArgs\n> => ({\n  type,\n  args: {\n    maxWidth: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FLUID_MAX_WIDTH,\n    },\n    maxHeight: {\n      type: GraphQLInt,\n    },\n    srcSetBreakpoints: {\n      type: new GraphQLList(GraphQLInt),\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFluidArgs,\n  ): Promise<FluidObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFluid({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFluidSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFluidFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFluidArgs> =>\n  createImgixFluidFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFluidArgs\n  >\n"],"names":["invariant","condition","msg","reporter","panic","ImgixSourceType","noop","transformUrlForWebProxy","url","domain","instance","URL","pathname","encodeURIComponent","toString","ns","namespace","str","getFromCacheOr","key","cache","f","pipe","get","then","value","O","getFromCache","TE","flow","set","setToCache","x","fetch","_fetch","reason","Error","String","semigroupImgixUrlParams","res","buffer","getObjectSemigroup","join","separator","arr","taskEitherFromSourceDataResolver","resolver","predicate","source","Promise","resolve","data","reject","FIXED_RESOLUTIONS","FLUID_BREAKPOINT_FACTORS","DEFAULT_LQIP_PARAMS","w","blur","q","buildImgixUrl","secureUrlToken","params","R","param","undefined","y","product","u","undefParams","acc","A","defParams","mergedParams","searchParams","URLSearchParams","forEach","_","includes","search","setURLSearchParams","token","md5","createURLSignature","append","signURL","buildImgixLqipUrl","concat","ImgixUrlParamsInputType","GraphQLInputObjectType","name","fields","Object","keys","imgixUrlParameters","parameters","reduce","spec","camelCase","expectsTypes","Array","from","Set","expects","map","expect","type","every","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLString","description","short_description","slice","aliases","sequenceTTE","sequenceT","resolveDimensions","resolveWidth","resolveHeight","fm","json","fetchJSON","fetchImgixMetadata","PixelWidth","PixelHeight","createImgixUrlSchemaFieldConfig","args","resolveUrl","defaultImgixParams","imgixParams","defaultValue","obj","T","createImgixBase64UrlFieldConfig","base64","GraphQLNonNull","contentType","buildBase64URL","headers","fetchImgixBase64Url","createImgixFixedSchemaFieldConfig","defaultPlaceholderImgixParams","width","height","placeholderImgixParams","aspectRatio","sourceWidth","sourceHeight","Math","round","src","h","srcSet","baseUrl","dpr","buildImgixFixedSrcSet","srcWebp","srcSetWebp","buildImgixFixed","createImgixFluidSchemaFieldConfig","maxWidth","maxHeight","srcSetBreakpoints","GraphQLList","eqNumber","ordNumber","breakpoint","buildImgixFluidSrcSet","sizes","buildImgixFluid","gatsbyContext","pluginOptions","schema","createTypes","actions","sourceType","isArray","WebProxy","Boolean","ImgixFixedType","GraphQLObjectType","ImgixFluidType","createImgixFluidType","ImgixImageType","buildObjectType","fixed","fluid","fieldTypes","fieldOptions","nodeType","fieldName","config","node","createNodeField","filter","internal","length","field","fieldValue","getUrl","getUrls","program","store","getState","fs","copyFileSync","path","__dirname","directory"],"mappings":"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"}