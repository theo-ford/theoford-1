{"version":3,"file":"gatsby-node.modern.js","sources":["../src/utils.ts","../src/builders.ts","../src/shared.ts","../src/createImgixBase64FieldConfig.ts","../src/createImgixFixedFieldConfig.ts","../src/createImgixFluidFieldConfig.ts","../src/gatsby-node.ts","../src/createImgixUrlFieldConfig.ts"],"sourcesContent":["import _fetch, { Response } from 'node-fetch'\nimport { GatsbyCache, Reporter } from 'gatsby'\nimport md5 from 'md5'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { Option } from 'fp-ts/lib/Option'\nimport { Semigroup, getObjectSemigroup } from 'fp-ts/lib/Semigroup'\nimport { Task } from 'fp-ts/lib/Task'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { flow } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams } from './types'\nimport { ImgixSourceDataResolver } from './shared'\n\nexport type Maybe<T> = T | undefined\nexport type Nullable<T> = Maybe<T | null>\nexport type OptionalPromise<T> = T | Promise<T>\n\nexport function invariant(\n  condition: unknown,\n  msg: string,\n  reporter: Reporter,\n): asserts condition {\n  if (!condition) reporter.panic(`Invariant failed: ${msg}`)\n}\n\nexport const noop = (): void => {\n  // noop\n}\n\nexport const transformUrlForWebProxy = (\n  url: string,\n  domain: string,\n): string => {\n  const instance = new URL(`https://${domain}`)\n  instance.pathname = encodeURIComponent(url)\n  return instance.toString()\n}\n\nexport const ns = (namespace = '', str: string): string => `${namespace}${str}`\n\n// getFromCache :: Cache -> String -> Task Option String\nexport const getFromCache = <A>(\n  key: string,\n  cache: GatsbyCache,\n): Task<Option<A>> => (): Promise<Option<A>> =>\n  cache.get(key).then((value?: A) => O.fromNullable(value))\n\n// setToCache :: Cache -> String -> Task Option String\nexport const setToCache = <A>(key: string, cache: GatsbyCache) => (\n  value: A,\n): Task<A> => (): Promise<A> => cache.set(key, value).then(() => value)\n\n// getFromCacheOr :: Cache, () => TaskEither A B -> String -> TaskEither A B\nexport const getFromCacheOr = <A, B>(\n  key: string,\n  cache: GatsbyCache,\n  f: () => TE.TaskEither<A, B>,\n): TE.TaskEither<A, B> =>\n  pipe(\n    getFromCache<B>(key, cache),\n    TE.rightTask,\n    TE.chain(\n      O.fold(\n        flow(\n          f,\n          TE.chain(flow(setToCache(key, cache), (x) => TE.rightTask<A, B>(x))),\n        ),\n        TE.right,\n      ),\n    ),\n  )\n\n// fetch :: String -> TaskEither Error Response\nexport const fetch = (url: string): TaskEither<Error, Response> =>\n  TE.tryCatch(\n    () => _fetch(url),\n    (reason) => new Error(String(reason)),\n  )\n\n// fetchJSON :: String -> TaskEither Error String\nexport const fetchJSON = <A>(url: string): TaskEither<Error, A> =>\n  pipe(\n    url,\n    fetch,\n    TE.chain((res) => TE.rightTask(() => res.json())),\n  )\n\n// fetchBase64 :: String -> TaskEither Error String\nexport const fetchBase64 = flow(\n  fetch,\n  TE.chain((res) => TE.rightTask(() => res.buffer())),\n  TE.chain((res) => TE.right(res.toString('base64'))),\n)\n\nexport const setURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.set(key, String(value))\n  return u.toString()\n}\n\nexport const appendURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.append(key, String(value))\n  return u.toString()\n}\n\nexport const deleteURLSearchParam = (key: string) => (url: string): string => {\n  const u = new URL(url)\n  u.searchParams.delete(key)\n  return u.toString()\n}\n\nexport const semigroupImgixUrlParams = getObjectSemigroup<ImgixUrlParams>()\n\nconst semigroupURLSearchParams: Semigroup<URLSearchParams> = {\n  concat: (x, y) => {\n    const product = new URLSearchParams(x.toString())\n    y.forEach((value, key) => {\n      value === undefined || value === null\n        ? product.delete(key)\n        : product.set(key, value)\n    })\n    return product\n  },\n}\n\nexport const setURLSearchParams = <K extends string>(url: string) => (\n  params: Record<K, string | undefined>,\n): string => {\n  const u = new URL(url)\n\n  const undefParams: K[] = pipe(\n    params,\n    R.reduceWithIndex([] as K[], (key, acc, value) =>\n      value === undefined ? A.cons(key, acc) : acc,\n    ),\n  )\n  const defParams = pipe(\n    params,\n    R.filter((param) => param !== undefined),\n  ) as Record<K, string>\n\n  const mergedParams = semigroupURLSearchParams.concat(\n    u.searchParams,\n    new URLSearchParams(defParams),\n  )\n  mergedParams.forEach((_, key) => {\n    if (undefParams.includes(key as K)) mergedParams.delete(key)\n  })\n  u.search = mergedParams.toString()\n\n  return u.toString()\n}\n\nexport const createURLSignature = (secureUrlToken: string) => (\n  url: string,\n): string =>\n  pipe(new URL(url), (u) => secureUrlToken + u.pathname + u.search, md5)\n\nexport const buildBase64URL = (contentType: string, base64: string): string =>\n  `data:${contentType};base64,${base64}`\n\nexport const signURL = (secureUrlToken: Option<string>) => (\n  url: string,\n): string =>\n  pipe(\n    secureUrlToken,\n    O.fold(\n      () => url,\n      (token) =>\n        pipe(\n          url,\n          deleteURLSearchParam('s'),\n          appendURLSearchParam('s', createURLSignature(token)(url)),\n        ),\n    ),\n  )\n\nexport const join = <A>(separator?: string) => (arr: A[]): string =>\n  arr.join(separator)\n\nexport const taskEitherFromSourceDataResolver = <TSource, TData>(\n  resolver: ImgixSourceDataResolver<TSource, TData>,\n  predicate?: (data: TData | null) => boolean,\n) => (source: TSource): TaskEither<Error, TData> =>\n  TE.tryCatch(\n    () =>\n      Promise.resolve(resolver(source)).then((data) => {\n        if (data === undefined || data === null)\n          return Promise.reject('Resolved data is null or undefined')\n\n        if (!predicate) return data\n\n        return predicate(data)\n          ? data\n          : Promise.reject('Resolved data is invalid.')\n      }),\n    (reason) => new Error(String(reason)),\n  )\n","import { FixedObject, FluidObject } from 'gatsby-image'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport { eqNumber } from 'fp-ts/lib/Eq'\nimport { ordNumber } from 'fp-ts/lib/Ord'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams, ImgixFixedArgs, ImgixFluidArgs } from './types'\nimport {\n  setURLSearchParams,\n  signURL,\n  semigroupImgixUrlParams,\n  join,\n} from './utils'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\n\n// Resolutions for `fixed` images. Same as `gatsby-plugin-sharp`.\nconst FIXED_RESOLUTIONS = [1, 1.5, 2]\n\n// Breakpoint factors for `fluid` images. Same as `gatsby-plugin-sharp`.\nconst FLUID_BREAKPOINT_FACTORS = [0.25, 0.5, 1.5, 2]\n\n// Default params for placeholder images.\nconst DEFAULT_LQIP_PARAMS: ImgixUrlParams = { w: 100, blur: 15, q: 20 }\n\nexport const buildImgixUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    params,\n    // TODO: Replace filterMap with map. filterMap is being used here just\n    // because it fibs the types a bit.\n    R.filterMap((param) =>\n      param === undefined ? O.some(undefined) : O.some(String(param)),\n    ),\n    setURLSearchParams(url),\n    signURL(O.fromNullable(secureUrlToken)),\n  )\n\nconst buildImgixLqipUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    semigroupImgixUrlParams.concat(DEFAULT_LQIP_PARAMS, params),\n    buildImgixUrl(url, secureUrlToken),\n  )\n\nconst buildImgixFixedSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    FIXED_RESOLUTIONS,\n    A.map((dpr) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, { dpr }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${dpr}x`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFixedArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFixedArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fixed image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fixed image object.\n */\nexport const buildImgixFixed = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFixedArgs): FixedObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n\n  let width: number\n  let height: number\n\n  if (args.width != undefined && args.height != undefined) {\n    width = args.width\n    height = args.height\n  } else if (args.width != undefined) {\n    width = args.width\n    height = Math.round(width / aspectRatio)\n  } else if (args.height != undefined) {\n    width = Math.round(args.height * aspectRatio)\n    height = args.height\n  } else {\n    width = DEFAULT_FIXED_WIDTH\n    height = Math.round(width / aspectRatio)\n  }\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  const srcSet = buildImgixFixedSrcSet(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  return {\n    base64,\n    width,\n    height,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n  }\n}\n\ntype BuildFluidSrcSetArgs = {\n  aspectRatio: number\n  maxWidth: number\n  srcSetBreakpoints?: number[]\n}\n\nconst buildImgixFluidSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n) => ({\n  aspectRatio,\n  maxWidth,\n  srcSetBreakpoints = FLUID_BREAKPOINT_FACTORS.map((x) => maxWidth * x),\n}: BuildFluidSrcSetArgs): string =>\n  pipe(\n    A.cons(maxWidth, srcSetBreakpoints),\n    A.uniq(eqNumber),\n    A.sort(ordNumber),\n    A.map((breakpoint) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, {\n          w: Math.round(breakpoint),\n          h: Math.round(breakpoint / aspectRatio),\n        }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${Math.round(breakpoint)}w`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFluidArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFluidArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fluid image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fluid image object.\n */\nexport const buildImgixFluid = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFluidArgs): FluidObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n  const maxWidth = args.maxWidth ?? DEFAULT_FLUID_MAX_WIDTH\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: maxWidth,\n    h: args.maxHeight,\n  })\n\n  const srcSet = buildImgixFluidSrcSet(\n    url,\n    secureUrlToken,\n  )(args.imgixParams ?? {})({\n    aspectRatio,\n    maxWidth: maxWidth,\n    srcSetBreakpoints: args.srcSetBreakpoints,\n  })\n\n  return {\n    base64,\n    aspectRatio,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n    sizes: '',\n  }\n}\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLInputObjectType,\n  GraphQLInputFieldConfigMap,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLString,\n  GraphQLBoolean,\n} from 'gatsby/graphql'\nimport imgixUrlParameters from 'imgix-url-params/dist/parameters.json'\nimport { camelCase } from 'camel-case'\n// import * as E from 'fp-ts/lib/Either'\nimport * as TE from 'fp-ts/lib/TaskEither'\n// import { Either } from 'fp-ts/lib/Either'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport { sequenceT } from 'fp-ts/lib/Apply'\n\nimport { ImgixMetadata } from './types'\nimport { buildImgixUrl } from './builders'\nimport {\n  getFromCacheOr,\n  fetchJSON,\n  taskEitherFromSourceDataResolver,\n  fetch,\n  buildBase64URL,\n} from './utils'\n\nexport const ImgixUrlParamsInputType = new GraphQLInputObjectType({\n  name: 'ImgixUrlParamsInput',\n  fields: Object.keys(imgixUrlParameters.parameters).reduce((fields, param) => {\n    const spec =\n      imgixUrlParameters.parameters[\n        param as keyof typeof imgixUrlParameters.parameters\n      ]\n\n    // The param name is camel-cased here to appease the GraphQL field\n    // requirements. This will need to be reversed with param-case when the\n    // URL is constructed in `buildImgixUrl`.\n    const name = camelCase(param)\n\n    const expects = spec.expects as { type: string }[]\n    const expectsTypes = Array.from(\n      new Set(expects.map((expect) => expect.type)),\n    )\n\n    // TODO: Clean up this mess.\n    const type = expectsTypes.every(\n      (type) => type === 'integer' || type === 'unit_scalar',\n    )\n      ? GraphQLInt\n      : expectsTypes.every(\n          (type) =>\n            type === 'integer' || type === 'unit_scalar' || type === 'number',\n        )\n      ? GraphQLFloat\n      : expectsTypes.every((type) => type === 'boolean')\n      ? GraphQLBoolean\n      : GraphQLString\n\n    fields[name] = {\n      type,\n      description:\n        spec.short_description +\n        // Ensure the description ends with a period.\n        (spec.short_description.slice(-1) === '.' ? '' : '.'),\n    }\n\n    // Add the default value as part of the description. Setting it as a\n    // GraphQL default value will automatically assign it in the final URL.\n    // Doing so would result in a huge number of unwanted params.\n    if ('default' in spec)\n      fields[name].description =\n        fields[name].description + ` Default: \\`${spec.default}\\`.`\n\n    // Add Imgix documentation URL as part of the description.\n    if ('url' in spec)\n      fields[name].description =\n        fields[name].description + ` [See docs](${spec.url}).`\n\n    // Create aliased fields.\n    if ('aliases' in spec)\n      for (const alias of spec.aliases)\n        fields[camelCase(alias)] = {\n          ...fields[name],\n          description: `Alias for \\`${name}\\`.`,\n        }\n\n    return fields\n  }, {} as GraphQLInputFieldConfigMap),\n})\n\nexport type ImgixSourceDataResolver<TSource, TData> = (\n  obj: TSource,\n) => TData | null | undefined | void | Promise<TData | null | undefined | void>\n\nexport const fetchImgixMetadata = (\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TE.TaskEither<Error, ImgixMetadata> =>\n  getFromCacheOr(`gatsby-plugin-imgix-metadata-${url}`, cache, () =>\n    pipe({ fm: 'json' }, buildImgixUrl(url, secureUrlToken), (u) =>\n      fetchJSON(u),\n    ),\n  )\n\nexport const fetchImgixBase64Url = (cache: GatsbyCache) => (\n  url: string,\n): TE.TaskEither<Error, string> =>\n  getFromCacheOr(`gatsby-plugin-imgix-base64-url-${url}`, cache, () =>\n    pipe(\n      url,\n      fetch,\n      TE.chain((res) =>\n        pipe(\n          TE.rightTask<Error, Buffer>(() => res.buffer()),\n          TE.chain((buffer) => TE.right(buffer.toString('base64'))),\n          TE.chain((base64) =>\n            TE.right(\n              buildBase64URL(String(res.headers.get('content-type')), base64),\n            ),\n          ),\n        ),\n      ),\n    ),\n  )\n\nconst sequenceTTE = sequenceT(TE.taskEither)\n\nexport const resolveDimensions = <TSource>(\n  source: TSource,\n  resolveWidth: ImgixSourceDataResolver<TSource, number>,\n  resolveHeight: ImgixSourceDataResolver<TSource, number>,\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TaskEither<Error, [number, number]> =>\n  pipe(\n    sequenceTTE(\n      taskEitherFromSourceDataResolver(resolveWidth)(source),\n      taskEitherFromSourceDataResolver(resolveHeight)(source),\n    ),\n    TE.fold(\n      () =>\n        pipe(\n          url,\n          fetchImgixMetadata(cache, secureUrlToken),\n          TE.map(\n            ({ PixelWidth, PixelHeight }) =>\n              [PixelWidth, PixelHeight] as [number, number],\n          ),\n        ),\n      TE.right,\n    ),\n  )\n\n// export const aspectRatio = (\n//   width: number,\n//   height: number,\n// ): Either<Error, number> =>\n//   height === 0\n//     ? E.left(new Error('Height cannot be 0'))\n//     : E.right(width / height)\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLFieldConfig,\n} from 'gatsby/graphql'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { fetchImgixBase64Url, ImgixSourceDataResolver } from './shared'\nimport { taskEitherFromSourceDataResolver } from './utils'\n\ninterface CreateImgixBase64UrlFieldConfigArgs {\n  resolveUrl?: ImgixSourceDataResolver<FixedObject | FluidObject, string>\n  cache: GatsbyCache\n}\n\nexport const createImgixBase64UrlFieldConfig = <TContext>({\n  resolveUrl = (obj: FixedObject | FluidObject): string | null | undefined =>\n    obj.base64,\n  cache,\n}: CreateImgixBase64UrlFieldConfigArgs): GraphQLFieldConfig<\n  FixedObject | FluidObject,\n  TContext\n> => ({\n  type: new GraphQLNonNull(GraphQLString),\n  resolve: (obj: FixedObject | FluidObject): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.chain(fetchImgixBase64Url(cache)),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLInt,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FixedObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFixedArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFixed, DEFAULT_FIXED_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFixedTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFixedType = ({\n  name,\n  cache,\n}: CreateImgixFixedTypeArgs): GraphQLObjectType<FixedObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      width: { type: new GraphQLNonNull(GraphQLInt) },\n      height: { type: new GraphQLNonNull(GraphQLInt) },\n    },\n  })\n\ninterface CreateImgixFixedFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FixedObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFixedFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFixedFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFixedArgs\n> => ({\n  type,\n  args: {\n    width: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FIXED_WIDTH,\n    },\n    height: {\n      type: GraphQLInt,\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFixedArgs,\n  ): Promise<FixedObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFixed({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFixedSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFixedFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFixedArgs> =>\n  createImgixFixedFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFixedArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FluidObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFluidArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFluid, DEFAULT_FLUID_MAX_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFluidTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFluidType = ({\n  name,\n  cache,\n}: CreateImgixFluidTypeArgs): GraphQLObjectType<FluidObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      aspectRatio: { type: new GraphQLNonNull(GraphQLFloat) },\n    },\n  })\n\ninterface CreateImgixFluidFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FluidObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFluidFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFluidFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFluidArgs\n> => ({\n  type,\n  args: {\n    maxWidth: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FLUID_MAX_WIDTH,\n    },\n    maxHeight: {\n      type: GraphQLInt,\n    },\n    srcSetBreakpoints: {\n      type: new GraphQLList(GraphQLInt),\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFluidArgs,\n  ): Promise<FluidObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFluid({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFluidSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFluidFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFluidArgs> =>\n  createImgixFluidFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFluidArgs\n  >\n","import fs from 'fs'\nimport path from 'path'\nimport {\n  GatsbyNode,\n  CreateSchemaCustomizationArgs,\n  Node,\n  PluginOptions as GatsbyPluginOptions,\n} from 'gatsby'\n\nimport { createImgixUrlSchemaFieldConfig } from './createImgixUrlFieldConfig'\nimport {\n  createImgixFixedSchemaFieldConfig,\n  createImgixFixedType,\n} from './createImgixFixedFieldConfig'\nimport {\n  createImgixFluidSchemaFieldConfig,\n  createImgixFluidType,\n} from './createImgixFluidFieldConfig'\nimport { invariant, transformUrlForWebProxy, ns } from './utils'\nimport { ImgixUrlParams } from './types'\n\nenum ImgixSourceType {\n  AmazonS3 = 's3',\n  GoogleCloudStorange = 'gcs',\n  MicrosoftAzure = 'azure',\n  WebFolder = 'webFolder',\n  WebProxy = 'webProxy',\n}\n\ninterface BaseFieldOptions {\n  nodeType: string\n  fieldName: string\n}\n\ninterface FieldOptionsSingleUrl extends BaseFieldOptions {\n  getUrl: (node: Node) => string\n}\n\ninterface FieldOptionsMultipleUrls extends BaseFieldOptions {\n  getUrls: (node: Node) => string\n}\n\ntype FieldOptions = FieldOptionsSingleUrl | FieldOptionsMultipleUrls\n\ninterface PluginOptions extends GatsbyPluginOptions {\n  domain?: string\n  secureUrlToken?: string\n  sourceType?: ImgixSourceType\n  namespace?: string\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n  fields?: FieldOptions[]\n}\n\nexport const onCreateNode: GatsbyNode['onCreateNode'] = async (\n  gatsbyContext,\n  pluginOptions: PluginOptions,\n) => {\n  const { node, actions, reporter } = gatsbyContext\n  const { createNodeField } = actions\n\n  const { domain, secureUrlToken, sourceType, fields = [] } = pluginOptions\n  invariant(\n    Array.isArray(fields),\n    'fields must be an array of field options',\n    reporter,\n  )\n\n  const fieldOptions = fields.filter(\n    (fieldOptions) => fieldOptions.nodeType === node.internal.type,\n  )\n  if (fieldOptions.length < 1) return\n\n  for (const field of fieldOptions) {\n    let fieldValue = undefined as string | string[] | undefined\n\n    if ('getUrl' in field) {\n      fieldValue = field.getUrl(node)\n      invariant(\n        fieldValue === undefined ||\n          fieldValue === null ||\n          typeof fieldValue === 'string',\n        'getUrl must return a URL string',\n        reporter,\n      )\n    } else if ('getUrls' in field) {\n      fieldValue = field.getUrls(node)\n      invariant(\n        Array.isArray(fieldValue),\n        'getUrls must return an array of URLs',\n        reporter,\n      )\n    }\n\n    if (!fieldValue) continue\n\n    if (sourceType === ImgixSourceType.WebProxy) {\n      invariant(\n        domain !== undefined,\n        'an Imgix domain must be provided if sourceType is webProxy',\n        reporter,\n      )\n      invariant(\n        secureUrlToken !== undefined,\n        'a secure URL token must be provided if sourceType is webProxy',\n        reporter,\n      )\n\n      if (Array.isArray(fieldValue))\n        fieldValue = fieldValue.map((url) =>\n          transformUrlForWebProxy(url, domain),\n        )\n      else fieldValue = transformUrlForWebProxy(fieldValue, domain)\n    }\n\n    createNodeField({ node, name: field.fieldName, value: fieldValue })\n  }\n}\n\nexport const createSchemaCustomization: GatsbyNode['createSchemaCustomization'] = async (\n  gatsbyContext: CreateSchemaCustomizationArgs,\n  pluginOptions: PluginOptions,\n) => {\n  const { actions, cache, schema, reporter } = gatsbyContext\n  const { createTypes } = actions\n\n  const {\n    secureUrlToken,\n    sourceType,\n    namespace,\n    defaultImgixParams,\n    defaultPlaceholderImgixParams,\n    fields = [],\n  } = pluginOptions\n  invariant(\n    Array.isArray(fields),\n    'fields must be an array of field options',\n    reporter,\n  )\n  invariant(\n    sourceType !== ImgixSourceType.WebProxy || Boolean(secureUrlToken),\n    'a secure URL token must be provided if sourceType is webProxy',\n    reporter,\n  )\n\n  const ImgixFixedType = createImgixFixedType({\n    name: ns(namespace, 'ImgixFixed'),\n    cache,\n  })\n\n  const ImgixFluidType = createImgixFluidType({\n    name: ns(namespace, 'ImgixFluid'),\n    cache,\n  })\n\n  const ImgixImageType = schema.buildObjectType({\n    name: ns(namespace, 'ImgixImage'),\n    fields: {\n      url: createImgixUrlSchemaFieldConfig({\n        resolveUrl: (url: string) => url,\n        secureUrlToken,\n        defaultImgixParams,\n      }),\n      fixed: createImgixFixedSchemaFieldConfig({\n        type: ImgixFixedType,\n        resolveUrl: (url: string) => url,\n        secureUrlToken,\n        defaultImgixParams,\n        defaultPlaceholderImgixParams,\n        cache,\n      }),\n      fluid: createImgixFluidSchemaFieldConfig({\n        type: ImgixFluidType,\n        resolveUrl: (url: string) => url,\n        secureUrlToken: secureUrlToken,\n        defaultImgixParams,\n        defaultPlaceholderImgixParams,\n        cache,\n      }),\n    },\n  })\n\n  const fieldTypes = fields.map((fieldOptions) =>\n    schema.buildObjectType({\n      name: `${fieldOptions.nodeType}Fields`,\n      fields: {\n        [fieldOptions.fieldName]: {\n          type:\n            'getUrls' in fieldOptions\n              ? `[${ImgixImageType.config.name}]`\n              : ImgixImageType.config.name,\n        },\n      },\n    }),\n  )\n\n  createTypes([ImgixFixedType, ImgixFluidType])\n  createTypes(ImgixImageType)\n  createTypes(fieldTypes)\n}\n\nexport const onPreExtractQueries: GatsbyNode['onPreExtractQueries'] = (\n  gatsbyContext,\n) => {\n  const { store } = gatsbyContext\n  const { program } = store.getState()\n\n  // Add fragments for GatsbyImgixImage to .cache/fragments.\n  fs.copyFileSync(\n    path.resolve(__dirname, '../fragments.js'),\n    path.resolve(\n      program.directory,\n      '.cache/fragments/gatsby-plugin-imgix-fragments.js',\n    ),\n  )\n}\n","import { GraphQLFieldConfig, GraphQLString } from 'gatsby/graphql'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { buildImgixUrl } from './builders'\nimport { ImgixSourceDataResolver, ImgixUrlParamsInputType } from './shared'\nimport { ImgixUrlParams } from './types'\nimport {\n  taskEitherFromSourceDataResolver,\n  semigroupImgixUrlParams,\n} from './utils'\n\nexport interface ImgixUrlArgs {\n  imgixParams?: ImgixUrlParams\n}\n\ninterface CreateImgixUrlFieldConfigArgs<TSource> {\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  secureUrlToken?: string\n  defaultImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixUrlFieldConfig = <TSource, TContext>({\n  resolveUrl,\n  secureUrlToken,\n  defaultImgixParams = {},\n}: CreateImgixUrlFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixUrlArgs\n> => ({\n  type: GraphQLString,\n  args: {\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (obj: TSource, args: ImgixUrlArgs): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.map((url) =>\n        pipe(\n          semigroupImgixUrlParams.concat(\n            defaultImgixParams,\n            args.imgixParams ?? {},\n          ),\n          buildImgixUrl(url, secureUrlToken),\n        ),\n      ),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n\nexport const createImgixUrlSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixUrlFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixUrlArgs> =>\n  createImgixUrlFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixUrlArgs\n  >\n"],"names":["invariant","condition","msg","reporter","panic","noop","transformUrlForWebProxy","url","domain","instance","URL","pathname","encodeURIComponent","toString","ns","namespace","str","getFromCacheOr","key","cache","f","pipe","get","then","value","O","getFromCache","TE","flow","set","setToCache","x","fetch","_fetch","reason","Error","String","semigroupImgixUrlParams","res","buffer","getObjectSemigroup","join","separator","arr","taskEitherFromSourceDataResolver","resolver","predicate","source","Promise","resolve","data","reject","FIXED_RESOLUTIONS","FLUID_BREAKPOINT_FACTORS","DEFAULT_LQIP_PARAMS","w","blur","q","buildImgixUrl","secureUrlToken","params","R","param","undefined","u","undefParams","acc","A","defParams","mergedParams","y","product","URLSearchParams","forEach","delete","semigroupURLSearchParams","searchParams","_","includes","search","setURLSearchParams","token","md5","createURLSignature","append","signURL","buildImgixLqipUrl","concat","ImgixUrlParamsInputType","GraphQLInputObjectType","name","fields","Object","keys","imgixUrlParameters","parameters","reduce","spec","camelCase","expectsTypes","Array","from","Set","expects","map","expect","type","every","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLString","description","short_description","slice","default","alias","aliases","sequenceTTE","sequenceT","resolveDimensions","resolveWidth","resolveHeight","fm","json","fetchJSON","fetchImgixMetadata","PixelWidth","PixelHeight","createImgixBase64UrlFieldConfig","resolveUrl","obj","base64","GraphQLNonNull","contentType","buildBase64URL","headers","fetchImgixBase64Url","T","createImgixFixedSchemaFieldConfig","args","defaultImgixParams","defaultPlaceholderImgixParams","width","defaultValue","height","imgixParams","placeholderImgixParams","sourceWidth","sourceHeight","aspectRatio","Math","round","src","h","srcSet","baseUrl","dpr","buildImgixFixedSrcSet","srcWebp","srcSetWebp","buildImgixFixed","createImgixFixedFieldConfig","createImgixFluidSchemaFieldConfig","maxWidth","maxHeight","srcSetBreakpoints","GraphQLList","eqNumber","ordNumber","breakpoint","buildImgixFluidSrcSet","sizes","buildImgixFluid","createImgixFluidFieldConfig","ImgixSourceType","onCreateNode","async","gatsbyContext","pluginOptions","node","actions","createNodeField","sourceType","isArray","fieldOptions","filter","nodeType","internal","length","field","fieldValue","getUrl","getUrls","WebProxy","fieldName","createSchemaCustomization","schema","createTypes","Boolean","ImgixFixedType","GraphQLObjectType","createImgixFixedType","ImgixFluidType","createImgixFluidType","ImgixImageType","buildObjectType","createImgixUrlFieldConfig","fixed","fluid","fieldTypes","[object Object]","config","onPreExtractQueries","store","program","getState","fs","copyFileSync","path","__dirname","directory"],"mappings":"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"}