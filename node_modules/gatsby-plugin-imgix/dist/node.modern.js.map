{"version":3,"file":"node.modern.js","sources":["../src/utils.ts","../src/builders.ts","../src/shared.ts","../src/createImgixUrlFieldConfig.ts","../src/createImgixBase64FieldConfig.ts","../src/createImgixFixedFieldConfig.ts","../src/createImgixFluidFieldConfig.ts"],"sourcesContent":["import _fetch, { Response } from 'node-fetch'\nimport { GatsbyCache, Reporter } from 'gatsby'\nimport md5 from 'md5'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { Option } from 'fp-ts/lib/Option'\nimport { Semigroup, getObjectSemigroup } from 'fp-ts/lib/Semigroup'\nimport { Task } from 'fp-ts/lib/Task'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { flow } from 'fp-ts/lib/function'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams } from './types'\nimport { ImgixSourceDataResolver } from './shared'\n\nexport type Maybe<T> = T | undefined\nexport type Nullable<T> = Maybe<T | null>\nexport type OptionalPromise<T> = T | Promise<T>\n\nexport function invariant(\n  condition: unknown,\n  msg: string,\n  reporter: Reporter,\n): asserts condition {\n  if (!condition) reporter.panic(`Invariant failed: ${msg}`)\n}\n\nexport const noop = (): void => {\n  // noop\n}\n\nexport const transformUrlForWebProxy = (\n  url: string,\n  domain: string,\n): string => {\n  const instance = new URL(`https://${domain}`)\n  instance.pathname = encodeURIComponent(url)\n  return instance.toString()\n}\n\nexport const ns = (namespace = '', str: string): string => `${namespace}${str}`\n\n// getFromCache :: Cache -> String -> Task Option String\nexport const getFromCache = <A>(\n  key: string,\n  cache: GatsbyCache,\n): Task<Option<A>> => (): Promise<Option<A>> =>\n  cache.get(key).then((value?: A) => O.fromNullable(value))\n\n// setToCache :: Cache -> String -> Task Option String\nexport const setToCache = <A>(key: string, cache: GatsbyCache) => (\n  value: A,\n): Task<A> => (): Promise<A> => cache.set(key, value).then(() => value)\n\n// getFromCacheOr :: Cache, () => TaskEither A B -> String -> TaskEither A B\nexport const getFromCacheOr = <A, B>(\n  key: string,\n  cache: GatsbyCache,\n  f: () => TE.TaskEither<A, B>,\n): TE.TaskEither<A, B> =>\n  pipe(\n    getFromCache<B>(key, cache),\n    TE.rightTask,\n    TE.chain(\n      O.fold(\n        flow(\n          f,\n          TE.chain(flow(setToCache(key, cache), (x) => TE.rightTask<A, B>(x))),\n        ),\n        TE.right,\n      ),\n    ),\n  )\n\n// fetch :: String -> TaskEither Error Response\nexport const fetch = (url: string): TaskEither<Error, Response> =>\n  TE.tryCatch(\n    () => _fetch(url),\n    (reason) => new Error(String(reason)),\n  )\n\n// fetchJSON :: String -> TaskEither Error String\nexport const fetchJSON = <A>(url: string): TaskEither<Error, A> =>\n  pipe(\n    url,\n    fetch,\n    TE.chain((res) => TE.rightTask(() => res.json())),\n  )\n\n// fetchBase64 :: String -> TaskEither Error String\nexport const fetchBase64 = flow(\n  fetch,\n  TE.chain((res) => TE.rightTask(() => res.buffer())),\n  TE.chain((res) => TE.right(res.toString('base64'))),\n)\n\nexport const setURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.set(key, String(value))\n  return u.toString()\n}\n\nexport const appendURLSearchParam = (key: string, value: string | number) => (\n  url: string,\n): string => {\n  const u = new URL(url)\n  u.searchParams.append(key, String(value))\n  return u.toString()\n}\n\nexport const deleteURLSearchParam = (key: string) => (url: string): string => {\n  const u = new URL(url)\n  u.searchParams.delete(key)\n  return u.toString()\n}\n\nexport const semigroupImgixUrlParams = getObjectSemigroup<ImgixUrlParams>()\n\nconst semigroupURLSearchParams: Semigroup<URLSearchParams> = {\n  concat: (x, y) => {\n    const product = new URLSearchParams(x.toString())\n    y.forEach((value, key) => {\n      value === undefined || value === null\n        ? product.delete(key)\n        : product.set(key, value)\n    })\n    return product\n  },\n}\n\nexport const setURLSearchParams = <K extends string>(url: string) => (\n  params: Record<K, string | undefined>,\n): string => {\n  const u = new URL(url)\n\n  const undefParams: K[] = pipe(\n    params,\n    R.reduceWithIndex([] as K[], (key, acc, value) =>\n      value === undefined ? A.cons(key, acc) : acc,\n    ),\n  )\n  const defParams = pipe(\n    params,\n    R.filter((param) => param !== undefined),\n  ) as Record<K, string>\n\n  const mergedParams = semigroupURLSearchParams.concat(\n    u.searchParams,\n    new URLSearchParams(defParams),\n  )\n  mergedParams.forEach((_, key) => {\n    if (undefParams.includes(key as K)) mergedParams.delete(key)\n  })\n  u.search = mergedParams.toString()\n\n  return u.toString()\n}\n\nexport const createURLSignature = (secureUrlToken: string) => (\n  url: string,\n): string =>\n  pipe(new URL(url), (u) => secureUrlToken + u.pathname + u.search, md5)\n\nexport const buildBase64URL = (contentType: string, base64: string): string =>\n  `data:${contentType};base64,${base64}`\n\nexport const signURL = (secureUrlToken: Option<string>) => (\n  url: string,\n): string =>\n  pipe(\n    secureUrlToken,\n    O.fold(\n      () => url,\n      (token) =>\n        pipe(\n          url,\n          deleteURLSearchParam('s'),\n          appendURLSearchParam('s', createURLSignature(token)(url)),\n        ),\n    ),\n  )\n\nexport const join = <A>(separator?: string) => (arr: A[]): string =>\n  arr.join(separator)\n\nexport const taskEitherFromSourceDataResolver = <TSource, TData>(\n  resolver: ImgixSourceDataResolver<TSource, TData>,\n  predicate?: (data: TData | null) => boolean,\n) => (source: TSource): TaskEither<Error, TData> =>\n  TE.tryCatch(\n    () =>\n      Promise.resolve(resolver(source)).then((data) => {\n        if (data === undefined || data === null)\n          return Promise.reject('Resolved data is null or undefined')\n\n        if (!predicate) return data\n\n        return predicate(data)\n          ? data\n          : Promise.reject('Resolved data is invalid.')\n      }),\n    (reason) => new Error(String(reason)),\n  )\n","import { FixedObject, FluidObject } from 'gatsby-image'\nimport * as A from 'fp-ts/lib/Array'\nimport * as O from 'fp-ts/lib/Option'\nimport * as R from 'fp-ts/lib/Record'\nimport { eqNumber } from 'fp-ts/lib/Eq'\nimport { ordNumber } from 'fp-ts/lib/Ord'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixUrlParams, ImgixFixedArgs, ImgixFluidArgs } from './types'\nimport {\n  setURLSearchParams,\n  signURL,\n  semigroupImgixUrlParams,\n  join,\n} from './utils'\n\nexport const DEFAULT_FIXED_WIDTH = 400\nexport const DEFAULT_FLUID_MAX_WIDTH = 800\n\n// Resolutions for `fixed` images. Same as `gatsby-plugin-sharp`.\nconst FIXED_RESOLUTIONS = [1, 1.5, 2]\n\n// Breakpoint factors for `fluid` images. Same as `gatsby-plugin-sharp`.\nconst FLUID_BREAKPOINT_FACTORS = [0.25, 0.5, 1.5, 2]\n\n// Default params for placeholder images.\nconst DEFAULT_LQIP_PARAMS: ImgixUrlParams = { w: 100, blur: 15, q: 20 }\n\nexport const buildImgixUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    params,\n    // TODO: Replace filterMap with map. filterMap is being used here just\n    // because it fibs the types a bit.\n    R.filterMap((param) =>\n      param === undefined ? O.some(undefined) : O.some(String(param)),\n    ),\n    setURLSearchParams(url),\n    signURL(O.fromNullable(secureUrlToken)),\n  )\n\nconst buildImgixLqipUrl = (url: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    semigroupImgixUrlParams.concat(DEFAULT_LQIP_PARAMS, params),\n    buildImgixUrl(url, secureUrlToken),\n  )\n\nconst buildImgixFixedSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n): string =>\n  pipe(\n    FIXED_RESOLUTIONS,\n    A.map((dpr) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, { dpr }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${dpr}x`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFixedArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFixedArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fixed image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fixed image object.\n */\nexport const buildImgixFixed = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFixedArgs): FixedObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n\n  let width: number\n  let height: number\n\n  if (args.width != undefined && args.height != undefined) {\n    width = args.width\n    height = args.height\n  } else if (args.width != undefined) {\n    width = args.width\n    height = Math.round(width / aspectRatio)\n  } else if (args.height != undefined) {\n    width = Math.round(args.height * aspectRatio)\n    height = args.height\n  } else {\n    width = DEFAULT_FIXED_WIDTH\n    height = Math.round(width / aspectRatio)\n  }\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  const srcSet = buildImgixFixedSrcSet(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: width,\n    h: height,\n  })\n\n  return {\n    base64,\n    width,\n    height,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n  }\n}\n\ntype BuildFluidSrcSetArgs = {\n  aspectRatio: number\n  maxWidth: number\n  srcSetBreakpoints?: number[]\n}\n\nconst buildImgixFluidSrcSet = (baseUrl: string, secureUrlToken?: string) => (\n  params: ImgixUrlParams,\n) => ({\n  aspectRatio,\n  maxWidth,\n  srcSetBreakpoints = FLUID_BREAKPOINT_FACTORS.map((x) => maxWidth * x),\n}: BuildFluidSrcSetArgs): string =>\n  pipe(\n    A.cons(maxWidth, srcSetBreakpoints),\n    A.uniq(eqNumber),\n    A.sort(ordNumber),\n    A.map((breakpoint) =>\n      pipe(\n        semigroupImgixUrlParams.concat(params, {\n          w: Math.round(breakpoint),\n          h: Math.round(breakpoint / aspectRatio),\n        }),\n        buildImgixUrl(baseUrl, secureUrlToken),\n        (url) => `${url} ${Math.round(breakpoint)}w`,\n      ),\n    ),\n    join(', '),\n  )\n\ntype BuildImgixFluidArgs = {\n  url: string\n  sourceWidth: number\n  sourceHeight: number\n  secureUrlToken?: string\n  args?: ImgixFluidArgs\n}\n\n/**\n * Builds a gatsby-image-compatible fluid image object from a base Imgix image URL.\n *\n * @returns gatsby-image-compatible fluid image object.\n */\nexport const buildImgixFluid = ({\n  url,\n  sourceWidth,\n  sourceHeight,\n  secureUrlToken,\n  args = {},\n}: BuildImgixFluidArgs): FluidObject => {\n  const aspectRatio = sourceWidth / sourceHeight\n  const maxWidth = args.maxWidth ?? DEFAULT_FLUID_MAX_WIDTH\n\n  const base64 = buildImgixLqipUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    ...args.placeholderImgixParams,\n  })\n\n  const src = buildImgixUrl(\n    url,\n    secureUrlToken,\n  )({\n    ...args.imgixParams,\n    w: maxWidth,\n    h: args.maxHeight,\n  })\n\n  const srcSet = buildImgixFluidSrcSet(\n    url,\n    secureUrlToken,\n  )(args.imgixParams ?? {})({\n    aspectRatio,\n    maxWidth: maxWidth,\n    srcSetBreakpoints: args.srcSetBreakpoints,\n  })\n\n  return {\n    base64,\n    aspectRatio,\n    src,\n    srcWebp: src,\n    srcSet,\n    srcSetWebp: srcSet,\n    sizes: '',\n  }\n}\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLInputObjectType,\n  GraphQLInputFieldConfigMap,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLString,\n  GraphQLBoolean,\n} from 'gatsby/graphql'\nimport imgixUrlParameters from 'imgix-url-params/dist/parameters.json'\nimport { camelCase } from 'camel-case'\n// import * as E from 'fp-ts/lib/Either'\nimport * as TE from 'fp-ts/lib/TaskEither'\n// import { Either } from 'fp-ts/lib/Either'\nimport { TaskEither } from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\nimport { sequenceT } from 'fp-ts/lib/Apply'\n\nimport { ImgixMetadata } from './types'\nimport { buildImgixUrl } from './builders'\nimport {\n  getFromCacheOr,\n  fetchJSON,\n  taskEitherFromSourceDataResolver,\n  fetch,\n  buildBase64URL,\n} from './utils'\n\nexport const ImgixUrlParamsInputType = new GraphQLInputObjectType({\n  name: 'ImgixUrlParamsInput',\n  fields: Object.keys(imgixUrlParameters.parameters).reduce((fields, param) => {\n    const spec =\n      imgixUrlParameters.parameters[\n        param as keyof typeof imgixUrlParameters.parameters\n      ]\n\n    // The param name is camel-cased here to appease the GraphQL field\n    // requirements. This will need to be reversed with param-case when the\n    // URL is constructed in `buildImgixUrl`.\n    const name = camelCase(param)\n\n    const expects = spec.expects as { type: string }[]\n    const expectsTypes = Array.from(\n      new Set(expects.map((expect) => expect.type)),\n    )\n\n    // TODO: Clean up this mess.\n    const type = expectsTypes.every(\n      (type) => type === 'integer' || type === 'unit_scalar',\n    )\n      ? GraphQLInt\n      : expectsTypes.every(\n          (type) =>\n            type === 'integer' || type === 'unit_scalar' || type === 'number',\n        )\n      ? GraphQLFloat\n      : expectsTypes.every((type) => type === 'boolean')\n      ? GraphQLBoolean\n      : GraphQLString\n\n    fields[name] = {\n      type,\n      description:\n        spec.short_description +\n        // Ensure the description ends with a period.\n        (spec.short_description.slice(-1) === '.' ? '' : '.'),\n    }\n\n    // Add the default value as part of the description. Setting it as a\n    // GraphQL default value will automatically assign it in the final URL.\n    // Doing so would result in a huge number of unwanted params.\n    if ('default' in spec)\n      fields[name].description =\n        fields[name].description + ` Default: \\`${spec.default}\\`.`\n\n    // Add Imgix documentation URL as part of the description.\n    if ('url' in spec)\n      fields[name].description =\n        fields[name].description + ` [See docs](${spec.url}).`\n\n    // Create aliased fields.\n    if ('aliases' in spec)\n      for (const alias of spec.aliases)\n        fields[camelCase(alias)] = {\n          ...fields[name],\n          description: `Alias for \\`${name}\\`.`,\n        }\n\n    return fields\n  }, {} as GraphQLInputFieldConfigMap),\n})\n\nexport type ImgixSourceDataResolver<TSource, TData> = (\n  obj: TSource,\n) => TData | null | undefined | void | Promise<TData | null | undefined | void>\n\nexport const fetchImgixMetadata = (\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TE.TaskEither<Error, ImgixMetadata> =>\n  getFromCacheOr(`gatsby-plugin-imgix-metadata-${url}`, cache, () =>\n    pipe({ fm: 'json' }, buildImgixUrl(url, secureUrlToken), (u) =>\n      fetchJSON(u),\n    ),\n  )\n\nexport const fetchImgixBase64Url = (cache: GatsbyCache) => (\n  url: string,\n): TE.TaskEither<Error, string> =>\n  getFromCacheOr(`gatsby-plugin-imgix-base64-url-${url}`, cache, () =>\n    pipe(\n      url,\n      fetch,\n      TE.chain((res) =>\n        pipe(\n          TE.rightTask<Error, Buffer>(() => res.buffer()),\n          TE.chain((buffer) => TE.right(buffer.toString('base64'))),\n          TE.chain((base64) =>\n            TE.right(\n              buildBase64URL(String(res.headers.get('content-type')), base64),\n            ),\n          ),\n        ),\n      ),\n    ),\n  )\n\nconst sequenceTTE = sequenceT(TE.taskEither)\n\nexport const resolveDimensions = <TSource>(\n  source: TSource,\n  resolveWidth: ImgixSourceDataResolver<TSource, number>,\n  resolveHeight: ImgixSourceDataResolver<TSource, number>,\n  cache: GatsbyCache,\n  secureUrlToken?: string,\n) => (url: string): TaskEither<Error, [number, number]> =>\n  pipe(\n    sequenceTTE(\n      taskEitherFromSourceDataResolver(resolveWidth)(source),\n      taskEitherFromSourceDataResolver(resolveHeight)(source),\n    ),\n    TE.fold(\n      () =>\n        pipe(\n          url,\n          fetchImgixMetadata(cache, secureUrlToken),\n          TE.map(\n            ({ PixelWidth, PixelHeight }) =>\n              [PixelWidth, PixelHeight] as [number, number],\n          ),\n        ),\n      TE.right,\n    ),\n  )\n\n// export const aspectRatio = (\n//   width: number,\n//   height: number,\n// ): Either<Error, number> =>\n//   height === 0\n//     ? E.left(new Error('Height cannot be 0'))\n//     : E.right(width / height)\n","import { GraphQLFieldConfig, GraphQLString } from 'gatsby/graphql'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { buildImgixUrl } from './builders'\nimport { ImgixSourceDataResolver, ImgixUrlParamsInputType } from './shared'\nimport { ImgixUrlParams } from './types'\nimport {\n  taskEitherFromSourceDataResolver,\n  semigroupImgixUrlParams,\n} from './utils'\n\nexport interface ImgixUrlArgs {\n  imgixParams?: ImgixUrlParams\n}\n\ninterface CreateImgixUrlFieldConfigArgs<TSource> {\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  secureUrlToken?: string\n  defaultImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixUrlFieldConfig = <TSource, TContext>({\n  resolveUrl,\n  secureUrlToken,\n  defaultImgixParams = {},\n}: CreateImgixUrlFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixUrlArgs\n> => ({\n  type: GraphQLString,\n  args: {\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (obj: TSource, args: ImgixUrlArgs): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.map((url) =>\n        pipe(\n          semigroupImgixUrlParams.concat(\n            defaultImgixParams,\n            args.imgixParams ?? {},\n          ),\n          buildImgixUrl(url, secureUrlToken),\n        ),\n      ),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n\nexport const createImgixUrlSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixUrlFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixUrlArgs> =>\n  createImgixUrlFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixUrlArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLNonNull,\n  GraphQLString,\n  GraphQLFieldConfig,\n} from 'gatsby/graphql'\nimport { FixedObject, FluidObject } from 'gatsby-image'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { fetchImgixBase64Url, ImgixSourceDataResolver } from './shared'\nimport { taskEitherFromSourceDataResolver } from './utils'\n\ninterface CreateImgixBase64UrlFieldConfigArgs {\n  resolveUrl?: ImgixSourceDataResolver<FixedObject | FluidObject, string>\n  cache: GatsbyCache\n}\n\nexport const createImgixBase64UrlFieldConfig = <TContext>({\n  resolveUrl = (obj: FixedObject | FluidObject): string | null | undefined =>\n    obj.base64,\n  cache,\n}: CreateImgixBase64UrlFieldConfigArgs): GraphQLFieldConfig<\n  FixedObject | FluidObject,\n  TContext\n> => ({\n  type: new GraphQLNonNull(GraphQLString),\n  resolve: (obj: FixedObject | FluidObject): Promise<string | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(resolveUrl),\n      TE.chain(fetchImgixBase64Url(cache)),\n      TE.fold(() => T.of(undefined), T.of),\n    )(),\n})\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLInt,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FixedObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFixedArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFixed, DEFAULT_FIXED_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFixedTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFixedType = ({\n  name,\n  cache,\n}: CreateImgixFixedTypeArgs): GraphQLObjectType<FixedObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      width: { type: new GraphQLNonNull(GraphQLInt) },\n      height: { type: new GraphQLNonNull(GraphQLInt) },\n    },\n  })\n\ninterface CreateImgixFixedFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FixedObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFixedFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFixedFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFixedArgs\n> => ({\n  type,\n  args: {\n    width: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FIXED_WIDTH,\n    },\n    height: {\n      type: GraphQLInt,\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFixedArgs,\n  ): Promise<FixedObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFixed({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFixedSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFixedFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFixedArgs> =>\n  createImgixFixedFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFixedArgs\n  >\n","import { GatsbyCache } from 'gatsby'\nimport {\n  GraphQLFieldConfig,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from 'gatsby/graphql'\nimport { FluidObject } from 'gatsby-image'\nimport { ComposeFieldConfigAsObject } from 'graphql-compose'\nimport * as T from 'fp-ts/lib/Task'\nimport * as TE from 'fp-ts/lib/TaskEither'\nimport { pipe } from 'fp-ts/lib/pipeable'\n\nimport { ImgixFluidArgs, ImgixUrlParams } from './types'\nimport { createImgixBase64UrlFieldConfig } from './createImgixBase64FieldConfig'\nimport { buildImgixFluid, DEFAULT_FLUID_MAX_WIDTH } from './builders'\nimport {\n  ImgixSourceDataResolver,\n  ImgixUrlParamsInputType,\n  resolveDimensions,\n} from './shared'\nimport { taskEitherFromSourceDataResolver, noop } from './utils'\n\ninterface CreateImgixFluidTypeArgs {\n  name: string\n  cache: GatsbyCache\n}\n\nexport const createImgixFluidType = ({\n  name,\n  cache,\n}: CreateImgixFluidTypeArgs): GraphQLObjectType<FluidObject> =>\n  new GraphQLObjectType({\n    name,\n    fields: {\n      base64: createImgixBase64UrlFieldConfig({ cache }),\n      src: { type: new GraphQLNonNull(GraphQLString) },\n      srcSet: { type: new GraphQLNonNull(GraphQLString) },\n      srcWebp: { type: new GraphQLNonNull(GraphQLString) },\n      srcSetWebp: { type: new GraphQLNonNull(GraphQLString) },\n      sizes: { type: new GraphQLNonNull(GraphQLString) },\n      aspectRatio: { type: new GraphQLNonNull(GraphQLFloat) },\n    },\n  })\n\ninterface CreateImgixFluidFieldConfigArgs<TSource> {\n  type: GraphQLObjectType<FluidObject>\n  resolveUrl: ImgixSourceDataResolver<TSource, string>\n  resolveWidth?: ImgixSourceDataResolver<TSource, number>\n  resolveHeight?: ImgixSourceDataResolver<TSource, number>\n  secureUrlToken?: string\n  cache: GatsbyCache\n  defaultImgixParams?: ImgixUrlParams\n  defaultPlaceholderImgixParams?: ImgixUrlParams\n}\n\nexport const createImgixFluidFieldConfig = <TSource, TContext>({\n  type,\n  resolveUrl,\n  resolveWidth = noop,\n  resolveHeight = noop,\n  secureUrlToken,\n  cache,\n  defaultImgixParams,\n  defaultPlaceholderImgixParams,\n}: CreateImgixFluidFieldConfigArgs<TSource>): GraphQLFieldConfig<\n  TSource,\n  TContext,\n  ImgixFluidArgs\n> => ({\n  type,\n  args: {\n    maxWidth: {\n      type: GraphQLInt,\n      defaultValue: DEFAULT_FLUID_MAX_WIDTH,\n    },\n    maxHeight: {\n      type: GraphQLInt,\n    },\n    srcSetBreakpoints: {\n      type: new GraphQLList(GraphQLInt),\n    },\n    imgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n    placeholderImgixParams: {\n      type: ImgixUrlParamsInputType,\n      defaultValue: {},\n    },\n  },\n  resolve: (\n    obj: TSource,\n    args: ImgixFluidArgs,\n  ): Promise<FluidObject | undefined> =>\n    pipe(\n      obj,\n      taskEitherFromSourceDataResolver(\n        resolveUrl,\n        (url) => typeof url === 'string',\n      ),\n      TE.chain((url) =>\n        pipe(\n          url,\n          resolveDimensions(\n            obj,\n            resolveWidth,\n            resolveHeight,\n            cache,\n            secureUrlToken,\n          ),\n          TE.map(([width, height]) =>\n            buildImgixFluid({\n              url,\n              sourceWidth: width,\n              sourceHeight: height,\n              secureUrlToken,\n              args: {\n                ...args,\n                imgixParams: {\n                  ...defaultImgixParams,\n                  ...args.imgixParams,\n                },\n                placeholderImgixParams: {\n                  ...defaultPlaceholderImgixParams,\n                  ...args.placeholderImgixParams,\n                },\n              },\n            }),\n          ),\n        ),\n      ),\n      TE.getOrElseW(() => T.of(undefined)),\n    )(),\n})\n\nexport const createImgixFluidSchemaFieldConfig = <TSource, TContext>(\n  args: CreateImgixFluidFieldConfigArgs<TSource>,\n): ComposeFieldConfigAsObject<TSource, TContext, ImgixFluidArgs> =>\n  createImgixFluidFieldConfig(args) as ComposeFieldConfigAsObject<\n    TSource,\n    TContext,\n    ImgixFluidArgs\n  >\n"],"names":["noop","getFromCacheOr","key","cache","f","pipe","get","then","value","O","getFromCache","TE","flow","set","setToCache","x","fetch","url","_fetch","reason","Error","String","semigroupImgixUrlParams","res","buffer","toString","getObjectSemigroup","join","separator","arr","taskEitherFromSourceDataResolver","resolver","predicate","source","Promise","resolve","data","reject","FIXED_RESOLUTIONS","FLUID_BREAKPOINT_FACTORS","DEFAULT_LQIP_PARAMS","w","blur","q","buildImgixUrl","secureUrlToken","params","R","param","undefined","u","URL","undefParams","acc","A","defParams","mergedParams","y","product","URLSearchParams","forEach","delete","semigroupURLSearchParams","searchParams","_","includes","search","setURLSearchParams","token","pathname","md5","createURLSignature","append","signURL","buildImgixLqipUrl","concat","ImgixUrlParamsInputType","GraphQLInputObjectType","name","fields","Object","keys","imgixUrlParameters","parameters","reduce","spec","camelCase","expectsTypes","Array","from","Set","expects","map","expect","type","every","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLString","description","short_description","slice","default","alias","aliases","sequenceTTE","sequenceT","resolveDimensions","resolveWidth","resolveHeight","fm","json","fetchJSON","fetchImgixMetadata","PixelWidth","PixelHeight","createImgixUrlFieldConfig","resolveUrl","defaultImgixParams","args","imgixParams","defaultValue","obj","T","createImgixUrlSchemaFieldConfig","createImgixBase64UrlFieldConfig","base64","GraphQLNonNull","contentType","buildBase64URL","headers","fetchImgixBase64Url","createImgixFixedType","GraphQLObjectType","src","srcSet","srcWebp","srcSetWebp","sizes","width","height","createImgixFixedFieldConfig","defaultPlaceholderImgixParams","placeholderImgixParams","sourceWidth","sourceHeight","aspectRatio","Math","round","h","baseUrl","dpr","buildImgixFixedSrcSet","buildImgixFixed","createImgixFixedSchemaFieldConfig","createImgixFluidType","createImgixFluidFieldConfig","maxWidth","maxHeight","srcSetBreakpoints","GraphQLList","eqNumber","ordNumber","breakpoint","buildImgixFluidSrcSet","buildImgixFluid","createImgixFluidSchemaFieldConfig"],"mappings":"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"}