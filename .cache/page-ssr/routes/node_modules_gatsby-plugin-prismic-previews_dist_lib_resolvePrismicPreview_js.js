"use strict";
exports.id = "node_modules_gatsby-plugin-prismic-previews_dist_lib_resolvePrismicPreview_js";
exports.ids = ["node_modules_gatsby-plugin-prismic-previews_dist_lib_resolvePrismicPreview_js"];
exports.modules = {

/***/ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/fmtLog.js":
/*!************************************************************************!*\
  !*** ./node_modules/gatsby-plugin-prismic-previews/dist/lib/fmtLog.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fmtLog: () => (/* binding */ fmtLog)
/* harmony export */ });
const fmtLog = (repositoryName, text) => {
  return `gatsby-plugin-prismic-previews(${repositoryName}) - ${text}`;
};


/***/ }),

/***/ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/getClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/gatsby-plugin-prismic-previews/dist/lib/getClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClient: () => (/* binding */ getClient)
/* harmony export */ });
/* harmony import */ var _prismicio_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prismicio/client */ "./node_modules/@prismicio/client/dist/createClient.js");
/* harmony import */ var _usePrismicPreviewStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../usePrismicPreviewStore.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/usePrismicPreviewStore.js");


const getClient = pluginOptions => {
  const state = _usePrismicPreviewStore_js__WEBPACK_IMPORTED_MODULE_0__.usePrismicPreviewStore.getState();
  if (state.client) {
    return state.client;
  } else {
    const client = (0,_prismicio_client__WEBPACK_IMPORTED_MODULE_1__.createClient)(pluginOptions.apiEndpoint || pluginOptions.repositoryName, {
      accessToken: pluginOptions.accessToken,
      routes: pluginOptions.routes,
      defaultParams: {
        lang: pluginOptions.lang || "*",
        fetchLinks: pluginOptions.fetchLinks,
        graphQuery: pluginOptions.graphQuery,
        predicates: pluginOptions.predicates
      }
    });
    state.setClient(client);
    return client;
  }
};


/***/ }),

/***/ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/getPluginOptions.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/gatsby-plugin-prismic-previews/dist/lib/getPluginOptions.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPluginOptions: () => (/* binding */ getPluginOptions)
/* harmony export */ });
/* harmony import */ var _usePrismicPreviewStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../usePrismicPreviewStore.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/usePrismicPreviewStore.js");

const getPluginOptions = repositoryName => {
  const state = _usePrismicPreviewStore_js__WEBPACK_IMPORTED_MODULE_0__.usePrismicPreviewStore.getState();
  return state.pluginOptions[repositoryName];
};


/***/ }),

/***/ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/getRepositoryConfig.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/gatsby-plugin-prismic-previews/dist/lib/getRepositoryConfig.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRepositoryConfig: () => (/* binding */ getRepositoryConfig)
/* harmony export */ });
/* harmony import */ var _usePrismicPreviewStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../usePrismicPreviewStore.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/usePrismicPreviewStore.js");

const getRepositoryConfig = repositoryName => {
  const state = _usePrismicPreviewStore_js__WEBPACK_IMPORTED_MODULE_0__.usePrismicPreviewStore.getState();
  return state.repositoryConfigs.find(config => config.repositoryName === repositoryName);
};


/***/ }),

/***/ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/resolvePrismicPreview.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/gatsby-plugin-prismic-previews/dist/lib/resolvePrismicPreview.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ resolvePrismicPreview)
/* harmony export */ });
/* harmony import */ var gatsby__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gatsby */ "./.cache/gatsby-browser-entry.js");
/* harmony import */ var _fmtLog_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fmtLog.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/fmtLog.js");
/* harmony import */ var _getClient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getClient.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/getClient.js");
/* harmony import */ var _getPluginOptions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getPluginOptions.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/getPluginOptions.js");
/* harmony import */ var _getRepositoryConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getRepositoryConfig.js */ "./node_modules/gatsby-plugin-prismic-previews/dist/lib/getRepositoryConfig.js");





const resolvePrismicPreview = async (repositoryName, abortController) => {
  const pluginOptions = (0,_getPluginOptions_js__WEBPACK_IMPORTED_MODULE_1__.getPluginOptions)(repositoryName);
  if (!pluginOptions) {
    console.error((0,_fmtLog_js__WEBPACK_IMPORTED_MODULE_2__.fmtLog)(repositoryName, `Plugin options could not be found. Did you add "gatsby-plugin-prismic-previews" for this repository to your app's "gatsby-config.js" file?`));
    return;
  }
  const repositoryConfig = (0,_getRepositoryConfig_js__WEBPACK_IMPORTED_MODULE_3__.getRepositoryConfig)(repositoryName);
  if (!repositoryConfig) {
    console.error((0,_fmtLog_js__WEBPACK_IMPORTED_MODULE_2__.fmtLog)(repositoryName, 'Repository configuration could not be found. Did you add <PrismicPreviewProvider> to your "gatsby-browser.js" and "gatsby-ssr.js"? It must contain a repository configuration object for this repository.'));
    return;
  }
  const client = (0,_getClient_js__WEBPACK_IMPORTED_MODULE_4__.getClient)(pluginOptions);
  try {
    const path = await client.resolvePreviewURL({
      linkResolver: repositoryConfig.linkResolver,
      defaultURL: "/",
      signal: abortController.signal
    });
    if (!abortController.signal.aborted) {
      (0,gatsby__WEBPACK_IMPORTED_MODULE_0__.navigate)(path);
    }
  } catch (error) {
    if (!(error instanceof Error && error.name === "AbortError")) {
      throw error;
    }
  }
};


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/buildQueryURL.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/buildQueryURL.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildQueryURL: () => (/* binding */ buildQueryURL)
/* harmony export */ });
/* harmony import */ var _lib_castArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/castArray.js */ "./node_modules/@prismicio/client/dist/lib/castArray.js");
/* harmony import */ var _lib_devMsg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/devMsg.js */ "./node_modules/@prismicio/client/dist/lib/devMsg.js");


const RENAMED_PARAMS = {
  accessToken: "access_token"
};
const castOrderingToString = (ordering) => {
  if (typeof ordering === "string") {
    if (true) {
      const [field, direction] = ordering.split(" ");
      const objectForm = direction === "desc" ? `{ field: "${field}", direction: "desc" }` : `{ field: "${field}" }`;
      console.warn(`[@prismicio/client] A string value was provided to the \`orderings\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${(0,_lib_devMsg_js__WEBPACK_IMPORTED_MODULE_0__.devMsg)("orderings-must-be-an-array-of-objects")}`);
    }
    return ordering;
  }
  return ordering.direction === "desc" ? `${ordering.field} desc` : ordering.field;
};
const buildQueryURL = (endpoint, args) => {
  const { filters, predicates, ...params } = args;
  const url = new URL(`documents/search`, `${endpoint}/`);
  if (filters) {
    if ( true && !Array.isArray(filters)) {
      console.warn(`[@prismicio/client] A non-array value was provided to the \`filters\` query parameter (\`${filters}\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${(0,_lib_devMsg_js__WEBPACK_IMPORTED_MODULE_0__.devMsg)("filters-must-be-an-array")}`);
    }
    for (const filter of (0,_lib_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(filters)) {
      url.searchParams.append("q", `[${filter}]`);
    }
  }
  if (predicates) {
    for (const predicate of (0,_lib_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(predicates)) {
      url.searchParams.append("q", `[${predicate}]`);
    }
  }
  for (const k in params) {
    const name = RENAMED_PARAMS[k] || k;
    let value = params[k];
    if (name === "orderings") {
      const scopedValue = params[name];
      if (scopedValue != null) {
        if ( true && typeof scopedValue === "string") {
          console.warn(`[@prismicio/client] A string value was provided to the \`orderings\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${(0,_lib_devMsg_js__WEBPACK_IMPORTED_MODULE_0__.devMsg)("orderings-must-be-an-array-of-objects")}`);
        }
        const v = (0,_lib_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(scopedValue).map((ordering) => castOrderingToString(ordering)).join(",");
        value = `[${v}]`;
      }
    } else if (name === "routes") {
      if (typeof params[name] === "object") {
        value = JSON.stringify((0,_lib_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(params[name]));
      }
    }
    if (value != null) {
      url.searchParams.set(name, (0,_lib_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(value).join(","));
    }
  }
  return url.toString();
};

//# sourceMappingURL=buildQueryURL.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/cookie.js":
/*!*******************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/cookie.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   preview: () => (/* binding */ preview)
/* harmony export */ });
const preview = "io.prismic.preview";

//# sourceMappingURL=cookie.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/createClient.js":
/*!*************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/createClient.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* binding */ Client),
/* harmony export */   GET_ALL_QUERY_DELAY: () => (/* binding */ GET_ALL_QUERY_DELAY),
/* harmony export */   REPOSITORY_CACHE_TTL: () => (/* binding */ REPOSITORY_CACHE_TTL),
/* harmony export */   createClient: () => (/* binding */ createClient)
/* harmony export */ });
/* harmony import */ var _lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/appendFilters.js */ "./node_modules/@prismicio/client/dist/lib/appendFilters.js");
/* harmony import */ var _lib_castThunk_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/castThunk.js */ "./node_modules/@prismicio/client/dist/lib/castThunk.js");
/* harmony import */ var _lib_devMsg_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/devMsg.js */ "./node_modules/@prismicio/client/dist/lib/devMsg.js");
/* harmony import */ var _lib_everyTagFilter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/everyTagFilter.js */ "./node_modules/@prismicio/client/dist/lib/everyTagFilter.js");
/* harmony import */ var _lib_findMasterRef_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/findMasterRef.js */ "./node_modules/@prismicio/client/dist/lib/findMasterRef.js");
/* harmony import */ var _lib_findRefByID_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/findRefByID.js */ "./node_modules/@prismicio/client/dist/lib/findRefByID.js");
/* harmony import */ var _lib_findRefByLabel_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/findRefByLabel.js */ "./node_modules/@prismicio/client/dist/lib/findRefByLabel.js");
/* harmony import */ var _lib_getPreviewCookie_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/getPreviewCookie.js */ "./node_modules/@prismicio/client/dist/lib/getPreviewCookie.js");
/* harmony import */ var _lib_minifyGraphQLQuery_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/minifyGraphQLQuery.js */ "./node_modules/@prismicio/client/dist/lib/minifyGraphQLQuery.js");
/* harmony import */ var _lib_someTagsFilter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/someTagsFilter.js */ "./node_modules/@prismicio/client/dist/lib/someTagsFilter.js");
/* harmony import */ var _lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/typeFilter.js */ "./node_modules/@prismicio/client/dist/lib/typeFilter.js");
/* harmony import */ var _errors_ForbiddenError_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./errors/ForbiddenError.js */ "./node_modules/@prismicio/client/dist/errors/ForbiddenError.js");
/* harmony import */ var _errors_NotFoundError_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./errors/NotFoundError.js */ "./node_modules/@prismicio/client/dist/errors/NotFoundError.js");
/* harmony import */ var _errors_ParsingError_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./errors/ParsingError.js */ "./node_modules/@prismicio/client/dist/errors/ParsingError.js");
/* harmony import */ var _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors/PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");
/* harmony import */ var _helpers_asLink_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/asLink.js */ "./node_modules/@prismicio/client/dist/helpers/asLink.js");
/* harmony import */ var _buildQueryURL_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./buildQueryURL.js */ "./node_modules/@prismicio/client/dist/buildQueryURL.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter.js */ "./node_modules/@prismicio/client/dist/filter.js");
/* harmony import */ var _getRepositoryEndpoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getRepositoryEndpoint.js */ "./node_modules/@prismicio/client/dist/getRepositoryEndpoint.js");
/* harmony import */ var _getRepositoryName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getRepositoryName.js */ "./node_modules/@prismicio/client/dist/getRepositoryName.js");
/* harmony import */ var _isRepositoryEndpoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isRepositoryEndpoint.js */ "./node_modules/@prismicio/client/dist/isRepositoryEndpoint.js");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};





















const MAX_PAGE_SIZE = 100;
const REPOSITORY_CACHE_TTL = 5e3;
const GET_ALL_QUERY_DELAY = 500;
var RefStateMode;
(function(RefStateMode2) {
  RefStateMode2["Master"] = "Master";
  RefStateMode2["ReleaseID"] = "ReleaseID";
  RefStateMode2["ReleaseLabel"] = "ReleaseLabel";
  RefStateMode2["Manual"] = "Manual";
})(RefStateMode || (RefStateMode = {}));
const createClient = (repositoryNameOrEndpoint, options) => new Client(repositoryNameOrEndpoint, options);
class Client {
  /**
   * Creates a Prismic client that can be used to query a repository.
   *
   * If used in an environment where a global `fetch` function is unavailable,
   * such as Node.js, the `fetch` option must be provided as part of the
   * `options` parameter.
   *
   * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest
   *   API V2 endpoint for the repository.
   * @param options - Configuration that determines how content will be queried
   *   from the Prismic repository.
   *
   * @returns A client that can query content from the repository.
   */
  constructor(repositoryNameOrEndpoint, options = {}) {
    /**
     * The Prismic REST API V2 endpoint for the repository (use
     * `prismic.getRepositoryEndpoint` for the default endpoint).
     */
    __publicField(this, "endpoint");
    /**
     * The secure token for accessing the API (only needed if your repository is
     * set to private).
     *
     * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}
     */
    __publicField(this, "accessToken");
    /**
     * A list of route resolver objects that define how a document's `url` field
     * is resolved.
     *
     * {@link https://prismic.io/docs/route-resolver}
     */
    __publicField(this, "routes");
    /**
     * The `brokenRoute` option allows you to define the route populated in the
     * `url` property for broken link or content relationship fields. A broken
     * link is a link or content relationship field whose linked document has been
     * unpublished or deleted.
     *
     * {@link https://prismic.io/docs/route-resolver}
     */
    __publicField(this, "brokenRoute");
    /**
     * The function used to make network requests to the Prismic REST API. In
     * environments where a global `fetch` function does not exist, such as
     * Node.js, this function must be provided.
     */
    __publicField(this, "fetchFn");
    __publicField(this, "fetchOptions");
    /**
     * Default parameters that will be sent with each query. These parameters can
     * be overridden on each query if needed.
     */
    __publicField(this, "defaultParams");
    /**
     * The client's ref mode state. This determines which ref is used during
     * queries.
     */
    __publicField(this, "refState", {
      mode: RefStateMode.Master,
      autoPreviewsEnabled: true
    });
    /**
     * Cached repository value.
     */
    __publicField(this, "cachedRepository");
    /**
     * Timestamp at which the cached repository data is considered stale.
     */
    __publicField(this, "cachedRepositoryExpiration", 0);
    /**
     * Active `fetch()` jobs keyed by URL and AbortSignal (if it exists).
     */
    __publicField(this, "fetchJobs", {});
    if ((0,_isRepositoryEndpoint_js__WEBPACK_IMPORTED_MODULE_0__.isRepositoryEndpoint)(repositoryNameOrEndpoint)) {
      if (true) {
        if (/\.prismic\.io\/(?!api\/v2\/?)/i.test(repositoryNameOrEndpoint)) {
          throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError("@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.", void 0, void 0);
        }
        const hostname = new URL(repositoryNameOrEndpoint).hostname.toLowerCase();
        if (hostname.endsWith(".prismic.io") && !hostname.endsWith(".cdn.prismic.io")) {
          const repositoryName = (0,_getRepositoryName_js__WEBPACK_IMPORTED_MODULE_2__.getRepositoryName)(repositoryNameOrEndpoint);
          const dotCDNEndpoint = (0,_getRepositoryEndpoint_js__WEBPACK_IMPORTED_MODULE_3__.getRepositoryEndpoint)(repositoryName);
          console.warn(`[@prismicio/client] A non-.cdn endpoint was provided to create a client with (\`${repositoryNameOrEndpoint}\`). Non-.cdn endpoints can have unexpected side-effects and cause performance issues when querying Prismic. Please convert it to the \`.cdn\` alternative (\`${dotCDNEndpoint}\`) or use the repository name directly instead (\`${repositoryName}\`). For more details, see ${(0,_lib_devMsg_js__WEBPACK_IMPORTED_MODULE_4__.devMsg)("endpoint-must-use-cdn")}`);
        }
      }
      this.endpoint = repositoryNameOrEndpoint;
    } else {
      this.endpoint = (0,_getRepositoryEndpoint_js__WEBPACK_IMPORTED_MODULE_3__.getRepositoryEndpoint)(repositoryNameOrEndpoint);
    }
    this.accessToken = options.accessToken;
    this.routes = options.routes;
    this.brokenRoute = options.brokenRoute;
    this.fetchOptions = options.fetchOptions;
    this.defaultParams = options.defaultParams;
    if (options.ref) {
      this.queryContentFromRef(options.ref);
    }
    if (typeof options.fetch === "function") {
      this.fetchFn = options.fetch;
    } else if (typeof globalThis.fetch === "function") {
      this.fetchFn = globalThis.fetch;
    } else {
      throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.", void 0, void 0);
    }
    if (this.fetchFn === globalThis.fetch) {
      this.fetchFn = this.fetchFn.bind(globalThis);
    }
    this.graphQLFetch = this.graphQLFetch.bind(this);
  }
  /**
   * Enables the client to automatically query content from a preview session if
   * one is active in browser environments. This is enabled by default in the
   * browser.
   *
   * For server environments, use `enableAutoPreviewsFromReq`.
   *
   * @example
   *
   * ```ts
   * client.enableAutoPreviews();
   * ```
   *
   * @see enableAutoPreviewsFromReq
   */
  enableAutoPreviews() {
    this.refState.autoPreviewsEnabled = true;
  }
  /**
   * Enables the client to automatically query content from a preview session if
   * one is active in server environments. This is disabled by default on the
   * server.
   *
   * For browser environments, use `enableAutoPreviews`.
   *
   * @example
   *
   * ```ts
   * // In an express app
   * app.get("/", function (req, res) {
   * 	client.enableAutoPreviewsFromReq(req);
   * });
   * ```
   *
   * @param req - An HTTP server request object containing the request's
   *   cookies.
   */
  enableAutoPreviewsFromReq(req) {
    this.refState.httpRequest = req;
    this.refState.autoPreviewsEnabled = true;
  }
  /**
   * Disables the client from automatically querying content from a preview
   * session if one is active.
   *
   * Automatic preview content querying is enabled by default unless this method
   * is called.
   *
   * @example
   *
   * ```ts
   * client.disableAutoPreviews();
   * ```
   */
  disableAutoPreviews() {
    this.refState.autoPreviewsEnabled = false;
  }
  /**
   * Queries content from the Prismic repository.
   *
   * @example
   *
   * ```ts
   * const response = await client.get();
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param params - Parameters to filter, sort, and paginate results.
   *
   * @returns A paginated response containing the result of the query.
   */
  async get(params) {
    const url = await this.buildQueryURL(params);
    return await this.fetch(url, params);
  }
  /**
   * Queries content from the Prismic repository and returns only the first
   * result, if any.
   *
   * @example
   *
   * ```ts
   * const document = await client.getFirst();
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param params - Parameters to filter, sort, and paginate results. @returns
   *   The first result of the query, if any.
   */
  async getFirst(params) {
    var _a;
    const actualParams = { ...params };
    if (!(params && params.page) && !(params == null ? void 0 : params.pageSize)) {
      actualParams.pageSize = ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) ?? 1;
    }
    const url = await this.buildQueryURL(actualParams);
    const result = await this.fetch(url, params);
    const firstResult = result.results[0];
    if (firstResult) {
      return firstResult;
    }
    throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError("No documents were returned", url, void 0);
  }
  /**
   * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and
   * require more resources than other methods. Prefer using other methods that
   * filter by filters such as `getAllByType`.
   *
   * Queries content from the Prismic repository and returns all matching
   * content. If no filters are provided, all documents will be fetched.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.dangerouslyGetAll();
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param params - Parameters to filter, sort, and paginate results.
   *
   * @returns A list of documents matching the query.
   */
  async dangerouslyGetAll(params = {}) {
    var _a;
    const { limit = Infinity, ...actualParams } = params;
    const resolvedParams = {
      ...actualParams,
      pageSize: Math.min(limit, actualParams.pageSize || ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) || MAX_PAGE_SIZE)
    };
    const documents = [];
    let latestResult;
    while ((!latestResult || latestResult.next_page) && documents.length < limit) {
      const page = latestResult ? latestResult.page + 1 : void 0;
      latestResult = await this.get({ ...resolvedParams, page });
      documents.push(...latestResult.results);
      if (latestResult.next_page) {
        await new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));
      }
    }
    return documents.slice(0, limit);
  }
  /**
   * Queries a document from the Prismic repository with a specific ID.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   * @example
   *
   * ```ts
   * const document = await client.getByID("WW4bKScAAMAqmluX");
   * ```
   *
   * @typeParam TDocument- Type of the Prismic document returned.
   *
   * @param id - ID of the document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns The document with an ID matching the `id` parameter, if a matching
   *   document exists.
   */
  async getByID(id, params) {
    return await this.getFirst((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, _filter_js__WEBPACK_IMPORTED_MODULE_6__.filter.at("document.id", id)));
  }
  /**
   * Queries documents from the Prismic repository with specific IDs.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   * @example
   *
   * ```ts
   * const response = await client.getByIDs([
   * 	"WW4bKScAAMAqmluX",
   * 	"U1kTRgEAAC8A5ldS",
   * ]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param ids - A list of document IDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with IDs matching the
   *   `ids` parameter.
   */
  async getByIDs(ids, params) {
    return await this.get((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, _filter_js__WEBPACK_IMPORTED_MODULE_6__.filter.in("document.id", ids)));
  }
  /**
   * Queries all documents from the Prismic repository with specific IDs.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   * @example
   *
   * ```ts
   * const response = await client.getAllByIDs([
   * 	"WW4bKScAAMAqmluX",
   * 	"U1kTRgEAAC8A5ldS",
   * ]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param ids - A list of document IDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of documents with IDs matching the `ids` parameter.
   */
  async getAllByIDs(ids, params) {
    return await this.dangerouslyGetAll((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, _filter_js__WEBPACK_IMPORTED_MODULE_6__.filter.in("document.id", ids)));
  }
  /**
   * Queries a document from the Prismic repository with a specific UID and
   * custom type.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   * @example
   *
   * ```ts
   * const document = await client.getByUID("blog_post", "my-first-post");
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param documentType - The API ID of the document's custom type.
   * @param uid - UID of the document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns The document with a UID matching the `uid` parameter, if a
   *   matching document exists.
   */
  async getByUID(documentType, uid, params) {
    return await this.getFirst((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, [
      (0,_lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__.typeFilter)(documentType),
      _filter_js__WEBPACK_IMPORTED_MODULE_6__.filter.at(`my.${documentType}.uid`, uid)
    ]));
  }
  /**
   * Queries document from the Prismic repository with specific UIDs and Custom
   * Type.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   * @example
   *
   * ```ts
   * const document = await client.getByUIDs("blog_post", [
   * 	"my-first-post",
   * 	"my-second-post",
   * ]);
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param documentType - The API ID of the document's custom type.
   * @param uids - A list of document UIDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with UIDs matching the
   *   `uids` parameter.
   */
  async getByUIDs(documentType, uids, params) {
    return await this.get((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, [
      (0,_lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__.typeFilter)(documentType),
      _filter_js__WEBPACK_IMPORTED_MODULE_6__.filter.in(`my.${documentType}.uid`, uids)
    ]));
  }
  /**
   * Queries all documents from the Prismic repository with specific UIDs and
   * custom type.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   * @example
   *
   * ```ts
   * const response = await client.getAllByUIDs([
   * 	"my-first-post",
   * 	"my-second-post",
   * ]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param documentType - The API ID of the document's custom type.
   * @param uids - A list of document UIDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of documents with UIDs matching the `uids` parameter.
   */
  async getAllByUIDs(documentType, uids, params) {
    return await this.dangerouslyGetAll((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, [
      (0,_lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__.typeFilter)(documentType),
      _filter_js__WEBPACK_IMPORTED_MODULE_6__.filter.in(`my.${documentType}.uid`, uids)
    ]));
  }
  /**
   * Queries a singleton document from the Prismic repository for a specific
   * custom type.
   *
   * @remarks
   * A singleton document is one that is configured in Prismic to only allow one
   * instance. For example, a repository may be configured to contain just one
   * Settings document. This is in contrast to a repeatable custom type which
   * allows multiple instances of itself.
   * @example
   *
   * ```ts
   * const document = await client.getSingle("settings");
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param documentType - The API ID of the singleton custom type.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns The singleton document for the custom type, if a matching document
   *   exists.
   */
  async getSingle(documentType, params) {
    return await this.getFirst((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__.typeFilter)(documentType)));
  }
  /**
   * Queries documents from the Prismic repository for a specific custom type.
   *
   * Use `getAllByType` instead if you need to query all documents for a
   * specific custom type.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByType("blog_post");
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param documentType - The API ID of the custom type.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents of the custom type.
   */
  async getByType(documentType, params) {
    return await this.get((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__.typeFilter)(documentType)));
  }
  /**
   * Queries all documents from the Prismic repository for a specific Custom
   * Type.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByType("blog_post");
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param documentType - The API ID of the custom type.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents of the custom type.
   */
  async getAllByType(documentType, params) {
    return await this.dangerouslyGetAll((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_typeFilter_js__WEBPACK_IMPORTED_MODULE_7__.typeFilter)(documentType)));
  }
  /**
   * Queries documents from the Prismic repository with a specific tag.
   *
   * Use `getAllByTag` instead if you need to query all documents with a
   * specific tag.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByTag("food");
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tag - The tag that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with the tag.
   */
  async getByTag(tag, params) {
    return await this.get((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_someTagsFilter_js__WEBPACK_IMPORTED_MODULE_8__.someTagsFilter)(tag)));
  }
  /**
   * Queries all documents from the Prismic repository with a specific tag.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllByTag("food");
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tag - The tag that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents with the tag.
   */
  async getAllByTag(tag, params) {
    return await this.dangerouslyGetAll((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_someTagsFilter_js__WEBPACK_IMPORTED_MODULE_8__.someTagsFilter)(tag)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with all of the queried tags to be included.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByEveryTag(["food", "fruit"]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with the tags.
   */
  async getByEveryTag(tags, params) {
    return await this.get((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_everyTagFilter_js__WEBPACK_IMPORTED_MODULE_9__.everyTagFilter)(tags)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with all of the queried tags to be included.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllByEveryTag(["food", "fruit"]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents with the tags.
   */
  async getAllByEveryTag(tags, params) {
    return await this.dangerouslyGetAll((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_everyTagFilter_js__WEBPACK_IMPORTED_MODULE_9__.everyTagFilter)(tags)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with at least one of the queried tags to be
   * included.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByEveryTag(["food", "fruit"]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with at least one of the
   *   tags.
   */
  async getBySomeTags(tags, params) {
    return await this.get((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_someTagsFilter_js__WEBPACK_IMPORTED_MODULE_8__.someTagsFilter)(tags)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with at least one of the queried tags to be
   * included.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllBySomeTags(["food", "fruit"]);
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents with at least one of the tags.
   */
  async getAllBySomeTags(tags, params) {
    return await this.dangerouslyGetAll((0,_lib_appendFilters_js__WEBPACK_IMPORTED_MODULE_5__.appendFilters)(params, (0,_lib_someTagsFilter_js__WEBPACK_IMPORTED_MODULE_8__.someTagsFilter)(tags)));
  }
  /**
   * Returns metadata about the Prismic repository, such as its refs, releases,
   * and custom types.
   *
   * @returns Repository metadata.
   */
  async getRepository(params) {
    const url = new URL(this.endpoint);
    if (this.accessToken) {
      url.searchParams.set("access_token", this.accessToken);
    }
    return await this.fetch(url.toString(), params);
  }
  /**
   * Returns a list of all refs for the Prismic repository.
   *
   * Refs are used to identify which version of the repository's content should
   * be queried. All repositories will have at least one ref pointing to the
   * latest published content called the "master ref".
   *
   * @returns A list of all refs for the Prismic repository.
   */
  async getRefs(params) {
    const repository = await this.getRepository(params);
    return repository.refs;
  }
  /**
   * Returns a ref for the Prismic repository with a matching ID.
   *
   * @param id - ID of the ref.
   *
   * @returns The ref with a matching ID, if it exists.
   */
  async getRefByID(id, params) {
    const refs = await this.getRefs(params);
    return (0,_lib_findRefByID_js__WEBPACK_IMPORTED_MODULE_10__.findRefByID)(refs, id);
  }
  /**
   * Returns a ref for the Prismic repository with a matching label.
   *
   * @param label - Label of the ref.
   *
   * @returns The ref with a matching label, if it exists.
   */
  async getRefByLabel(label, params) {
    const refs = await this.getRefs(params);
    return (0,_lib_findRefByLabel_js__WEBPACK_IMPORTED_MODULE_11__.findRefByLabel)(refs, label);
  }
  /**
   * Returns the master ref for the Prismic repository. The master ref points to
   * the repository's latest published content.
   *
   * @returns The repository's master ref.
   */
  async getMasterRef(params) {
    const refs = await this.getRefs(params);
    return (0,_lib_findMasterRef_js__WEBPACK_IMPORTED_MODULE_12__.findMasterRef)(refs);
  }
  /**
   * Returns a list of all Releases for the Prismic repository. Releases are
   * used to group content changes before publishing.
   *
   * @returns A list of all Releases for the Prismic repository.
   */
  async getReleases(params) {
    const refs = await this.getRefs(params);
    return refs.filter((ref) => !ref.isMasterRef);
  }
  /**
   * Returns a Release for the Prismic repository with a matching ID.
   *
   * @param id - ID of the Release.
   *
   * @returns The Release with a matching ID, if it exists.
   */
  async getReleaseByID(id, params) {
    const releases = await this.getReleases(params);
    return (0,_lib_findRefByID_js__WEBPACK_IMPORTED_MODULE_10__.findRefByID)(releases, id);
  }
  /**
   * Returns a Release for the Prismic repository with a matching label.
   *
   * @param label - Label of the ref.
   *
   * @returns The ref with a matching label, if it exists.
   */
  async getReleaseByLabel(label, params) {
    const releases = await this.getReleases(params);
    return (0,_lib_findRefByLabel_js__WEBPACK_IMPORTED_MODULE_11__.findRefByLabel)(releases, label);
  }
  /**
   * Returns a list of all tags used in the Prismic repository.
   *
   * @returns A list of all tags used in the repository.
   */
  async getTags(params) {
    try {
      const tagsForm = await this.getCachedRepositoryForm("tags", params);
      const url = new URL(tagsForm.action);
      if (this.accessToken) {
        url.searchParams.set("access_token", this.accessToken);
      }
      return await this.fetch(url.toString(), params);
    } catch {
      const repository = await this.getRepository(params);
      return repository.tags;
    }
  }
  /**
   * Builds a URL used to query content from the Prismic repository.
   *
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A URL string that can be requested to query content.
   */
  async buildQueryURL({ signal, fetchOptions, ...params } = {}) {
    const ref = params.ref || await this.getResolvedRefString({ signal, fetchOptions });
    const integrationFieldsRef = params.integrationFieldsRef || (await this.getCachedRepository({ signal, fetchOptions })).integrationFieldsRef || void 0;
    return (0,_buildQueryURL_js__WEBPACK_IMPORTED_MODULE_13__.buildQueryURL)(this.endpoint, {
      ...this.defaultParams,
      ...params,
      ref,
      integrationFieldsRef,
      routes: params.routes || this.routes,
      brokenRoute: params.brokenRoute || this.brokenRoute,
      accessToken: params.accessToken || this.accessToken
    });
  }
  /**
   * Determines the URL for a previewed document during an active preview
   * session. The result of this method should be used to redirect the user to
   * the document's URL.
   *
   * @example
   *
   * ```ts
   * 	const url = client.resolvePreviewURL({
   * 	linkResolver: (document) => `/${document.uid}`
   * 	defaultURL: '/'
   * 	})
   * ```
   *
   * @param args - Arguments to configure the URL resolving.
   *
   * @returns The URL for the previewed document during an active preview
   *   session. The user should be redirected to this URL.
   */
  async resolvePreviewURL(args) {
    var _a, _b;
    let documentID = args.documentID;
    let previewToken = args.previewToken;
    if (typeof globalThis.location !== "undefined") {
      const searchParams = new URLSearchParams(globalThis.location.search);
      documentID = documentID || searchParams.get("documentId");
      previewToken = previewToken || searchParams.get("token");
    } else if (this.refState.httpRequest) {
      if ("query" in this.refState.httpRequest) {
        documentID = documentID || ((_a = this.refState.httpRequest.query) == null ? void 0 : _a.documentId);
        previewToken = previewToken || ((_b = this.refState.httpRequest.query) == null ? void 0 : _b.token);
      } else if ("url" in this.refState.httpRequest && this.refState.httpRequest.url) {
        const searchParams = new URL(this.refState.httpRequest.url, "missing-host://").searchParams;
        documentID = documentID || searchParams.get("documentId");
        previewToken = previewToken || searchParams.get("token");
      }
    }
    if (documentID != null && previewToken != null) {
      const document = await this.getByID(documentID, {
        ref: previewToken,
        lang: "*",
        signal: args.signal,
        fetchOptions: args.fetchOptions
      });
      const url = (0,_helpers_asLink_js__WEBPACK_IMPORTED_MODULE_14__.asLink)(document, { linkResolver: args.linkResolver });
      if (typeof url === "string") {
        return url;
      }
    }
    return args.defaultURL;
  }
  /**
   * Configures the client to query the latest published content for all future
   * queries.
   *
   * If the `ref` parameter is provided during a query, it takes priority for
   * that query.
   *
   * @example
   *
   * ```ts
   * await client.queryLatestContent();
   * const document = await client.getByID("WW4bKScAAMAqmluX");
   * ```
   */
  queryLatestContent() {
    this.refState.mode = RefStateMode.Master;
  }
  /**
   * Configures the client to query content from a specific Release identified
   * by its ID for all future queries.
   *
   * If the `ref` parameter is provided during a query, it takes priority for
   * that query.
   *
   * @example
   *
   * ```ts
   * await client.queryContentFromReleaseByID("YLB7OBAAACMA7Cpa");
   * const document = await client.getByID("WW4bKScAAMAqmluX");
   * ```
   *
   * @param releaseID - The ID of the Release.
   */
  queryContentFromReleaseByID(releaseID) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.ReleaseID,
      releaseID
    };
  }
  /**
   * Configures the client to query content from a specific Release identified
   * by its label for all future queries.
   *
   * If the `ref` parameter is provided during a query, it takes priority for
   * that query.
   *
   * @example
   *
   * ```ts
   * await client.queryContentFromReleaseByLabel("My Release");
   * const document = await client.getByID("WW4bKScAAMAqmluX");
   * ```
   *
   * @param releaseLabel - The label of the Release.
   */
  queryContentFromReleaseByLabel(releaseLabel) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.ReleaseLabel,
      releaseLabel
    };
  }
  /**
   * Configures the client to query content from a specific ref. The ref can be
   * provided as a string or a function.
   *
   * If a function is provided, the ref is fetched lazily before each query. The
   * function may also be asynchronous.
   *
   * @example
   *
   * ```ts
   * await client.queryContentFromRef("my-ref");
   * const document = await client.getByID("WW4bKScAAMAqmluX");
   * ```
   *
   * @param ref - The ref or a function that returns the ref from which to query
   *   content.
   */
  queryContentFromRef(ref) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.Manual,
      ref
    };
  }
  /**
   * A `fetch()` function to be used with GraphQL clients configured for
   * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`
   * and Authorization headers. Queries will automatically be minified by
   * removing whitespace where possible.
   *
   * @example
   *
   * ```ts
   * const graphQLClient = new ApolloClient({
   * 	link: new HttpLink({
   * 		uri: prismic.getGraphQLEndpoint(repositoryName),
   * 		// Provide `client.graphQLFetch` as the fetch implementation.
   * 		fetch: client.graphQLFetch,
   * 		// Using GET is required.
   * 		useGETForQueries: true,
   * 	}),
   * 	cache: new InMemoryCache(),
   * });
   * ```
   *
   * @param input - The `fetch()` `input` parameter. Only strings are supported.
   * @param init - The `fetch()` `init` parameter. Only plain objects are
   *   supported.
   *
   * @returns The `fetch()` Response for the request.
   *
   * @experimental
   */
  async graphQLFetch(input, init) {
    const cachedRepository = await this.getCachedRepository();
    const ref = await this.getResolvedRefString();
    const unsanitizedHeaders = {
      "Prismic-ref": ref,
      Authorization: this.accessToken ? `Token ${this.accessToken}` : "",
      // Asserting `init.headers` is a Record since popular GraphQL
      // libraries pass this as a Record. Header objects as input
      // are unsupported.
      ...init ? init.headers : {}
    };
    if (cachedRepository.integrationFieldsRef) {
      unsanitizedHeaders["Prismic-integration-field-ref"] = cachedRepository.integrationFieldsRef;
    }
    const headers = {};
    for (const key in unsanitizedHeaders) {
      if (unsanitizedHeaders[key]) {
        headers[key.toLowerCase()] = unsanitizedHeaders[key];
      }
    }
    const url = new URL(
      // Asserting `input` is a string since popular GraphQL
      // libraries pass this as a string. Request objects as
      // input are unsupported.
      input
    );
    url.searchParams.set("ref", ref);
    const query = url.searchParams.get("query");
    if (query) {
      url.searchParams.set(
        "query",
        // Compress the GraphQL query (if it exists) by
        // removing whitespace. This is done to
        // optimize the query size and avoid
        // hitting the upper limit of GET requests
        // (2048 characters).
        (0,_lib_minifyGraphQLQuery_js__WEBPACK_IMPORTED_MODULE_15__.minifyGraphQLQuery)(query)
      );
    }
    return await this.fetchFn(url.toString(), {
      ...init,
      headers
    });
  }
  /**
   * Returns a cached version of `getRepository` with a TTL.
   *
   * @returns Cached repository metadata.
   */
  async getCachedRepository(params) {
    if (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) {
      this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;
      this.cachedRepository = await this.getRepository(params);
    }
    return this.cachedRepository;
  }
  /**
   * Returns a cached Prismic repository form. Forms are used to determine API
   * endpoints for types of repository data.
   *
   * @param name - Name of the form.
   *
   * @returns The repository form.
   *
   * @throws If a matching form cannot be found.
   */
  async getCachedRepositoryForm(name, params) {
    const cachedRepository = await this.getCachedRepository(params);
    const form = cachedRepository.forms[name];
    if (!form) {
      throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError(`Form with name "${name}" could not be found`, void 0, void 0);
    }
    return form;
  }
  /**
   * Returns the ref needed to query based on the client's current state. This
   * method may make a network request to fetch a ref or resolve the user's ref
   * thunk.
   *
   * If auto previews are enabled, the preview ref takes priority if available.
   *
   * The following strategies are used depending on the client's state:
   *
   * - If the user called `queryLatestContent`: Use the repository's master ref.
   *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is
   *   fetched.
   * - If the user called `queryContentFromReleaseByID`: Use the release's ref.
   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the
   *   release is fetched.
   * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.
   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the
   *   release is fetched.
   * - If the user called `queryContentFromRef`: Use the provided ref. Fall back
   *   to the master ref if the ref is not a string.
   *
   * @returns The ref to use during a query.
   */
  async getResolvedRefString(params) {
    var _a, _b;
    if (this.refState.autoPreviewsEnabled) {
      let previewRef;
      let cookieJar;
      if ((_a = this.refState.httpRequest) == null ? void 0 : _a.headers) {
        if ("get" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get === "function") {
          cookieJar = this.refState.httpRequest.headers.get("cookie");
        } else if ("cookie" in this.refState.httpRequest.headers) {
          cookieJar = this.refState.httpRequest.headers.cookie;
        }
      } else if ((_b = globalThis.document) == null ? void 0 : _b.cookie) {
        cookieJar = globalThis.document.cookie;
      }
      if (cookieJar) {
        previewRef = (0,_lib_getPreviewCookie_js__WEBPACK_IMPORTED_MODULE_16__.getPreviewCookie)(cookieJar);
      }
      if (previewRef) {
        return previewRef;
      }
    }
    const cachedRepository = await this.getCachedRepository(params);
    const refModeType = this.refState.mode;
    if (refModeType === RefStateMode.ReleaseID) {
      return (0,_lib_findRefByID_js__WEBPACK_IMPORTED_MODULE_10__.findRefByID)(cachedRepository.refs, this.refState.releaseID).ref;
    } else if (refModeType === RefStateMode.ReleaseLabel) {
      return (0,_lib_findRefByLabel_js__WEBPACK_IMPORTED_MODULE_11__.findRefByLabel)(cachedRepository.refs, this.refState.releaseLabel).ref;
    } else if (refModeType === RefStateMode.Manual) {
      const res = await (0,_lib_castThunk_js__WEBPACK_IMPORTED_MODULE_17__.castThunk)(this.refState.ref)();
      if (typeof res === "string") {
        return res;
      }
    }
    return (0,_lib_findMasterRef_js__WEBPACK_IMPORTED_MODULE_12__.findMasterRef)(cachedRepository.refs).ref;
  }
  /**
   * Performs a network request using the configured `fetch` function. It
   * assumes all successful responses will have a JSON content type. It also
   * normalizes unsuccessful network requests.
   *
   * @typeParam T - The JSON response.
   *
   * @param url - URL to the resource to fetch.
   * @param params - Prismic REST API parameters for the network request.
   *
   * @returns The JSON response from the network request.
   */
  async fetch(url, params = {}) {
    var _a, _b, _c, _d;
    const requestInit = {
      ...this.fetchOptions,
      ...params.fetchOptions,
      headers: {
        ...(_a = this.fetchOptions) == null ? void 0 : _a.headers,
        ...(_b = params.fetchOptions) == null ? void 0 : _b.headers
      },
      signal: ((_c = params.fetchOptions) == null ? void 0 : _c.signal) || params.signal || ((_d = this.fetchOptions) == null ? void 0 : _d.signal)
    };
    let job;
    if (this.fetchJobs[url] && this.fetchJobs[url].has(requestInit.signal)) {
      job = this.fetchJobs[url].get(requestInit.signal);
    } else {
      this.fetchJobs[url] = this.fetchJobs[url] || /* @__PURE__ */ new Map();
      job = this.fetchFn(url, requestInit).then(async (res2) => {
        let json = void 0;
        try {
          json = await res2.json();
        } catch {
        }
        return {
          status: res2.status,
          json
        };
      }).finally(() => {
        this.fetchJobs[url].delete(requestInit.signal);
        if (this.fetchJobs[url].size === 0) {
          delete this.fetchJobs[url];
        }
      });
      this.fetchJobs[url].set(requestInit.signal, job);
    }
    const res = await job;
    if (res.status !== 404 && res.json == null) {
      throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError(void 0, url, res.json);
    }
    switch (res.status) {
      case 200: {
        return res.json;
      }
      case 400: {
        throw new _errors_ParsingError_js__WEBPACK_IMPORTED_MODULE_18__.ParsingError(res.json.message, url, res.json);
      }
      case 401:
      case 403: {
        throw new _errors_ForbiddenError_js__WEBPACK_IMPORTED_MODULE_19__.ForbiddenError("error" in res.json ? res.json.error : res.json.message, url, res.json);
      }
      case 404: {
        throw new _errors_NotFoundError_js__WEBPACK_IMPORTED_MODULE_20__.NotFoundError(`Prismic repository not found. Check that "${this.endpoint}" is pointing to the correct repository.`, url, void 0);
      }
    }
    throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError(void 0, url, res.json);
  }
}

//# sourceMappingURL=createClient.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/errors/ForbiddenError.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/errors/ForbiddenError.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForbiddenError: () => (/* binding */ ForbiddenError)
/* harmony export */ });
/* harmony import */ var _PrismicError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");

class ForbiddenError extends _PrismicError_js__WEBPACK_IMPORTED_MODULE_0__.PrismicError {
}

//# sourceMappingURL=ForbiddenError.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/errors/NotFoundError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/errors/NotFoundError.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError)
/* harmony export */ });
/* harmony import */ var _PrismicError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");

class NotFoundError extends _PrismicError_js__WEBPACK_IMPORTED_MODULE_0__.PrismicError {
}

//# sourceMappingURL=NotFoundError.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/errors/ParsingError.js":
/*!********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/errors/ParsingError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParsingError: () => (/* binding */ ParsingError)
/* harmony export */ });
/* harmony import */ var _PrismicError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");

class ParsingError extends _PrismicError_js__WEBPACK_IMPORTED_MODULE_0__.PrismicError {
}

//# sourceMappingURL=ParsingError.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/errors/PrismicError.js":
/*!********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/errors/PrismicError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrismicError: () => (/* binding */ PrismicError)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PrismicError extends Error {
  constructor(message = "An invalid API response was returned", url, response) {
    super(message);
    __publicField(this, "url");
    __publicField(this, "response");
    this.url = url;
    this.response = response;
  }
}

//# sourceMappingURL=PrismicError.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/filter.js":
/*!*******************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/filter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filter: () => (/* binding */ filter)
/* harmony export */ });
const formatValue = (value) => {
  if (Array.isArray(value)) {
    return `[${value.map(formatValue).join(", ")}]`;
  }
  if (typeof value === "string") {
    return `"${value}"`;
  }
  if (value instanceof Date) {
    return `${value.getTime()}`;
  }
  return `${value}`;
};
const pathWithArgsFilter = (name) => {
  const fn = (path, ...args) => {
    const formattedArgs = args.map(formatValue).join(", ");
    const joiner = path && args.length ? ", " : "";
    return `[${name}(${path}${joiner}${formattedArgs})]`;
  };
  return fn;
};
const pathFilter = (name) => {
  const filterFn = pathWithArgsFilter(name);
  const fn = (path) => {
    return filterFn(path);
  };
  return fn;
};
const argsFilter = (name) => {
  const filterFn = pathWithArgsFilter(name);
  const fn = (...args) => {
    return filterFn("", ...args);
  };
  return fn;
};
const filter = {
  /**
   * The `at` filter checks that the path matches the described value exactly.
   * It takes a single value for a field or an array (only for tags).
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#at}
   */
  at: pathWithArgsFilter("at"),
  /**
   * The `not` filter checks that the path doesn't match the provided value
   * exactly. It takes a single value for a field or an array (only for tags).
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#not}
   */
  not: pathWithArgsFilter("not"),
  /**
   * The `any` filter takes an array of values. It works exactly the same way as
   * the `at` operator, but checks whether the fragment matches any of the
   * values in the array.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#any}
   */
  any: pathWithArgsFilter("any"),
  /**
   * The `in` filter is used specifically to retrieve an array of documents by
   * their IDs or UIDs. This filter is much more efficient at this than the any
   * filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#in}
   */
  in: pathWithArgsFilter("in"),
  /**
   * The `fulltext` filter provides two capabilities:
   *
   * 1. Checking if a certain string is anywhere inside a document (this is what
   *    you should use to make your project's search engine feature)
   * 2. Checking if the string is contained inside a specific custom type’s Rich
   *    Text or Key Text fragment.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}
   */
  fulltext: pathWithArgsFilter("fulltext"),
  /**
   * The `has` filter checks whether a fragment has a value. It will return all
   * the documents of the specified type that contain a value for the specified
   * field.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#has}
   */
  has: pathFilter("has"),
  /**
   * The `missing` filter checks if a fragment doesn't have a value. It will
   * return all the documents of the specified type that do not contain a value
   * for the specified field.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#missing}
   */
  missing: pathFilter("missing"),
  /**
   * The `similar` filter takes the ID of a document, and returns a list of
   * documents with similar content. This allows you to build an automated
   * content discovery feature (for example, a "Related posts" section).
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#similar}
   */
  similar: argsFilter("similar"),
  /**
   * The `geopoint.near` filter checks that the value in the path is within the
   * radius of the given coordinates.
   *
   * This filter will only work for a geopoint field.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}
   */
  geopointNear: pathWithArgsFilter("geopoint.near"),
  /**
   * The `number.lt` filter checks that the value in the number field is less
   * than the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}
   */
  numberLessThan: pathWithArgsFilter("number.lt"),
  /**
   * The `number.gt` filter checks that the value in the number field is greater
   * than the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}
   */
  numberGreaterThan: pathWithArgsFilter("number.gt"),
  /**
   * The `number.inRange` filter checks that the value in the path is within the
   * two values passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}
   */
  numberInRange: pathWithArgsFilter("number.inRange"),
  /**
   * The `date.after` filter checks that the value in the path is after the date
   * value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateAfter: pathWithArgsFilter("date.after"),
  /**
   * The `date.before` filter checks that the value in the path is before the
   * date value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateBefore: pathWithArgsFilter("date.before"),
  /**
   * The `date.between` filter checks that the value in the path is within the
   * date values passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateBetween: pathWithArgsFilter("date.between"),
  /**
   * The `date.day-of-month` filter checks that the value in the path is equal
   * to the day of the month passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfMonth: pathWithArgsFilter("date.day-of-month"),
  /**
   * The `date.day-of-month-after` filter checks that the value in the path is
   * after the day of the month passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfMonthAfter: pathWithArgsFilter("date.day-of-month-after"),
  /**
   * The `date.day-of-month-before` filter checks that the value in the path is
   * before the day of the month passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfMonthBefore: pathWithArgsFilter("date.day-of-month-before"),
  /**
   * The `date.day-of-week` filter checks that the value in the path is equal to
   * the day of the week passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfWeek: pathWithArgsFilter("date.day-of-week"),
  /**
   * The `date.day-of-week-after` filter checks that the value in the path is
   * after the day of the week passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfWeekAfter: pathWithArgsFilter("date.day-of-week-after"),
  /**
   * The date.day-of-week-before filter checks that the value in the path is
   * before the day of the week passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfWeekBefore: pathWithArgsFilter("date.day-of-week-before"),
  /**
   * The `date.month` filter checks that the value in the path occurs in the
   * month value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateMonth: pathWithArgsFilter("date.month"),
  /**
   * The `date.month-after` filter checks that the value in the path occurs in
   * any month after the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateMonthAfter: pathWithArgsFilter("date.month-after"),
  /**
   * The `date.month-before` filter checks that the value in the path occurs in
   * any month before the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateMonthBefore: pathWithArgsFilter("date.month-before"),
  /**
   * The `date.year` filter checks that the value in the path occurs in the year
   * value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateYear: pathWithArgsFilter("date.year"),
  /**
   * The `date.hour` filter checks that the value in the path occurs within the
   * hour value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateHour: pathWithArgsFilter("date.hour"),
  /**
   * The `date.hour-after` filter checks that the value in the path occurs after
   * the hour value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateHourAfter: pathWithArgsFilter("date.hour-after"),
  /**
   * The `date.hour-before` filter checks that the value in the path occurs
   * before the hour value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateHourBefore: pathWithArgsFilter("date.hour-before")
};

//# sourceMappingURL=filter.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/getRepositoryEndpoint.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/getRepositoryEndpoint.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRepositoryEndpoint: () => (/* binding */ getRepositoryEndpoint)
/* harmony export */ });
/* harmony import */ var _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors/PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");
/* harmony import */ var _isRepositoryName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isRepositoryName.js */ "./node_modules/@prismicio/client/dist/isRepositoryName.js");


const getRepositoryEndpoint = (repositoryName) => {
  if ((0,_isRepositoryName_js__WEBPACK_IMPORTED_MODULE_0__.isRepositoryName)(repositoryName)) {
    return `https://${repositoryName}.cdn.prismic.io/api/v2`;
  } else {
    throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_1__.PrismicError(`An invalid Prismic repository name was given: ${repositoryName}`, void 0, void 0);
  }
};

//# sourceMappingURL=getRepositoryEndpoint.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/getRepositoryName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/getRepositoryName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRepositoryName: () => (/* binding */ getRepositoryName)
/* harmony export */ });
/* harmony import */ var _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors/PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");

const getRepositoryName = (repositoryEndpoint) => {
  try {
    return new URL(repositoryEndpoint).hostname.split(".")[0];
  } catch {
    throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_0__.PrismicError(`An invalid Prismic Rest API V2 endpoint was provided: ${repositoryEndpoint}`, void 0, void 0);
  }
};

//# sourceMappingURL=getRepositoryName.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/helpers/asLink.js":
/*!***************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/helpers/asLink.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asLink: () => (/* binding */ asLink)
/* harmony export */ });
/* harmony import */ var _types_value_link_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/value/link.js */ "./node_modules/@prismicio/client/dist/types/value/link.js");
/* harmony import */ var _documentToLinkField_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentToLinkField.js */ "./node_modules/@prismicio/client/dist/helpers/documentToLinkField.js");


const asLink = (linkFieldOrDocument, ...configObjectOrTuple) => {
  if (!linkFieldOrDocument) {
    return null;
  }
  const linkField = (
    // prettier-ignore
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501
    // TODO: Remove the `prettier-ignore` comment when this bug is fixed.
    "link_type" in linkFieldOrDocument ? linkFieldOrDocument : (0,_documentToLinkField_js__WEBPACK_IMPORTED_MODULE_0__.documentToLinkField)(linkFieldOrDocument)
  );
  const [configObjectOrLinkResolver] = configObjectOrTuple;
  let config;
  if (typeof configObjectOrLinkResolver === "function" || configObjectOrLinkResolver == null) {
    config = {
      linkResolver: configObjectOrLinkResolver
    };
  } else {
    config = { ...configObjectOrLinkResolver };
  }
  switch (linkField.link_type) {
    case _types_value_link_js__WEBPACK_IMPORTED_MODULE_1__.LinkType.Media:
    case _types_value_link_js__WEBPACK_IMPORTED_MODULE_1__.LinkType.Web:
      return "url" in linkField ? linkField.url : null;
    case _types_value_link_js__WEBPACK_IMPORTED_MODULE_1__.LinkType.Document: {
      if ("id" in linkField && config.linkResolver) {
        const resolvedURL = config.linkResolver(linkField);
        if (resolvedURL != null) {
          return resolvedURL;
        }
      }
      if ("url" in linkField && linkField.url) {
        return linkField.url;
      }
      return null;
    }
    case _types_value_link_js__WEBPACK_IMPORTED_MODULE_1__.LinkType.Any:
    default:
      return null;
  }
};

//# sourceMappingURL=asLink.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/helpers/documentToLinkField.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/helpers/documentToLinkField.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   documentToLinkField: () => (/* binding */ documentToLinkField)
/* harmony export */ });
/* harmony import */ var _types_value_link_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/value/link.js */ "./node_modules/@prismicio/client/dist/types/value/link.js");

const documentToLinkField = (prismicDocument) => {
  var _a;
  return {
    link_type: _types_value_link_js__WEBPACK_IMPORTED_MODULE_0__.LinkType.Document,
    id: prismicDocument.id,
    uid: prismicDocument.uid || void 0,
    type: prismicDocument.type,
    tags: prismicDocument.tags,
    lang: prismicDocument.lang,
    url: prismicDocument.url == null ? void 0 : prismicDocument.url,
    slug: (_a = prismicDocument.slugs) == null ? void 0 : _a[0],
    // The REST API does not include a `data` property if the data
    // object is empty.
    //
    // A presence check for `prismicDocument.data` is done to
    // support partial documents. While `documentToLinkField` is
    // not typed to accept partial documents, passing a partial
    // document can happen in untyped projects.
    ...prismicDocument.data && Object.keys(prismicDocument.data).length > 0 ? { data: prismicDocument.data } : {}
  };
};

//# sourceMappingURL=documentToLinkField.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/isRepositoryEndpoint.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/isRepositoryEndpoint.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRepositoryEndpoint: () => (/* binding */ isRepositoryEndpoint)
/* harmony export */ });
const isRepositoryEndpoint = (input) => {
  try {
    new URL(input);
    return true;
  } catch {
    return false;
  }
};

//# sourceMappingURL=isRepositoryEndpoint.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/isRepositoryName.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/isRepositoryName.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRepositoryName: () => (/* binding */ isRepositoryName)
/* harmony export */ });
const isRepositoryName = (input) => {
  return /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);
};

//# sourceMappingURL=isRepositoryName.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/appendFilters.js":
/*!******************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/appendFilters.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendFilters: () => (/* binding */ appendFilters)
/* harmony export */ });
/* harmony import */ var _castArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./castArray.js */ "./node_modules/@prismicio/client/dist/lib/castArray.js");

const appendFilters = (objWithFilters = {}, filters) => {
  return {
    ...objWithFilters,
    filters: [...objWithFilters.filters || [], ...(0,_castArray_js__WEBPACK_IMPORTED_MODULE_0__.castArray)(filters)]
  };
};

//# sourceMappingURL=appendFilters.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/castArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/castArray.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   castArray: () => (/* binding */ castArray)
/* harmony export */ });
const castArray = (a) => {
  return Array.isArray(a) ? a : [a];
};

//# sourceMappingURL=castArray.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/castThunk.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/castThunk.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   castThunk: () => (/* binding */ castThunk)
/* harmony export */ });
const castThunk = (a) => {
  return typeof a === "function" ? a : () => a;
};

//# sourceMappingURL=castThunk.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/devMsg.js":
/*!***********************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/devMsg.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   devMsg: () => (/* binding */ devMsg)
/* harmony export */ });
/* harmony import */ var _package_json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json.js */ "./node_modules/@prismicio/client/dist/package.json.js");

const devMsg = (slug) => {
  return `https://prismic.dev/msg/client/v${_package_json_js__WEBPACK_IMPORTED_MODULE_0__.version}/${slug}`;
};

//# sourceMappingURL=devMsg.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/everyTagFilter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/everyTagFilter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   everyTagFilter: () => (/* binding */ everyTagFilter)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ "./node_modules/@prismicio/client/dist/filter.js");
/* harmony import */ var _castArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./castArray.js */ "./node_modules/@prismicio/client/dist/lib/castArray.js");


const everyTagFilter = (tags) => {
  return _filter_js__WEBPACK_IMPORTED_MODULE_0__.filter.at("document.tags", (0,_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(tags));
};

//# sourceMappingURL=everyTagFilter.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/findMasterRef.js":
/*!******************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/findMasterRef.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findMasterRef: () => (/* binding */ findMasterRef)
/* harmony export */ });
/* harmony import */ var _findRef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findRef.js */ "./node_modules/@prismicio/client/dist/lib/findRef.js");

const findMasterRef = (refs) => {
  return (0,_findRef_js__WEBPACK_IMPORTED_MODULE_0__.findRef)(refs, (ref) => ref.isMasterRef);
};

//# sourceMappingURL=findMasterRef.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/findRef.js":
/*!************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/findRef.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findRef: () => (/* binding */ findRef)
/* harmony export */ });
/* harmony import */ var _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/PrismicError.js */ "./node_modules/@prismicio/client/dist/errors/PrismicError.js");

const findRef = (refs, filter) => {
  const ref = refs.find((ref2) => filter(ref2));
  if (!ref) {
    throw new _errors_PrismicError_js__WEBPACK_IMPORTED_MODULE_0__.PrismicError("Ref could not be found.", void 0, void 0);
  }
  return ref;
};

//# sourceMappingURL=findRef.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/findRefByID.js":
/*!****************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/findRefByID.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findRefByID: () => (/* binding */ findRefByID)
/* harmony export */ });
/* harmony import */ var _findRef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findRef.js */ "./node_modules/@prismicio/client/dist/lib/findRef.js");

const findRefByID = (refs, id) => {
  return (0,_findRef_js__WEBPACK_IMPORTED_MODULE_0__.findRef)(refs, (ref) => ref.id === id);
};

//# sourceMappingURL=findRefByID.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/findRefByLabel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/findRefByLabel.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findRefByLabel: () => (/* binding */ findRefByLabel)
/* harmony export */ });
/* harmony import */ var _findRef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findRef.js */ "./node_modules/@prismicio/client/dist/lib/findRef.js");

const findRefByLabel = (refs, label) => {
  return (0,_findRef_js__WEBPACK_IMPORTED_MODULE_0__.findRef)(refs, (ref) => ref.label === label);
};

//# sourceMappingURL=findRefByLabel.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/getPreviewCookie.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/getPreviewCookie.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPreviewCookie: () => (/* binding */ getPreviewCookie)
/* harmony export */ });
/* harmony import */ var _cookie_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cookie.js */ "./node_modules/@prismicio/client/dist/cookie.js");

const readValue = (value) => {
  return value.replace(/%3B/g, ";");
};
const getPreviewCookie = (cookieJar) => {
  const cookies = cookieJar.split("; ");
  let value;
  for (const cookie of cookies) {
    const parts = cookie.split("=");
    const name = readValue(parts[0]).replace(/%3D/g, "=");
    if (name === _cookie_js__WEBPACK_IMPORTED_MODULE_0__.preview) {
      value = readValue(parts.slice(1).join("="));
      break;
    }
  }
  return value;
};

//# sourceMappingURL=getPreviewCookie.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/minifyGraphQLQuery.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/minifyGraphQLQuery.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   minifyGraphQLQuery: () => (/* binding */ minifyGraphQLQuery)
/* harmony export */ });
const minifyGraphQLQuery = (query) => {
  return query.replace(/(\n| )*( |{|})(\n| )*/gm, (_chars, _spaces, brackets) => brackets);
};

//# sourceMappingURL=minifyGraphQLQuery.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/someTagsFilter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/someTagsFilter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   someTagsFilter: () => (/* binding */ someTagsFilter)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ "./node_modules/@prismicio/client/dist/filter.js");
/* harmony import */ var _castArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./castArray.js */ "./node_modules/@prismicio/client/dist/lib/castArray.js");


const someTagsFilter = (tags) => {
  return _filter_js__WEBPACK_IMPORTED_MODULE_0__.filter.any("document.tags", (0,_castArray_js__WEBPACK_IMPORTED_MODULE_1__.castArray)(tags));
};

//# sourceMappingURL=someTagsFilter.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/lib/typeFilter.js":
/*!***************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/lib/typeFilter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   typeFilter: () => (/* binding */ typeFilter)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ "./node_modules/@prismicio/client/dist/filter.js");

const typeFilter = (documentType) => {
  return _filter_js__WEBPACK_IMPORTED_MODULE_0__.filter.at("document.type", documentType);
};

//# sourceMappingURL=typeFilter.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/package.json.js":
/*!*************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/package.json.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
const version = "7.1.0";

//# sourceMappingURL=package.json.js.map


/***/ }),

/***/ "./node_modules/@prismicio/client/dist/types/value/link.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@prismicio/client/dist/types/value/link.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinkType: () => (/* binding */ LinkType)
/* harmony export */ });
const LinkType = {
  Any: "Any",
  Document: "Document",
  Media: "Media",
  Web: "Web"
};

//# sourceMappingURL=link.js.map


/***/ })

};
;
//# sourceMappingURL=node_modules_gatsby-plugin-prismic-previews_dist_lib_resolvePrismicPreview_js.js.map